{
    "def_names": [
        "fun merge_wrt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"merge_wrt _ xs [] = xs\"|\n  \"merge_wrt rel [] ys = ys\"|\n  \"merge_wrt rel (x # xs) (y # ys) =\n    (if x = y then\n      y # (merge_wrt rel xs ys)\n    else if rel x y then\n      x # (merge_wrt rel xs (y # ys))\n    else\n      y # (merge_wrt rel (x # xs) ys)\n    )\""
    ],
    "problem_names": [
        "lemma subset_imageE_inj:\n  assumes \"B \\<subseteq> f ` A\"\n  obtains C where \"C \\<subseteq> A\" and \"B = f ` C\" and \"inj_on f C\"",
        "lemma wfP_chain:\n  assumes \"\\<not>(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i))\"\n  shows \"wfP r\"",
        "lemma transp_sequence:\n  assumes \"transp r\" and \"\\<And>i. r (seq (Suc i)) (seq i)\" and \"i < j\"\n  shows \"r (seq j) (seq i)\"",
        "lemma almost_full_on_finite_subsetE:\n  assumes \"reflp P\" and \"almost_full_on P S\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. P t s)\"",
        "lemma map_upt: \"map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs\"",
        "lemma map_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map (\\<lambda>(x, y). f x y) (zip xs ys)\" (is \"?l = ?r\")",
        "lemma distinct_sorted_wrt_irrefl:\n  assumes \"irreflp rel\" and \"transp rel\" and \"sorted_wrt rel xs\"\n  shows \"distinct xs\"",
        "lemma distinct_sorted_wrt_imp_sorted_wrt_strict:\n  assumes \"distinct xs\" and \"sorted_wrt rel xs\"\n  shows \"sorted_wrt (\\<lambda>x y. rel x y \\<and> \\<not> x = y) xs\"",
        "lemma sorted_wrt_distinct_set_unique:\n  assumes \"antisymp rel\"\n  assumes \"sorted_wrt rel xs\" \"distinct xs\" \"sorted_wrt rel ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\"",
        "lemma sorted_wrt_refl_nth_mono:\n  assumes \"reflp P\" and \"sorted_wrt P xs\" and \"i \\<le> j\" and \"j < length xs\"\n  shows \"P (xs ! i) (xs ! j)\"",
        "lemma set_merge_wrt: \"set (merge_wrt rel xs ys) = set xs \\<union> set ys\"",
        "lemma sorted_merge_wrt:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"sorted_wrt rel xs\" and \"sorted_wrt rel ys\"\n  shows \"sorted_wrt rel (merge_wrt rel xs ys)\"",
        "lemma set_fold:\n  assumes \"\\<And>x ys. set (f (g x) ys) = set (g x) \\<union> set ys\"\n  shows \"set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys\"",
        "lemma additive_implies_homogenous:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f (y::'a::monoid_add))::'b::cancel_comm_monoid_add)\"\n  shows \"f 0 = 0\"",
        "lemma fun_sum_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"",
        "lemma fun_sum_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"",
        "lemma fun_sum_list_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"",
        "lemma fun_sum_list_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"",
        "lemma sum_set_upt_eq_sum_list: \"(\\<Sum>i = m..<n. f i) = (\\<Sum>i\\<leftarrow>[m..<n]. f i)\"",
        "lemma sum_list_upt: \"(\\<Sum>i\\<leftarrow>[0..<(length xs)]. f (xs ! i)) = (\\<Sum>x\\<leftarrow>xs. f x)\"",
        "lemma sum_list_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"(\\<Sum>i\\<leftarrow>[0..<(length ys)]. f (xs ! i) (ys ! i)) = (\\<Sum>(x, y)\\<leftarrow>(zip xs ys). f x y)\"",
        "lemma sum_list_zeroI:\n  assumes \"set xs \\<subseteq> {0}\"\n  shows \"sum_list xs = 0\"",
        "lemma fun_prod_commute:\n  assumes \"f 1 = 1\" and \"\\<And>x y. f (x * y) = f x * f y\"\n  shows \"f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\""
    ],
    "translations": [
        [
            "",
            "section \\<open>Utilities\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "theory Utils\n  imports Main Well_Quasi_Orders.Almost_Full_Relations\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lemma subset_imageE_inj:\n  assumes \"B \\<subseteq> f ` A\"\n  obtains C where \"C \\<subseteq> A\" and \"B = f ` C\" and \"inj_on f C\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "define g where \"g = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have \"g b \\<in> A \\<and> f (g b) = b\" if \"b \\<in> B\" for b",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "proof -",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "from that assms",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb \\<in> B\nB \\<subseteq> f ` A",
            "have \"b \\<in> f ` A\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> B\nB \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. b \\<in> f ` A",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> f ` A\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "then",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb \\<in> f ` A",
            "obtain a where \"a \\<in> A\" and \"b = f a\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> A; b = f a\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na \\<in> A\nb = f a\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "hence \"a \\<in> A \\<and> f a = b\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> A\nb = f a\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<and> f a = b",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b",
            "unfolding g_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> A \\<and> f a = b) \\<in> A \\<and> f (SOME a. a \\<in> A \\<and> f a = b) = b",
            "by (rule someI)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng b \\<in> A \\<and> f (g b) = b\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "hence 1: \"\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A\" and 2: \"\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A) &&& (\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b)",
            "by simp_all",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A\n?b \\<in> B \\<Longrightarrow> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "let ?C = \"g ` B\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. thesis",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. ?C \\<subseteq> A\n 2. B = f ` ?C\n 3. inj_on f ?C",
            "show \"?C \\<subseteq> A\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g ` B \\<subseteq> A",
            "by (auto intro: 1)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng ` B \\<subseteq> A\n\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)",
            "show \"B = f ` ?C\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. B = f ` g ` B",
            "proof (rule set_eqI)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)",
            "fix b",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)",
            "show \"b \\<in> B \\<longleftrightarrow> b \\<in> f ` ?C\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (b \\<in> B) = (b \\<in> f ` g ` B)",
            "proof",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "assume \"b \\<in> B\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "from this",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb \\<in> B",
            "have \"f (g b) = b\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b) = b",
            "by (rule 2)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (g b) = b\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb \\<in> B\nf (g b) = b",
            "show \"b \\<in> f ` ?C\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> B\nf (g b) = b\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B",
            "by force",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "assume \"b \\<in> f ` ?C\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "then",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb \\<in> f ` g ` B",
            "obtain b' where \"b' \\<in> B\" and \"b = f (g b')\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'. \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding image_image",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> (\\<lambda>x. f (g x)) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'. \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "..",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb' \\<in> B\nb = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb' \\<in> B\nb = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "from this(1)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb' \\<in> B",
            "have \"f (g b') = b'\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb' \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b') = b'",
            "by (rule 2)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nb' \\<in> B\nb = f (g b')\nf (g b') = b'",
            "show \"b \\<in> B\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb' \\<in> B\nb = f (g b')\nf (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> B",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> B\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(b \\<in> B) = (b \\<in> f ` g ` B)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB = f ` g ` B\n\ngoal (1 subgoal):\n 1. inj_on f (g ` B)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)",
            "show \"inj_on f ?C\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)",
            "proof",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "fix x y",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "assume \"x \\<in> ?C\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "then",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> g ` B",
            "obtain bx where \"bx \\<in> B\" and x: \"x = g bx\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>bx. \\<lbrakk>bx \\<in> B; x = g bx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbx \\<in> B\nx = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbx \\<in> B\nx = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "from this(1)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbx \\<in> B",
            "have \"f (g bx) = bx\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbx \\<in> B\n\ngoal (1 subgoal):\n 1. f (g bx) = bx",
            "by (rule 2)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (g bx) = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbx \\<in> B\nx = g bx\nf (g bx) = bx",
            "have *: \"f x = bx\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbx \\<in> B\nx = g bx\nf (g bx) = bx\n\ngoal (1 subgoal):\n 1. f x = bx",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "assume \"y \\<in> ?C\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "then",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny \\<in> g ` B",
            "obtain \"by\" where \"by \\<in> B\" and y: \"y = g by\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>by. \\<lbrakk>by \\<in> B; y = g by\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nby \\<in> B\ny = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nby \\<in> B\ny = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "from this(1)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nby \\<in> B",
            "have \"f (g by) = by\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nby \\<in> B\n\ngoal (1 subgoal):\n 1. f (g by) = by",
            "by (rule 2)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (g by) = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nby \\<in> B\ny = g by\nf (g by) = by",
            "have \"f y = by\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nby \\<in> B\ny = g by\nf (g by) = by\n\ngoal (1 subgoal):\n 1. f y = by",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "assume \"f x = f y\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf y = by\nf x = f y",
            "have \"bx = by\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf y = by\nf x = f y\n\ngoal (1 subgoal):\n 1. bx = by",
            "using *",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf y = by\nf x = f y\nf x = bx\n\ngoal (1 subgoal):\n 1. bx = by",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbx = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y",
            "thus \"x = y\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbx = by\n\ngoal (1 subgoal):\n 1. x = y",
            "by (simp only: x y)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on f (g ` B)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nthesis\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma wfP_chain:\n  assumes \"\\<not>(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i))\"\n  shows \"wfP r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wfP r",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. wfP r",
            "from assms wf_iff_no_infinite_down_chain[of \"{(x, y). r x y}\"]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\nwf {(x, y). r x y} = (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})",
            "have \"wf {(x, y). r x y}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\nwf {(x, y). r x y} = (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r",
            "thus \"wfP r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r",
            "unfolding wfP_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwfP r\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma transp_sequence:\n  assumes \"transp r\" and \"\\<And>i. r (seq (Suc i)) (seq i)\" and \"i < j\"\n  shows \"r (seq j) (seq i)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "have \"\\<And>k. r (seq (i + Suc k)) (seq i)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)",
            "proof -",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)",
            "fix k::nat",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)",
            "show \"r (seq (i + Suc k)) (seq i)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r (seq (i + Suc k)) (seq i)",
            "proof (induct k)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "case 0",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "from assms(2)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr (seq (Suc ?i)) (seq ?i)",
            "have \"r (seq (Suc i)) (seq i)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc i)) (seq i)",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (Suc i)) (seq i)\n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "thus ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc 0)) (seq i)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc 0)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "case (Suc k)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "note assms(1)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ntransp r\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ntransp r\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "from assms(2)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr (seq (Suc ?i)) (seq ?i)",
            "have \"r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "have \"r (seq (Suc (i + k))) (seq i)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)",
            "using Suc.hyps",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ntransp r\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\nr (seq (Suc (i + k))) (seq i)",
            "have \"r (seq (Suc (Suc i + k))) (seq i)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntransp r\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\nr (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq i)",
            "by (rule transpD)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)",
            "thus ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (Suc k))) (seq i)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc (Suc k))) (seq i)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc k)) (seq i)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "hence \"r (seq (i + Suc(j - i - 1))) (seq i)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (j - i - 1))) (seq i)",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "thus \"r (seq j) (seq i)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "using \\<open>i < j\\<close>",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr (seq (i + Suc (j - i - 1))) (seq i)\ni < j\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr (seq j) (seq i)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma almost_full_on_finite_subsetE:\n  assumes \"reflp P\" and \"almost_full_on P S\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. P t s)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "define crit where \"crit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have critD: \"s \\<notin> U\" if \"crit U s\" for U s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> U",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "assume \"s \\<in> U\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns \\<in> U\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "from \\<open>crit U s\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncrit U s",
            "have \"\\<forall>u\\<in>U. \\<not> P u s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncrit U s\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s",
            "unfolding crit_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>u\\<in>U. \\<not> P u s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "from this \\<open>s \\<in> U\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>u\\<in>U. \\<not> P u s\ns \\<in> U",
            "have \"\\<not> P s s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>u\\<in>U. \\<not> P u s\ns \\<in> U\n\ngoal (1 subgoal):\n 1. \\<not> P s s",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "from assms(1)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nreflp P",
            "have \"P s s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P s s",
            "by (rule reflpD)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nP s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> P s s\nP s s",
            "show False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> P s s\nP s s\n\ngoal (1 subgoal):\n 1. False",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit ?U ?s \\<Longrightarrow> ?s \\<notin> ?U\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "define \"fun\"\n    where \"fun = (\\<lambda>U. (if (\\<exists>s. crit U s) then\n                        insert (SOME s. crit U s) U\n                      else\n                        U\n                      ))\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfun = (\\<lambda>U. if \\<exists>s. crit U s then insert (SOME s. crit U s) U else U)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "define seq where \"seq = rec_nat {} (\\<lambda>_. fun)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq = rec_nat {} (\\<lambda>_. fun)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have seq_Suc: \"seq (Suc i) = fun (seq i)\" for i",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. seq (Suc i) = fun (seq i)",
            "by (simp add: seq_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq (Suc ?i) = fun (seq ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have seq_incr_Suc: \"seq i \\<subseteq> seq (Suc i)\" for i",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq (Suc i)",
            "by (auto simp add: seq_Suc fun_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq ?i \\<subseteq> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have seq_incr: \"i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j\" for i j",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "proof -",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "assume \"i \\<le> j\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "hence \"i = j \\<or> i < j\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni \\<le> j\n\ngoal (1 subgoal):\n 1. i = j \\<or> i < j",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "thus \"seq i \\<subseteq> seq j\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j",
            "proof",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "assume \"i = j\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "thus ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni = j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "assume \"i < j\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j",
            "with _ seq_incr_Suc",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nPROP ?psi \\<Longrightarrow> PROP ?psi\nseq ?i \\<subseteq> seq (Suc ?i)\ni < j",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nPROP ?psi \\<Longrightarrow> PROP ?psi\nseq ?i \\<subseteq> seq (Suc ?i)\ni < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j",
            "by (rule transp_sequence, simp add: transp_def)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?i \\<le> ?j \\<Longrightarrow> seq ?i \\<subseteq> seq ?j\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have sub: \"seq i \\<subseteq> S\" for i",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S",
            "proof (induct i, simp add: seq_def, simp add: seq_Suc fun_def, rule)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S",
            "fix i",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S",
            "assume \"Ex (crit (seq i))\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nEx (crit (seq i))\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S",
            "hence \"crit (seq i) (Eps (crit (seq i)))\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nEx (crit (seq i))\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i)))",
            "by (rule someI_ex)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S",
            "thus \"Eps (crit (seq i)) \\<in> S\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<in> S",
            "by (simp add: crit_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nEps (crit (seq i)) \\<in> S\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq ?i \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "have \"\\<exists>i. seq (Suc i) = seq i\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. seq (Suc i) = seq i",
            "proof (rule ccontr, simp)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "assume \"\\<forall>i. seq (Suc i) \\<noteq> seq i\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "with seq_incr_Suc",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq ?i \\<subseteq> seq (Suc ?i)\n\\<forall>i. seq (Suc i) \\<noteq> seq i",
            "have \"seq i \\<subset> seq (Suc i)\" for i",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq ?i \\<subseteq> seq (Suc ?i)\n\\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. seq i \\<subset> seq (Suc i)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq ?i \\<subset> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "define seq1 where \"seq1 = (\\<lambda>n. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n))\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 = (\\<lambda>n. SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "have seq1: \"seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n\" for n",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n",
            "unfolding seq1_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n) \\<in> seq (Suc n) \\<and> (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n) \\<notin> seq n",
            "proof (rule someI_ex)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n",
            "from \\<open>seq n \\<subset> seq (Suc n)\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq n \\<subset> seq (Suc n)",
            "show \"\\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq n \\<subset> seq (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n",
            "by blast",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "have \"seq1 i \\<in> S\" for i",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. seq1 i \\<in> S",
            "proof",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. seq1 i \\<in> ?A\n 2. ?A \\<subseteq> S",
            "from seq1[of i]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i",
            "show \"seq1 i \\<in> seq (Suc i)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq1 i \\<in> seq (Suc i)",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 i \\<in> seq (Suc i)\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<subseteq> S",
            "qed (fact sub)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "with assms(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nalmost_full_on P S\nseq1 ?i \\<in> S",
            "obtain a b where \"a < b\" and \"P (seq1 a) (seq1 b)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nalmost_full_on P S\nseq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>a b. \\<lbrakk>a < b; P (seq1 a) (seq1 b)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (rule almost_full_onD)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na < b\nP (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from \\<open>a < b\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\na < b",
            "have \"Suc a \\<le> b\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na < b\n\ngoal (1 subgoal):\n 1. Suc a \\<le> b",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nSuc a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from seq1",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n",
            "have \"seq1 a \\<in> seq (Suc a)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq (Suc a)",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "also",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from \\<open>Suc a \\<le> b\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nSuc a \\<le> b",
            "have \"... \\<subseteq> seq b\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nSuc a \\<le> b\n\ngoal (1 subgoal):\n 1. seq (Suc a) \\<subseteq> seq b",
            "by (rule seq_incr)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq (Suc a) \\<subseteq> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "finally",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq1 a \\<in> seq b",
            "have \"seq1 a \\<in> seq b\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq b",
            ".",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from seq1",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n",
            "have \"seq1 b \\<in> seq (Suc b)\" and \"seq1 b \\<notin> seq b\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 b \\<in> seq (Suc b) &&& seq1 b \\<notin> seq b",
            "by blast+",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq1 b \\<in> seq (Suc b)\nseq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "hence \"crit (seq b) (seq1 b)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq1 b \\<in> seq (Suc b)\nseq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. crit (seq b) (seq1 b)",
            "by (simp add: seq_Suc fun_def someI split: if_splits)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "hence \"\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncrit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)",
            "by (simp add: crit_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from this \\<open>seq1 a \\<in> seq b\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\nseq1 a \\<in> seq b",
            "have \"\\<not> P (seq1 a) (seq1 b)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<not> P (seq1 a) (seq1 b)",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> P (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False",
            "from this \\<open>P (seq1 a) (seq1 b)\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> P (seq1 a) (seq1 b)\nP (seq1 a) (seq1 b)",
            "show False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> P (seq1 a) (seq1 b)\nP (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. False",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>i. seq (Suc i) = seq i",
            "obtain i where \"seq (Suc i) = seq i\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>i. seq (Suc i) = seq i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. thesis",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. finite ?T\n 2. ?T \\<subseteq> S\n 3. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>?T. P t s",
            "show \"finite (seq i)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. finite (seq i)",
            "by (induct i, simp_all add: seq_def fun_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (seq i)\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s",
            "fix s",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s",
            "assume \"s \\<in> S\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns \\<in> S\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s",
            "let ?s = \"Eps (crit (seq i))\"",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s",
            "show \"\\<exists>t\\<in>seq i. P t s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>seq i. P t s",
            "proof (rule ccontr, simp)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "assume \"\\<forall>t\\<in>seq i. \\<not> P t s\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "with \\<open>s \\<in> S\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns \\<in> S\n\\<forall>t\\<in>seq i. \\<not> P t s",
            "have \"crit (seq i) s\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns \\<in> S\n\\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. crit (seq i) s",
            "by (simp only: crit_def)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit (seq i) s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "hence \"crit (seq i) ?s\" and eq: \"seq (Suc i) = insert ?s (seq i)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncrit (seq i) s\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i))) &&& seq (Suc i) = insert (Eps (crit (seq i))) (seq i)",
            "by (auto simp add: seq_Suc fun_def intro: someI)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncrit (seq i) (Eps (crit (seq i)))\nseq (Suc i) = insert (Eps (crit (seq i))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "from this(1)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncrit (seq i) (Eps (crit (seq i)))",
            "have \"?s \\<notin> seq i\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<notin> seq i",
            "by (rule critD)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "hence \"seq (Suc i) \\<noteq> seq i\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<noteq> seq i",
            "unfolding eq",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. insert (Eps (crit (seq i))) (seq i) \\<noteq> seq i",
            "by blast",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nseq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False",
            "from this \\<open>seq (Suc i) = seq i\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nseq (Suc i) \\<noteq> seq i\nseq (Suc i) = seq i",
            "show False",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nseq (Suc i) \\<noteq> seq i\nseq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. False",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>t\\<in>seq i. P t s\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S",
            "qed (fact sub)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nthesis\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Lists\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "lemma map_upt: \"map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs",
            "by (auto intro: nth_equalityI)",
            1,
            "NA"
        ],
        [
            "",
            "lemma map_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map (\\<lambda>(x, y). f x y) (zip xs ys)\" (is \"?l = ?r\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys",
            "have len_l: \"length ?l = length ys\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) = length ys",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlength (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nlength xs = length ys",
            "have len_r: \"length ?r = length ys\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlength xs = length ys\n\ngoal (1 subgoal):\n 1. length (map2 f xs ys) = length ys",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlength (map2 f xs ys) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys",
            "proof (simp only: list_eq_iff_nth_eq len_l len_r, rule, rule, intro allI impI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i",
            "fix i",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i",
            "assume \"i < length ys\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni < length ys\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i",
            "hence \"i < length ?l\" and \"i < length ?r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni < length ys\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) &&& i < length (map2 f xs ys)",
            "by (simp_all only: len_l len_r)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\ni < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i",
            "thus \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map (\\<lambda>(x, y). f x y) (zip xs ys) ! i\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\ni < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmap (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmap (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma distinct_sorted_wrt_irrefl:\n  assumes \"irreflp rel\" and \"transp rel\" and \"sorted_wrt rel xs\"\n  shows \"distinct xs\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. distinct xs",
            "using assms(3)",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs",
            "proof (induct xs)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel []\n\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. distinct []",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct []\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "case (Cons x xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs \\<Longrightarrow> distinct xs\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "from Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"sorted_wrt rel xs\" and *: \"\\<forall>y\\<in>set xs. rel x y\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs &&& \\<forall>y\\<in>set xs. rel x y",
            "by (simp_all)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\\<forall>y\\<in>set xs. rel x y\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "from this(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel xs",
            "have \"distinct xs\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs",
            "by (rule Cons(1))",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # xs)",
            "proof (simp add: \\<open>distinct xs\\<close>, rule)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False",
            "assume \"x \\<in> set xs\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>y\\<in>set xs. rel x y\nx \\<in> set xs",
            "have \"rel x x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>y\\<in>set xs. rel x y\nx \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x x",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False",
            "with assms(1)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nirreflp rel\nrel x x",
            "show False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nirreflp rel\nrel x x\n\ngoal (1 subgoal):\n 1. False",
            "by (simp add: irreflp_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct (x # xs)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma distinct_sorted_wrt_imp_sorted_wrt_strict:\n  assumes \"distinct xs\" and \"sorted_wrt rel xs\"\n  shows \"sorted_wrt (\\<lambda>x y. rel x y \\<and> \\<not> x = y) xs\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndistinct xs\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs",
            "proof (induct xs)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n 2. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct []\nsorted_wrt rel []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n 2. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)",
            "case step: (Cons x xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs\ndistinct (x # xs)\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "proof (cases \"xs\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nxs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "case (Cons y zs)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxs = y # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "from step(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndistinct (x # xs)",
            "have \"x \\<noteq> y\" and 1: \"distinct (y # zs)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndistinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& distinct (y # zs)",
            "by (simp_all add: Cons)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\ndistinct (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "from step(3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"rel x y\" and 2: \"sorted_wrt rel (y # zs)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. rel x y &&& sorted_wrt rel (y # zs)",
            "by (simp_all add: Cons)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x y\nsorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "from 1 2",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndistinct (y # zs)\nsorted_wrt rel (y # zs)",
            "have \"sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndistinct (y # zs)\nsorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)",
            "by (rule step(1)[simplified Cons])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "with \\<open>x \\<noteq> y\\<close> \\<open>rel x y\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "using step.prems",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\ndistinct (x # xs)\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)",
            "by (auto simp: Cons)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma sorted_wrt_distinct_set_unique:\n  assumes \"antisymp rel\"\n  assumes \"sorted_wrt rel xs\" \"distinct xs\" \"sorted_wrt rel ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. xs = ys",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. xs = ys",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nantisymp rel\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys",
            "have 1: \"length xs = length ys\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nantisymp rel\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. length xs = length ys",
            "by (auto dest!: distinct_card)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlength xs = length ys\n\ngoal (1 subgoal):\n 1. xs = ys",
            "from assms(2-6)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys",
            "proof(induct rule:list_induct2[OF 1])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct []; set [] = set []\\<rbrakk> \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "case 1",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel []\ndistinct []\nsorted_wrt rel []\ndistinct []\nset [] = set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct []; set [] = set []\\<rbrakk> \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. [] = []",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "case (2 x xs y ys)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlength xs = length ys\n\\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys\nsorted_wrt rel (x # xs)\ndistinct (x # xs)\nsorted_wrt rel (y # ys)\ndistinct (y # ys)\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "from 2(4)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndistinct (x # xs)",
            "have \"x \\<notin> set xs\" and \"distinct xs\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndistinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs &&& distinct xs",
            "by simp_all",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<notin> set xs\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "from 2(6)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndistinct (y # ys)",
            "have \"y \\<notin> set ys\" and \"distinct ys\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndistinct (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> set ys &&& distinct ys",
            "by simp_all",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<notin> set ys\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "have \"x = y\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x = y",
            "proof (rule ccontr)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "assume \"x \\<noteq> y\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "from 2(3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"\\<forall>z\\<in>set xs. rel x z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set xs. rel x z",
            "by (simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "from \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y",
            "have \"y \\<in> set xs\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<in> set xs",
            "using 2(7)",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>z\\<in>set xs. rel x z\ny \\<in> set xs",
            "have *: \"rel x y\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>z\\<in>set xs. rel x z\ny \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x y",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "from 2(5)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)",
            "have \"\\<forall>z\\<in>set ys. rel y z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set ys. rel y z",
            "by (simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "from \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y",
            "have \"x \\<in> set ys\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> set ys",
            "using 2(7)",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set ys",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>z\\<in>set ys. rel y z\nx \\<in> set ys",
            "have \"rel y x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>z\\<in>set ys. rel y z\nx \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y x",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "with assms(1) *",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nantisymp rel\nrel x y\nrel y x",
            "have \"x = y\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nantisymp rel\nrel x y\nrel y x\n\ngoal (1 subgoal):\n 1. x = y",
            "by (rule antisympD)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False",
            "with \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\nx = y",
            "show False",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nx = y\n\ngoal (1 subgoal):\n 1. False",
            "..",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "from 2(3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"sorted_wrt rel xs\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs",
            "by (simp)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "note \\<open>distinct xs\\<close>",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "from 2(5)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)",
            "have \"sorted_wrt rel ys\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys",
            "by (simp)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "note \\<open>distinct ys\\<close>",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "from 2(7) \\<open>x \\<notin> set xs\\<close> \\<open>y \\<notin> set ys\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nset (x # xs) = set (y # ys)\nx \\<notin> set xs\ny \\<notin> set ys",
            "have \"set xs = set ys\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nset (x # xs) = set (y # ys)\nx \\<notin> set xs\ny \\<notin> set ys\n\ngoal (1 subgoal):\n 1. set xs = set ys",
            "by (auto simp add: \\<open>x = y\\<close>)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset xs = set ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys",
            "have \"xs = ys\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys",
            "by (rule 2(2))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys",
            "with \\<open>x = y\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = y\nxs = ys",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = y\nxs = ys\n\ngoal (1 subgoal):\n 1. x # xs = y # ys",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx # xs = y # ys\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxs = ys\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma sorted_wrt_refl_nth_mono:\n  assumes \"reflp P\" and \"sorted_wrt P xs\" and \"i \\<le> j\" and \"j < length xs\"\n  shows \"P (xs ! i) (xs ! j)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)",
            "proof (cases \"i < j\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "from assms(2) this assms(4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt P xs\ni < j\nj < length xs",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt P xs\ni < j\nj < length xs\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)",
            "by (rule sorted_wrt_nth_less)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nP (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "with assms(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ni \\<le> j\n\\<not> i < j",
            "have \"i = j\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ni \\<le> j\n\\<not> i < j\n\ngoal (1 subgoal):\n 1. i = j",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ni = j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nreflp P",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)",
            "unfolding \\<open>i = j\\<close>",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P (xs ! j) (xs ! j)",
            "by (rule reflpD)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nP (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "fun merge_wrt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"merge_wrt _ xs [] = xs\"|\n  \"merge_wrt rel [] ys = ys\"|\n  \"merge_wrt rel (x # xs) (y # ys) =\n    (if x = y then\n      y # (merge_wrt rel xs ys)\n    else if rel x y then\n      x # (merge_wrt rel xs (y # ys))\n    else\n      y # (merge_wrt rel (x # xs) ys)\n    )\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma set_merge_wrt: \"set (merge_wrt rel xs ys) = set xs \\<union> set ys\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs ys) = set xs \\<union> set ys",
            "proof (induct rel xs ys rule: merge_wrt.induct)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case (1 rel xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs []) = set xs \\<union> set []",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel xs []) = set xs \\<union> set []\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case (2 rel y ys)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case (3 rel x xs y ys)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys\n\\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys)\n\\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "proof (cases \"x = y\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "by (simp add: 3(1))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "proof (cases \"rel x y\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "with \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\nrel x y",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "by (simp add: 3(2) insert_commute)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "with \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> rel x y",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)",
            "by (simp add: 3(3))",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma sorted_merge_wrt:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"sorted_wrt rel xs\" and \"sorted_wrt rel ys\"\n  shows \"sorted_wrt rel (merge_wrt rel xs ys)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "proof (induct rel xs ys rule: merge_wrt.induct)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. \\<lbrakk>transp uu_; \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x; sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk> \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case (1 rel xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel []\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. \\<lbrakk>transp uu_; \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x; sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk> \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "from 1(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel xs",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs [])",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs [])\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case (2 rel y ys)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel []\nsorted_wrt rel (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "from 2(4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel [] (y # ys))",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel [] (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case (3 rel x xs y ys)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys)\n\\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys))\n\\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys)\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "proof (cases \"x = y\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "proof (auto simp add: True)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)",
            "fix z",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)",
            "assume \"z \\<in> set (merge_wrt rel xs ys)\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set (merge_wrt rel xs ys)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)",
            "hence \"z \\<in> set xs \\<union> set ys\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel xs ys)\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys",
            "by (simp only: set_merge_wrt)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)",
            "thus \"rel y z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z",
            "proof",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z",
            "assume \"z \\<in> set xs\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z",
            "with 3(6)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel y z",
            "by (simp add: True)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "assume \"z \\<in> set ys\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "with 3(7)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z",
            "by (simp)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "note True 3(4, 5)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "from 3(6)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"sorted_wrt rel xs\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs",
            "by (simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "from 3(7)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)",
            "have \"sorted_wrt rel ys\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys",
            "by (simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys",
            "show \"sorted_wrt rel (merge_wrt rel xs ys)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)",
            "by (rule 3(1))",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs ys)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "proof (cases \"rel x y\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "proof (auto simp add: False True)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "fix z",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "assume \"z \\<in> set (merge_wrt rel xs (y # ys))\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "hence \"z \\<in> insert y (set xs \\<union> set ys)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (1 subgoal):\n 1. z \\<in> insert y (set xs \\<union> set ys)",
            "by (simp add: set_merge_wrt)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> insert y (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "thus \"rel x z\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> insert y (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel x z",
            "proof",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z",
            "assume \"z = y\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz = y\n\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z",
            "with True",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nrel x y\nz = y",
            "show ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nrel x y\nz = y\n\ngoal (1 subgoal):\n 1. rel x z",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z",
            "next",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z",
            "assume \"z \\<in> set xs \\<union> set ys\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z",
            "thus ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel x z",
            "proof",
            11,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z",
            "assume \"z \\<in> set xs\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z",
            "with 3(6)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z",
            "by (simp)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z",
            "next",
            12,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z",
            "assume \"z \\<in> set ys\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z",
            "with 3(7)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys",
            "have \"rel y z\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z",
            "by (simp)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z",
            "with 3(4) True",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ntransp rel\nrel x y\nrel y z",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntransp rel\nrel x y\nrel y z\n\ngoal (1 subgoal):\n 1. rel x z",
            "by (rule transpD)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal:\nNo subgoals!",
            "qed",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "note False True 3(4, 5)",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "from 3(6)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)",
            "have \"sorted_wrt rel xs\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs",
            "by (simp)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs",
            "show \"sorted_wrt rel (merge_wrt rel xs (y # ys))\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "using 3(7)",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))",
            "by (rule 3(2))",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs (y # ys))\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "assume \"\\<not> rel x y\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "from \\<open>x \\<noteq> y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y",
            "have \"rel x y \\<or> rel y x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. rel x y \\<or> rel y x",
            "by (rule 3(5))",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "with \\<open>\\<not> rel x y\\<close>",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> rel x y\nrel x y \\<or> rel y x",
            "have *: \"rel y x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> rel x y\nrel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. rel y x",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))",
            "proof (auto simp add: False \\<open>\\<not> rel x y\\<close>)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "fix z",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "assume \"z \\<in> set (merge_wrt rel (x # xs) ys)\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "hence \"z \\<in> insert x (set xs \\<union> set ys)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (1 subgoal):\n 1. z \\<in> insert x (set xs \\<union> set ys)",
            "by (simp add: set_merge_wrt)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> insert x (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "thus \"rel y z\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> insert x (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel y z",
            "proof",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z",
            "assume \"z = x\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz = x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z",
            "with *",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nrel y x\nz = x",
            "show ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nrel y x\nz = x\n\ngoal (1 subgoal):\n 1. rel y z",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z",
            "next",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z",
            "assume \"z \\<in> set xs \\<union> set ys\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z",
            "thus ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z",
            "proof",
            11,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z",
            "assume \"z \\<in> set xs\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z",
            "with 3(6)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs",
            "have \"rel x z\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z",
            "by (simp)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel x z\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z",
            "with 3(4) *",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ntransp rel\nrel y x\nrel x z",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntransp rel\nrel y x\nrel x z\n\ngoal (1 subgoal):\n 1. rel y z",
            "by (rule transpD)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "next",
            12,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "assume \"z \\<in> set ys\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z",
            "with 3(7)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z",
            "by (simp)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!",
            "qed",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "note False \\<open>\\<not> rel x y\\<close> 3(4, 5, 6)",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "from 3(7)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsorted_wrt rel (y # ys)",
            "have \"sorted_wrt rel ys\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys",
            "by (simp)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel ys",
            "show \"sorted_wrt rel (merge_wrt rel (x # xs) ys)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)",
            "by (rule 3(3))",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) ys)\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma set_fold:\n  assumes \"\\<And>x ys. set (f (g x) ys) = set (g x) \\<union> set ys\"\n  shows \"set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys",
            "proof (induct xs arbitrary: ys)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. \\<And>ys. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "case (Cons x xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) xs ?ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "have eq: \"set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)",
            "by (rule Cons)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) (x # xs) ys) = (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys",
            "by (simp add: o_def assms set_merge_wrt eq ac_simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) (x # xs) ys) = (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Sums and Products\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "lemma additive_implies_homogenous:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f (y::'a::monoid_add))::'b::cancel_comm_monoid_add)\"\n  shows \"f 0 = 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)",
            "have \"f (0 + 0) = f 0 + f 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)",
            "by (rule assms)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)",
            "hence \"f 0 = f 0 + f 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = f (0::'a) + f (0::'a)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)",
            "thus \"f 0 = 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (0::'a) = (0::'b)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma fun_sum_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "proof (cases \"finite A\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "proof (induct A)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))",
            "case empty",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))",
            "by (simp add: assms(1))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))",
            "case step: (insert a A)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite A\na \\<notin> A\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))",
            "by (simp add: sum.insert[OF step(1) step(2)] assms(2) step(3))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninfinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninfinite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "by (simp add: assms(1))",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma fun_sum_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))",
            "by (rule fun_sum_commute, rule additive_implies_homogenous, fact+)",
            1,
            "NA"
        ],
        [
            "",
            "lemma fun_sum_list_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)",
            "proof (induct xs)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list []) = sum_list (map f [])",
            "by (simp add: assms(1))",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum_list []) = sum_list (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))",
            "case (Cons x xs)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. f (sum_list (x # xs)) = sum_list (map f (x # xs))",
            "by (simp add: assms(2))",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (sum_list (x # xs)) = sum_list (map f (x # xs))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma fun_sum_list_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)",
            "by (rule fun_sum_list_commute, rule additive_implies_homogenous, fact+)",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_set_upt_eq_sum_list: \"(\\<Sum>i = m..<n. f i) = (\\<Sum>i\\<leftarrow>[m..<n]. f i)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])",
            "using sum_set_upt_conv_sum_list_nat",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum ?f (set [?m..<?n]) = sum_list (map ?f [?m..<?n])\n\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_list_upt: \"(\\<Sum>i\\<leftarrow>[0..<(length xs)]. f (xs ! i)) = (\\<Sum>x\\<leftarrow>xs. f x)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length xs]. f (xs ! i)) = sum_list (map f xs)",
            "by (simp only: map_upt)",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_list_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"(\\<Sum>i\\<leftarrow>[0..<(length ys)]. f (xs ! i) (ys ! i)) = (\\<Sum>(x, y)\\<leftarrow>(zip xs ys). f x y)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length ys]. f (xs ! i) (ys ! i)) = sum_list (map2 f xs ys)",
            "by (simp only: map_upt_zip[OF assms])",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_list_zeroI:\n  assumes \"set xs \\<subseteq> {0}\"\n  shows \"sum_list xs = 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nset xs \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)",
            "by (induct xs, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lemma fun_prod_commute:\n  assumes \"f 1 = 1\" and \"\\<And>x y. f (x * y) = f x * f y\"\n  shows \"f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "proof (cases \"finite A\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "proof (induct A)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))",
            "case empty",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))",
            "by (simp add: assms(1))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))",
            "case step: (insert a A)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite A\na \\<notin> A\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))",
            "by (simp add: prod.insert[OF step(1) step(2)] assms(2) step(3))",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninfinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninfinite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))",
            "by (simp add: assms(1))",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ]
    ],
    "whole_thing": "<\\STATESEP>section \\<open>Utilities\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>theory Utils\n  imports Main Well_Quasi_Orders.Almost_Full_Relations\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma subset_imageE_inj:\n  assumes \"B \\<subseteq> f ` A\"\n  obtains C where \"C \\<subseteq> A\" and \"B = f ` C\" and \"inj_on f C\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>define g where \"g = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ng = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have \"g b \\<in> A \\<and> f (g b) = b\" if \"b \\<in> B\" for b<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>proof -<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>from that assms<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nb \\<in> B\nB \\<subseteq> f ` A<\\STATESEP>have \"b \\<in> f ` A\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> B\nB \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. b \\<in> f ` A<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nb \\<in> f ` A\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>then<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nb \\<in> f ` A<\\STATESEP>obtain a where \"a \\<in> A\" and \"b = f a\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> A; b = f a\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na \\<in> A\nb = f a\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>hence \"a \\<in> A \\<and> f a = b\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na \\<in> A\nb = f a\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<and> f a = b<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b<\\STATESEP>unfolding g_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\na \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> A \\<and> f a = b) \\<in> A \\<and> f (SOME a. a \\<in> A \\<and> f a = b) = b<\\STATESEP>by (rule someI)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng b \\<in> A \\<and> f (g b) = b\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>hence 1: \"\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A\" and 2: \"\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A) &&& (\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b)<\\STATESEP>by simp_all<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n?b \\<in> B \\<Longrightarrow> g ?b \\<in> A\n?b \\<in> B \\<Longrightarrow> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>let ?C = \"g ` B\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C. \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. thesis<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. ?C \\<subseteq> A\n 2. B = f ` ?C\n 3. inj_on f ?C<\\STATESEP>show \"?C \\<subseteq> A\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g ` B \\<subseteq> A<\\STATESEP>by (auto intro: 1)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng ` B \\<subseteq> A\n\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)<\\STATESEP>show \"B = f ` ?C\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. B = f ` g ` B<\\STATESEP>proof (rule set_eqI)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)<\\STATESEP>fix b<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)<\\STATESEP>show \"b \\<in> B \\<longleftrightarrow> b \\<in> f ` ?C\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (b \\<in> B) = (b \\<in> f ` g ` B)<\\STATESEP>proof<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>assume \"b \\<in> B\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nb \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nb \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>from this<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nb \\<in> B<\\STATESEP>have \"f (g b) = b\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b) = b<\\STATESEP>by (rule 2)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf (g b) = b\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nb \\<in> B\nf (g b) = b<\\STATESEP>show \"b \\<in> f ` ?C\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> B\nf (g b) = b\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B<\\STATESEP>by force<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>assume \"b \\<in> f ` ?C\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>then<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nb \\<in> f ` g ` B<\\STATESEP>obtain b' where \"b' \\<in> B\" and \"b = f (g b')\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'. \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding image_image<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> (\\<lambda>x. f (g x)) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'. \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>..<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nb' \\<in> B\nb = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nb' \\<in> B\nb = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>from this(1)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nb' \\<in> B<\\STATESEP>have \"f (g b') = b'\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nb' \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b') = b'<\\STATESEP>by (rule 2)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nb' \\<in> B\nb = f (g b')\nf (g b') = b'<\\STATESEP>show \"b \\<in> B\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nb' \\<in> B\nb = f (g b')\nf (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> B<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nb \\<in> B\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(b \\<in> B) = (b \\<in> f ` g ` B)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nB = f ` g ` B\n\ngoal (1 subgoal):\n 1. inj_on f (g ` B)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)<\\STATESEP>show \"inj_on f ?C\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)<\\STATESEP>proof<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>fix x y<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>assume \"x \\<in> ?C\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>then<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> g ` B<\\STATESEP>obtain bx where \"bx \\<in> B\" and x: \"x = g bx\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>bx. \\<lbrakk>bx \\<in> B; x = g bx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nbx \\<in> B\nx = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nbx \\<in> B\nx = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>from this(1)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nbx \\<in> B<\\STATESEP>have \"f (g bx) = bx\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nbx \\<in> B\n\ngoal (1 subgoal):\n 1. f (g bx) = bx<\\STATESEP>by (rule 2)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf (g bx) = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nbx \\<in> B\nx = g bx\nf (g bx) = bx<\\STATESEP>have *: \"f x = bx\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nbx \\<in> B\nx = g bx\nf (g bx) = bx\n\ngoal (1 subgoal):\n 1. f x = bx<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf x = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>assume \"y \\<in> ?C\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ny \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>then<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ny \\<in> g ` B<\\STATESEP>obtain \"by\" where \"by \\<in> B\" and y: \"y = g by\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ny \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>by. \\<lbrakk>by \\<in> B; y = g by\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nby \\<in> B\ny = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nby \\<in> B\ny = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>from this(1)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nby \\<in> B<\\STATESEP>have \"f (g by) = by\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nby \\<in> B\n\ngoal (1 subgoal):\n 1. f (g by) = by<\\STATESEP>by (rule 2)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf (g by) = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nby \\<in> B\ny = g by\nf (g by) = by<\\STATESEP>have \"f y = by\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nby \\<in> B\ny = g by\nf (g by) = by\n\ngoal (1 subgoal):\n 1. f y = by<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>assume \"f x = f y\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nf y = by\nf x = f y<\\STATESEP>have \"bx = by\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nf y = by\nf x = f y\n\ngoal (1 subgoal):\n 1. bx = by<\\STATESEP>using *<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nf y = by\nf x = f y\nf x = bx\n\ngoal (1 subgoal):\n 1. bx = by<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nbx = by\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>thus \"x = y\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nbx = by\n\ngoal (1 subgoal):\n 1. x = y<\\STATESEP>by (simp only: x y)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ninj_on f (g ` B)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nthesis\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma wfP_chain:\n  assumes \"\\<not>(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i))\"\n  shows \"wfP r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wfP r<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. wfP r<\\STATESEP>from assms wf_iff_no_infinite_down_chain[of \"{(x, y). r x y}\"]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\nwf {(x, y). r x y} = (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})<\\STATESEP>have \"wf {(x, y). r x y}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\nwf {(x, y). r x y} = (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r<\\STATESEP>thus \"wfP r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r<\\STATESEP>unfolding wfP_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nwf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwfP r\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma transp_sequence:\n  assumes \"transp r\" and \"\\<And>i. r (seq (Suc i)) (seq i)\" and \"i < j\"\n  shows \"r (seq j) (seq i)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>have \"\\<And>k. r (seq (i + Suc k)) (seq i)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)<\\STATESEP>proof -<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)<\\STATESEP>fix k::nat<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)<\\STATESEP>show \"r (seq (i + Suc k)) (seq i)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r (seq (i + Suc k)) (seq i)<\\STATESEP>proof (induct k)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>case 0<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>from assms(2)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nr (seq (Suc ?i)) (seq ?i)<\\STATESEP>have \"r (seq (Suc i)) (seq i)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc i)) (seq i)<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (Suc i)) (seq i)\n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>thus ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc 0)) (seq i)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc 0)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>case (Suc k)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>note assms(1)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ntransp r\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ntransp r\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>from assms(2)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nr (seq (Suc ?i)) (seq ?i)<\\STATESEP>have \"r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>have \"r (seq (Suc (i + k))) (seq i)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)<\\STATESEP>using Suc.hyps<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nr (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ntransp r\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\nr (seq (Suc (i + k))) (seq i)<\\STATESEP>have \"r (seq (Suc (Suc i + k))) (seq i)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ntransp r\nr (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\nr (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq i)<\\STATESEP>by (rule transpD)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i) \\<Longrightarrow> r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>thus ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (Suc k))) (seq i)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc (Suc k))) (seq i)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc k)) (seq i)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>hence \"r (seq (i + Suc(j - i - 1))) (seq i)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (j - i - 1))) (seq i)<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>thus \"r (seq j) (seq i)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>using \\<open>i < j\\<close><\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr (seq (i + Suc (j - i - 1))) (seq i)\ni < j\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr (seq j) (seq i)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma almost_full_on_finite_subsetE:\n  assumes \"reflp P\" and \"almost_full_on P S\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. P t s)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>define crit where \"crit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncrit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have critD: \"s \\<notin> U\" if \"crit U s\" for U s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> U<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>assume \"s \\<in> U\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ns \\<in> U\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>from \\<open>crit U s\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ncrit U s<\\STATESEP>have \"\\<forall>u\\<in>U. \\<not> P u s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncrit U s\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s<\\STATESEP>unfolding crit_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>u\\<in>U. \\<not> P u s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>from this \\<open>s \\<in> U\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>u\\<in>U. \\<not> P u s\ns \\<in> U<\\STATESEP>have \"\\<not> P s s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>u\\<in>U. \\<not> P u s\ns \\<in> U\n\ngoal (1 subgoal):\n 1. \\<not> P s s<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>from assms(1)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nreflp P<\\STATESEP>have \"P s s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P s s<\\STATESEP>by (rule reflpD)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nP s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<not> P s s\nP s s<\\STATESEP>show False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<not> P s s\nP s s\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncrit ?U ?s \\<Longrightarrow> ?s \\<notin> ?U\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>define \"fun\"\n    where \"fun = (\\<lambda>U. (if (\\<exists>s. crit U s) then\n                        insert (SOME s. crit U s) U\n                      else\n                        U\n                      ))\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfun = (\\<lambda>U. if \\<exists>s. crit U s then insert (SOME s. crit U s) U else U)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>define seq where \"seq = rec_nat {} (\\<lambda>_. fun)\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nseq = rec_nat {} (\\<lambda>_. fun)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have seq_Suc: \"seq (Suc i) = fun (seq i)\" for i<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. seq (Suc i) = fun (seq i)<\\STATESEP>by (simp add: seq_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nseq (Suc ?i) = fun (seq ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have seq_incr_Suc: \"seq i \\<subseteq> seq (Suc i)\" for i<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq (Suc i)<\\STATESEP>by (auto simp add: seq_Suc fun_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nseq ?i \\<subseteq> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have seq_incr: \"i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j\" for i j<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>proof -<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>assume \"i \\<le> j\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ni \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>hence \"i = j \\<or> i < j\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ni \\<le> j\n\ngoal (1 subgoal):\n 1. i = j \\<or> i < j<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ni = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>thus \"seq i \\<subseteq> seq j\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ni = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j<\\STATESEP>proof<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>assume \"i = j\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ni = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>thus ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ni = j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>assume \"i < j\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ni < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j<\\STATESEP>with _ seq_incr_Suc<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nPROP ?psi \\<Longrightarrow> PROP ?psi\nseq ?i \\<subseteq> seq (Suc ?i)\ni < j<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nPROP ?psi \\<Longrightarrow> PROP ?psi\nseq ?i \\<subseteq> seq (Suc ?i)\ni < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j<\\STATESEP>by (rule transp_sequence, simp add: transp_def)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nseq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?i \\<le> ?j \\<Longrightarrow> seq ?i \\<subseteq> seq ?j\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have sub: \"seq i \\<subseteq> S\" for i<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S<\\STATESEP>proof (induct i, simp add: seq_def, simp add: seq_Suc fun_def, rule)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S<\\STATESEP>fix i<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S<\\STATESEP>assume \"Ex (crit (seq i))\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nEx (crit (seq i))\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S<\\STATESEP>hence \"crit (seq i) (Eps (crit (seq i)))\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nEx (crit (seq i))\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i)))<\\STATESEP>by (rule someI_ex)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk> \\<Longrightarrow> Eps (crit (seq i)) \\<in> S<\\STATESEP>thus \"Eps (crit (seq i)) \\<in> S\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<in> S<\\STATESEP>by (simp add: crit_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nEps (crit (seq i)) \\<in> S\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nseq ?i \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>have \"\\<exists>i. seq (Suc i) = seq i\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. seq (Suc i) = seq i<\\STATESEP>proof (rule ccontr, simp)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>assume \"\\<forall>i. seq (Suc i) \\<noteq> seq i\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>with seq_incr_Suc<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nseq ?i \\<subseteq> seq (Suc ?i)\n\\<forall>i. seq (Suc i) \\<noteq> seq i<\\STATESEP>have \"seq i \\<subset> seq (Suc i)\" for i<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nseq ?i \\<subseteq> seq (Suc ?i)\n\\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. seq i \\<subset> seq (Suc i)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nseq ?i \\<subset> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>define seq1 where \"seq1 = (\\<lambda>n. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n))\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nseq1 = (\\<lambda>n. SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>have seq1: \"seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n\" for n<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n<\\STATESEP>unfolding seq1_def<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n) \\<in> seq (Suc n) \\<and> (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n) \\<notin> seq n<\\STATESEP>proof (rule someI_ex)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n<\\STATESEP>from \\<open>seq n \\<subset> seq (Suc n)\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nseq n \\<subset> seq (Suc n)<\\STATESEP>show \"\\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nseq n \\<subset> seq (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n<\\STATESEP>by blast<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>have \"seq1 i \\<in> S\" for i<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. seq1 i \\<in> S<\\STATESEP>proof<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. seq1 i \\<in> ?A\n 2. ?A \\<subseteq> S<\\STATESEP>from seq1[of i]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nseq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i<\\STATESEP>show \"seq1 i \\<in> seq (Suc i)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nseq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq1 i \\<in> seq (Suc i)<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nseq1 i \\<in> seq (Suc i)\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<subseteq> S<\\STATESEP>qed (fact sub)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nseq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>with assms(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nalmost_full_on P S\nseq1 ?i \\<in> S<\\STATESEP>obtain a b where \"a < b\" and \"P (seq1 a) (seq1 b)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nalmost_full_on P S\nseq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>a b. \\<lbrakk>a < b; P (seq1 a) (seq1 b)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (rule almost_full_onD)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na < b\nP (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from \\<open>a < b\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\na < b<\\STATESEP>have \"Suc a \\<le> b\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na < b\n\ngoal (1 subgoal):\n 1. Suc a \\<le> b<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nSuc a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from seq1<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n<\\STATESEP>have \"seq1 a \\<in> seq (Suc a)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq (Suc a)<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nseq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>also<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nseq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from \\<open>Suc a \\<le> b\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nSuc a \\<le> b<\\STATESEP>have \"... \\<subseteq> seq b\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nSuc a \\<le> b\n\ngoal (1 subgoal):\n 1. seq (Suc a) \\<subseteq> seq b<\\STATESEP>by (rule seq_incr)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nseq (Suc a) \\<subseteq> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>finally<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nseq1 a \\<in> seq b<\\STATESEP>have \"seq1 a \\<in> seq b\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq b<\\STATESEP>.<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from seq1<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n<\\STATESEP>have \"seq1 b \\<in> seq (Suc b)\" and \"seq1 b \\<notin> seq b\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nseq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 b \\<in> seq (Suc b) &&& seq1 b \\<notin> seq b<\\STATESEP>by blast+<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nseq1 b \\<in> seq (Suc b)\nseq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>hence \"crit (seq b) (seq1 b)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nseq1 b \\<in> seq (Suc b)\nseq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. crit (seq b) (seq1 b)<\\STATESEP>by (simp add: seq_Suc fun_def someI split: if_splits)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ncrit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>hence \"\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncrit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)<\\STATESEP>by (simp add: crit_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from this \\<open>seq1 a \\<in> seq b\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\nseq1 a \\<in> seq b<\\STATESEP>have \"\\<not> P (seq1 a) (seq1 b)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\nseq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<not> P (seq1 a) (seq1 b)<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<not> P (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False<\\STATESEP>from this \\<open>P (seq1 a) (seq1 b)\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<not> P (seq1 a) (seq1 b)\nP (seq1 a) (seq1 b)<\\STATESEP>show False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<not> P (seq1 a) (seq1 b)\nP (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>i. seq (Suc i) = seq i<\\STATESEP>obtain i where \"seq (Suc i) = seq i\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>i. seq (Suc i) = seq i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nseq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T. \\<lbrakk>finite T; T \\<subseteq> S; \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. thesis<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. finite ?T\n 2. ?T \\<subseteq> S\n 3. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>?T. P t s<\\STATESEP>show \"finite (seq i)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. finite (seq i)<\\STATESEP>by (induct i, simp_all add: seq_def fun_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nfinite (seq i)\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s<\\STATESEP>fix s<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s<\\STATESEP>assume \"s \\<in> S\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ns \\<in> S\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s<\\STATESEP>let ?s = \"Eps (crit (seq i))\"<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s<\\STATESEP>show \"\\<exists>t\\<in>seq i. P t s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>seq i. P t s<\\STATESEP>proof (rule ccontr, simp)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>assume \"\\<forall>t\\<in>seq i. \\<not> P t s\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>with \\<open>s \\<in> S\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ns \\<in> S\n\\<forall>t\\<in>seq i. \\<not> P t s<\\STATESEP>have \"crit (seq i) s\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ns \\<in> S\n\\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. crit (seq i) s<\\STATESEP>by (simp only: crit_def)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ncrit (seq i) s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>hence \"crit (seq i) ?s\" and eq: \"seq (Suc i) = insert ?s (seq i)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ncrit (seq i) s\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i))) &&& seq (Suc i) = insert (Eps (crit (seq i))) (seq i)<\\STATESEP>by (auto simp add: seq_Suc fun_def intro: someI)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ncrit (seq i) (Eps (crit (seq i)))\nseq (Suc i) = insert (Eps (crit (seq i))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>from this(1)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ncrit (seq i) (Eps (crit (seq i)))<\\STATESEP>have \"?s \\<notin> seq i\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ncrit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<notin> seq i<\\STATESEP>by (rule critD)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>hence \"seq (Suc i) \\<noteq> seq i\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<noteq> seq i<\\STATESEP>unfolding eq<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nEps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. insert (Eps (crit (seq i))) (seq i) \\<noteq> seq i<\\STATESEP>by blast<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nseq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False<\\STATESEP>from this \\<open>seq (Suc i) = seq i\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nseq (Suc i) \\<noteq> seq i\nseq (Suc i) = seq i<\\STATESEP>show False<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nseq (Suc i) \\<noteq> seq i\nseq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<exists>t\\<in>seq i. P t s\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S<\\STATESEP>qed (fact sub)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nthesis\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>subsection \\<open>Lists\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma map_upt: \"map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs<\\STATESEP>by (auto intro: nth_equalityI)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma map_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map (\\<lambda>(x, y). f x y) (zip xs ys)\" (is \"?l = ?r\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys<\\STATESEP>have len_l: \"length ?l = length ys\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) = length ys<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlength (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nlength xs = length ys<\\STATESEP>have len_r: \"length ?r = length ys\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nlength xs = length ys\n\ngoal (1 subgoal):\n 1. length (map2 f xs ys) = length ys<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlength (map2 f xs ys) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys<\\STATESEP>proof (simp only: list_eq_iff_nth_eq len_l len_r, rule, rule, intro allI impI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i<\\STATESEP>fix i<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i<\\STATESEP>assume \"i < length ys\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ni < length ys\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i<\\STATESEP>hence \"i < length ?l\" and \"i < length ?r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ni < length ys\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) &&& i < length (map2 f xs ys)<\\STATESEP>by (simp_all only: len_l len_r)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ni < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\ni < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ys \\<Longrightarrow> map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i<\\STATESEP>thus \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map (\\<lambda>(x, y). f x y) (zip xs ys) ! i\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ni < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\ni < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmap (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map2 f xs ys ! i\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmap (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma distinct_sorted_wrt_irrefl:\n  assumes \"irreflp rel\" and \"transp rel\" and \"sorted_wrt rel xs\"\n  shows \"distinct xs\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. distinct xs<\\STATESEP>using assms(3)<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs<\\STATESEP>proof (induct xs)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel []\n\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. distinct []<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ndistinct []\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>case (Cons x xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs \\<Longrightarrow> distinct xs\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>from Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"sorted_wrt rel xs\" and *: \"\\<forall>y\\<in>set xs. rel x y\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs &&& \\<forall>y\\<in>set xs. rel x y<\\STATESEP>by (simp_all)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\\<forall>y\\<in>set xs. rel x y\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>from this(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel xs<\\STATESEP>have \"distinct xs\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs<\\STATESEP>by (rule Cons(1))<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs; sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> distinct (a # xs)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # xs)<\\STATESEP>proof (simp add: \\<open>distinct xs\\<close>, rule)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False<\\STATESEP>assume \"x \\<in> set xs\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>y\\<in>set xs. rel x y\nx \\<in> set xs<\\STATESEP>have \"rel x x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>y\\<in>set xs. rel x y\nx \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x x<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False<\\STATESEP>with assms(1)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nirreflp rel\nrel x x<\\STATESEP>show False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nirreflp rel\nrel x x\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by (simp add: irreflp_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ndistinct (x # xs)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma distinct_sorted_wrt_imp_sorted_wrt_strict:\n  assumes \"distinct xs\" and \"sorted_wrt rel xs\"\n  shows \"sorted_wrt (\\<lambda>x y. rel x y \\<and> \\<not> x = y) xs\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\ndistinct xs\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs<\\STATESEP>proof (induct xs)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n 2. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ndistinct []\nsorted_wrt rel []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n 2. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)<\\STATESEP>case step: (Cons x xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs\ndistinct (x # xs)\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs; distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk> \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (a # xs)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>proof (cases \"xs\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nxs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nxs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>case (Cons y zs)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nxs = y # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>from step(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ndistinct (x # xs)<\\STATESEP>have \"x \\<noteq> y\" and 1: \"distinct (y # zs)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ndistinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& distinct (y # zs)<\\STATESEP>by (simp_all add: Cons)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\ndistinct (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>from step(3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"rel x y\" and 2: \"sorted_wrt rel (y # zs)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. rel x y &&& sorted_wrt rel (y # zs)<\\STATESEP>by (simp_all add: Cons)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrel x y\nsorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>from 1 2<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ndistinct (y # zs)\nsorted_wrt rel (y # zs)<\\STATESEP>have \"sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ndistinct (y # zs)\nsorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)<\\STATESEP>by (rule step(1)[simplified Cons])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>with \\<open>x \\<noteq> y\\<close> \\<open>rel x y\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>using step.prems<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\ndistinct (x # xs)\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)<\\STATESEP>by (auto simp: Cons)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nsorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma sorted_wrt_distinct_set_unique:\n  assumes \"antisymp rel\"\n  assumes \"sorted_wrt rel xs\" \"distinct xs\" \"sorted_wrt rel ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. xs = ys<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. xs = ys<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nantisymp rel\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys<\\STATESEP>have 1: \"length xs = length ys\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nantisymp rel\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. length xs = length ys<\\STATESEP>by (auto dest!: distinct_card)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlength xs = length ys\n\ngoal (1 subgoal):\n 1. xs = ys<\\STATESEP>from assms(2-6)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys<\\STATESEP>proof(induct rule:list_induct2[OF 1])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct []; set [] = set []\\<rbrakk> \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>case 1<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel []\ndistinct []\nsorted_wrt rel []\ndistinct []\nset [] = set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct []; set [] = set []\\<rbrakk> \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. [] = []<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n[] = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>case (2 x xs y ys)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nlength xs = length ys\n\\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys\nsorted_wrt rel (x # xs)\ndistinct (x # xs)\nsorted_wrt rel (y # ys)\ndistinct (y # ys)\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>from 2(4)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ndistinct (x # xs)<\\STATESEP>have \"x \\<notin> set xs\" and \"distinct xs\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ndistinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs &&& distinct xs<\\STATESEP>by simp_all<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nx \\<notin> set xs\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>from 2(6)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ndistinct (y # ys)<\\STATESEP>have \"y \\<notin> set ys\" and \"distinct ys\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ndistinct (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> set ys &&& distinct ys<\\STATESEP>by simp_all<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ny \\<notin> set ys\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>have \"x = y\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x = y<\\STATESEP>proof (rule ccontr)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>assume \"x \\<noteq> y\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>from 2(3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"\\<forall>z\\<in>set xs. rel x z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set xs. rel x z<\\STATESEP>by (simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>from \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y<\\STATESEP>have \"y \\<in> set xs\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<in> set xs<\\STATESEP>using 2(7)<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ny \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>z\\<in>set xs. rel x z\ny \\<in> set xs<\\STATESEP>have *: \"rel x y\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>z\\<in>set xs. rel x z\ny \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x y<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrel x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>from 2(5)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)<\\STATESEP>have \"\\<forall>z\\<in>set ys. rel y z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set ys. rel y z<\\STATESEP>by (simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>from \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y<\\STATESEP>have \"x \\<in> set ys\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> set ys<\\STATESEP>using 2(7)<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nset (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set ys<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nx \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>z\\<in>set ys. rel y z\nx \\<in> set ys<\\STATESEP>have \"rel y x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>z\\<in>set ys. rel y z\nx \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y x<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrel y x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>with assms(1) *<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nantisymp rel\nrel x y\nrel y x<\\STATESEP>have \"x = y\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nantisymp rel\nrel x y\nrel y x\n\ngoal (1 subgoal):\n 1. x = y<\\STATESEP>by (rule antisympD)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False<\\STATESEP>with \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\nx = y<\\STATESEP>show False<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nx = y\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>..<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>from 2(3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"sorted_wrt rel xs\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs<\\STATESEP>by (simp)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>note \\<open>distinct xs\\<close><\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ndistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>from 2(5)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)<\\STATESEP>have \"sorted_wrt rel ys\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys<\\STATESEP>by (simp)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>note \\<open>distinct ys\\<close><\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ndistinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>from 2(7) \\<open>x \\<notin> set xs\\<close> \\<open>y \\<notin> set ys\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nset (x # xs) = set (y # ys)\nx \\<notin> set xs\ny \\<notin> set ys<\\STATESEP>have \"set xs = set ys\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nset (x # xs) = set (y # ys)\nx \\<notin> set xs\ny \\<notin> set ys\n\ngoal (1 subgoal):\n 1. set xs = set ys<\\STATESEP>by (auto simp add: \\<open>x = y\\<close>)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nset xs = set ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys<\\STATESEP>have \"xs = ys\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel xs\ndistinct xs\nsorted_wrt rel ys\ndistinct ys\nset xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys<\\STATESEP>by (rule 2(2))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nxs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys. \\<lbrakk>length xs = length ys; \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys; set xs = set ys\\<rbrakk> \\<Longrightarrow> xs = ys; sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys); distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk> \\<Longrightarrow> x # xs = y # ys<\\STATESEP>with \\<open>x = y\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx = y\nxs = ys<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = y\nxs = ys\n\ngoal (1 subgoal):\n 1. x # xs = y # ys<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nx # xs = y # ys\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nxs = ys\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma sorted_wrt_refl_nth_mono:\n  assumes \"reflp P\" and \"sorted_wrt P xs\" and \"i \\<le> j\" and \"j < length xs\"\n  shows \"P (xs ! i) (xs ! j)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)<\\STATESEP>proof (cases \"i < j\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ni < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>from assms(2) this assms(4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt P xs\ni < j\nj < length xs<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt P xs\ni < j\nj < length xs\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)<\\STATESEP>by (rule sorted_wrt_nth_less)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nP (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>with assms(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ni \\<le> j\n\\<not> i < j<\\STATESEP>have \"i = j\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ni \\<le> j\n\\<not> i < j\n\ngoal (1 subgoal):\n 1. i = j<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ni = j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nreflp P<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)<\\STATESEP>unfolding \\<open>i = j\\<close><\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nreflp P\n\ngoal (1 subgoal):\n 1. P (xs ! j) (xs ! j)<\\STATESEP>by (rule reflpD)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nP (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>fun merge_wrt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"merge_wrt _ xs [] = xs\"|\n  \"merge_wrt rel [] ys = ys\"|\n  \"merge_wrt rel (x # xs) (y # ys) =\n    (if x = y then\n      y # (merge_wrt rel xs ys)\n    else if rel x y then\n      x # (merge_wrt rel xs (y # ys))\n    else\n      y # (merge_wrt rel (x # xs) ys)\n    )\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma set_merge_wrt: \"set (merge_wrt rel xs ys) = set xs \\<union> set ys\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs ys) = set xs \\<union> set ys<\\STATESEP>proof (induct rel xs ys rule: merge_wrt.induct)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case (1 rel xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs []) = set xs \\<union> set []<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel xs []) = set xs \\<union> set []\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case (2 rel y ys)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case (3 rel x xs y ys)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nx = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys\n\\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys)\n\\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys; \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) = set xs \\<union> set (y # ys); \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) = set (x # xs) \\<union> set ys\\<rbrakk> \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>proof (cases \"x = y\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>by (simp add: 3(1))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>proof (cases \"rel x y\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nrel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>with \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\nrel x y<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>by (simp add: 3(2) insert_commute)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>with \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> rel x y<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)<\\STATESEP>by (simp add: 3(3))<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nset (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma sorted_merge_wrt:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"sorted_wrt rel xs\" and \"sorted_wrt rel ys\"\n  shows \"sorted_wrt rel (merge_wrt rel xs ys)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>proof (induct rel xs ys rule: merge_wrt.induct)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. \\<lbrakk>transp uu_; \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x; sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk> \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case (1 rel xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel []\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. \\<lbrakk>transp uu_; \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x; sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk> \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>from 1(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel xs<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs [])<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs [])\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case (2 rel y ys)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel []\nsorted_wrt rel (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>rel v va. \\<lbrakk>transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>from 2(4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel [] (y # ys))<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel [] (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case (3 rel x xs y ys)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys)\n\\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys))\n\\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys)\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys. \\<lbrakk>\\<lbrakk>x = y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys); \\<lbrakk>x \\<noteq> y; rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys)); \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys); transp rel; \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x; sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk> \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>proof (cases \"x = y\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>proof (auto simp add: True)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>fix z<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>assume \"z \\<in> set (merge_wrt rel xs ys)\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nz \\<in> set (merge_wrt rel xs ys)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>hence \"z \\<in> set xs \\<union> set ys\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel xs ys)\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys<\\STATESEP>by (simp only: set_merge_wrt)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>thus \"rel y z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>proof<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z \\<in> set xs\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>with 3(6)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by (simp add: True)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z \\<in> set ys\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>with 3(7)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by (simp)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>note True 3(4, 5)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>from 3(6)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"sorted_wrt rel xs\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs<\\STATESEP>by (simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>from 3(7)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)<\\STATESEP>have \"sorted_wrt rel ys\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys<\\STATESEP>by (simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys<\\STATESEP>show \"sorted_wrt rel (merge_wrt rel xs ys)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx = y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)<\\STATESEP>by (rule 3(1))<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs ys)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>proof (cases \"rel x y\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nrel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>proof (auto simp add: False True)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>fix z<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>assume \"z \\<in> set (merge_wrt rel xs (y # ys))\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nz \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>hence \"z \\<in> insert y (set xs \\<union> set ys)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (1 subgoal):\n 1. z \\<in> insert y (set xs \\<union> set ys)<\\STATESEP>by (simp add: set_merge_wrt)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nz \\<in> insert y (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>thus \"rel x z\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> insert y (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>proof<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z<\\STATESEP>assume \"z = y\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nz = y\n\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z<\\STATESEP>with True<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nrel x y\nz = y<\\STATESEP>show ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nrel x y\nz = y\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z<\\STATESEP>next<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z<\\STATESEP>assume \"z \\<in> set xs \\<union> set ys\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z<\\STATESEP>thus ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>proof<\\STATESEP>11<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>assume \"z \\<in> set xs\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>with 3(6)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>by (simp)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>next<\\STATESEP>12<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>assume \"z \\<in> set ys\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>with 3(7)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys<\\STATESEP>have \"rel y z\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by (simp)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z<\\STATESEP>with 3(4) True<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\ntransp rel\nrel x y\nrel y z<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ntransp rel\nrel x y\nrel y z\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>by (rule transpD)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>note False True 3(4, 5)<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>from 3(6)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)<\\STATESEP>have \"sorted_wrt rel xs\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs<\\STATESEP>by (simp)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs<\\STATESEP>show \"sorted_wrt rel (merge_wrt rel xs (y # ys))\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>using 3(7)<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\nrel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel xs\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))<\\STATESEP>by (rule 3(2))<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel xs (y # ys))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>assume \"\\<not> rel x y\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>from \\<open>x \\<noteq> y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y<\\STATESEP>have \"rel x y \\<or> rel y x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. rel x y \\<or> rel y x<\\STATESEP>by (rule 3(5))<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>with \\<open>\\<not> rel x y\\<close><\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<not> rel x y\nrel x y \\<or> rel y x<\\STATESEP>have *: \"rel y x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<not> rel x y\nrel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. rel y x<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))<\\STATESEP>proof (auto simp add: False \\<open>\\<not> rel x y\\<close>)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>fix z<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>assume \"z \\<in> set (merge_wrt rel (x # xs) ys)\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nz \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>hence \"z \\<in> insert x (set xs \\<union> set ys)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (1 subgoal):\n 1. z \\<in> insert x (set xs \\<union> set ys)<\\STATESEP>by (simp add: set_merge_wrt)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nz \\<in> insert x (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>thus \"rel y z\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> insert x (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>proof<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z = x\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nz = x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z<\\STATESEP>with *<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nrel y x\nz = x<\\STATESEP>show ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nrel y x\nz = x\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z<\\STATESEP>next<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z \\<in> set xs \\<union> set ys\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z<\\STATESEP>thus ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>proof<\\STATESEP>11<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z \\<in> set xs\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nz \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>with 3(6)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs<\\STATESEP>have \"rel x z\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (x # xs)\nz \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z<\\STATESEP>by (simp)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel x z\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>with 3(4) *<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\ntransp rel\nrel y x\nrel x z<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ntransp rel\nrel y x\nrel x z\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by (rule transpD)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>next<\\STATESEP>12<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>assume \"z \\<in> set ys\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z<\\STATESEP>with 3(7)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\nz \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z<\\STATESEP>by (simp)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nrel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>note False \\<open>\\<not> rel x y\\<close> 3(4, 5, 6)<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>from 3(7)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nsorted_wrt rel (y # ys)<\\STATESEP>have \"sorted_wrt rel ys\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nsorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys<\\STATESEP>by (simp)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel ys<\\STATESEP>show \"sorted_wrt rel (merge_wrt rel (x # xs) ys)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> rel x y\ntransp rel\n?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\nsorted_wrt rel (x # xs)\nsorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)<\\STATESEP>by (rule 3(3))<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) ys)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nsorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma set_fold:\n  assumes \"\\<And>x ys. set (f (g x) ys) = set (g x) \\<union> set ys\"\n  shows \"set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys<\\STATESEP>proof (induct xs arbitrary: ys)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. \\<And>ys. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) [] ys) = (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>case (Cons x xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) xs ?ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>have eq: \"set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)<\\STATESEP>by (rule Cons)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys. (\\<And>ys. set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys) \\<Longrightarrow> set (fold (\\<lambda>x. f (g x)) (a # xs) ys) = (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) (x # xs) ys) = (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys<\\STATESEP>by (simp add: o_def assms set_merge_wrt eq ac_simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nset (fold (\\<lambda>x. f (g x)) (x # xs) ys) = (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>subsection \\<open>Sums and Products\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma additive_implies_homogenous:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f (y::'a::monoid_add))::'b::cancel_comm_monoid_add)\"\n  shows \"f 0 = 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)<\\STATESEP>have \"f (0 + 0) = f 0 + f 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)<\\STATESEP>by (rule assms)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)<\\STATESEP>hence \"f 0 = f 0 + f 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = f (0::'a) + f (0::'a)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)<\\STATESEP>thus \"f 0 = 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (0::'a) = (0::'b)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma fun_sum_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>proof (cases \"finite A\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfinite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>proof (induct A)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))<\\STATESEP>case empty<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))<\\STATESEP>by (simp add: assms(1))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))<\\STATESEP>case step: (insert a A)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nfinite A\na \\<notin> A\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (sum g (insert x F)) = (\\<Sum>a\\<in>insert x F. f (g a))<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))<\\STATESEP>by (simp add: sum.insert[OF step(1) step(2)] assms(2) step(3))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ninfinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninfinite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>by (simp add: assms(1))<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma fun_sum_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))<\\STATESEP>by (rule fun_sum_commute, rule additive_implies_homogenous, fact+)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fun_sum_list_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)<\\STATESEP>proof (induct xs)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list []) = sum_list (map f [])<\\STATESEP>by (simp add: assms(1))<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (sum_list []) = sum_list (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))<\\STATESEP>case (Cons x xs)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs. f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow> f (sum_list (a # xs)) = sum_list (map f (a # xs))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. f (sum_list (x # xs)) = sum_list (map f (x # xs))<\\STATESEP>by (simp add: assms(2))<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (sum_list (x # xs)) = sum_list (map f (x # xs))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma fun_sum_list_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)<\\STATESEP>by (rule fun_sum_list_commute, rule additive_implies_homogenous, fact+)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_set_upt_eq_sum_list: \"(\\<Sum>i = m..<n. f i) = (\\<Sum>i\\<leftarrow>[m..<n]. f i)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])<\\STATESEP>using sum_set_upt_conv_sum_list_nat<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nsum ?f (set [?m..<?n]) = sum_list (map ?f [?m..<?n])\n\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_list_upt: \"(\\<Sum>i\\<leftarrow>[0..<(length xs)]. f (xs ! i)) = (\\<Sum>x\\<leftarrow>xs. f x)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length xs]. f (xs ! i)) = sum_list (map f xs)<\\STATESEP>by (simp only: map_upt)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_list_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"(\\<Sum>i\\<leftarrow>[0..<(length ys)]. f (xs ! i) (ys ! i)) = (\\<Sum>(x, y)\\<leftarrow>(zip xs ys). f x y)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length ys]. f (xs ! i) (ys ! i)) = sum_list (map2 f xs ys)<\\STATESEP>by (simp only: map_upt_zip[OF assms])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_list_zeroI:\n  assumes \"set xs \\<subseteq> {0}\"\n  shows \"sum_list xs = 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nset xs \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)<\\STATESEP>by (induct xs, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fun_prod_commute:\n  assumes \"f 1 = 1\" and \"\\<And>x y. f (x * y) = f x * f y\"\n  shows \"f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>proof (cases \"finite A\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfinite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>proof (induct A)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))<\\STATESEP>case empty<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))<\\STATESEP>by (simp add: assms(1))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))<\\STATESEP>case step: (insert a A)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nfinite A\na \\<notin> A\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk> \\<Longrightarrow> f (prod g (insert x F)) = (\\<Prod>a\\<in>insert x F. f (g a))<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))<\\STATESEP>by (simp add: prod.insert[OF step(1) step(2)] assms(2) step(3))<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ninfinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninfinite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))<\\STATESEP>by (simp add: assms(1))<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP>",
    "theory_file_path": "/home/ubuntu/afp-2022-12-06/thys/Polynomials/Utils.thy",
    "working_directory": "/home/ubuntu/afp-2022-12-06/thys/Polynomials"
}