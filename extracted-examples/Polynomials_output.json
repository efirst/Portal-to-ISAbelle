{
    "def_names": [
        "datatype (vars_tpoly: 'v, nums_tpoly: 'a)tpoly = PVar 'v | PNum 'a | PSum \"('v,'a)tpoly list\" | PMult \"('v,'a)tpoly list\"",
        "type_synonym ('v,'a)assign = \"'v \\<Rightarrow> 'a\"",
        "primrec eval_tpoly :: \"('v,'a::{monoid_add,monoid_mult})assign \\<Rightarrow> ('v,'a)tpoly \\<Rightarrow> 'a\"\nwhere \"eval_tpoly \\<alpha> (PVar x) = \\<alpha> x\"\n   |  \"eval_tpoly \\<alpha> (PNum a) = a\"\n   |  \"eval_tpoly \\<alpha> (PSum ps) = sum_list (map (eval_tpoly \\<alpha>) ps)\"\n   |  \"eval_tpoly \\<alpha> (PMult ps) = prod_list (map (eval_tpoly \\<alpha>) ps)\"",
        "type_synonym 'v monom_list = \"('v \\<times> nat)list\"",
        "definition monom_inv :: \"'a monom_list \\<Rightarrow> bool\" where \n  \"monom_inv m \\<equiv> (\\<forall> (x,n) \\<in> set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m)\"",
        "fun eval_monom_list :: \"('a,'b :: comm_semiring_1)assign \\<Rightarrow> ('a monom_list) \\<Rightarrow> 'b\" where \n  \"eval_monom_list \\<alpha> [] = 1\"\n| \"eval_monom_list \\<alpha> ((x,p) # m) = eval_monom_list \\<alpha> m * (\\<alpha> x)^p\"",
        "definition sum_var_list :: \"'a monom_list \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n  \"sum_var_list m x \\<equiv> sum_list (map (\\<lambda> (y,c). if x = y then c else 0) m)\"",
        "fun monom_mult_list :: \"'a monom_list \\<Rightarrow> 'a monom_list \\<Rightarrow> 'a monom_list\" where \n  \"monom_mult_list [] n = n\"\n| \"monom_mult_list ((x,p) # m) n = (case n of\n     Nil \\<Rightarrow> (x,p) # m \n   | (y,q) # n' \\<Rightarrow> if x = y then (x,p + q) # monom_mult_list m n' else\n       if x < y then (x,p) # monom_mult_list m n else (y,q) # monom_mult_list ((x,p) # m) n')\"",
        "typedef (overloaded) 'v monom = \"Collect (monom_inv :: 'v :: linorder monom_list \\<Rightarrow> bool)\"",
        "type_synonym ('v,'a)poly = \"('v monom \\<times> 'a)list\"",
        "definition poly_inv :: \"('v,'a :: zero)poly \\<Rightarrow> bool\"\n  where \"poly_inv p \\<equiv> (\\<forall> c \\<in> snd ` set p. c \\<noteq> 0) \\<and> distinct (map fst p)\"",
        "primrec eval_poly :: \"('v :: linorder, 'a :: comm_semiring_1)assign \\<Rightarrow> ('v,'a)poly \\<Rightarrow> 'a\" where \n  \"eval_poly \\<alpha> [] = 0\"\n| \"eval_poly \\<alpha> (mc # p) = eval_monomc \\<alpha> mc + eval_poly \\<alpha> p\"",
        "definition poly_const :: \"'a :: zero \\<Rightarrow> ('v :: linorder,'a)poly\" where\n  \"poly_const a = (if a = 0 then [] else [(1,a)])\"",
        "fun poly_add :: \"('v,'a)poly \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_add [] q = q\"\n| \"poly_add ((m,c) # p) q = (case List.extract (\\<lambda> mc. fst mc = m) q of\n    None \\<Rightarrow> (m,c) # poly_add p q\n  | Some (q1,(_,d),q2) \\<Rightarrow> if (c+d = 0) then poly_add p (q1 @ q2) else (m,c+d) # poly_add p (q1 @ q2))\"",
        "fun monom_mult_poly :: \"('v :: linorder monom \\<times> 'a) \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"monom_mult_poly _ [] = []\"\n| \"monom_mult_poly (m,c) ((m',d) # p) = (if c * d = 0 then monom_mult_poly (m,c) p else (m * m', c * d) # monom_mult_poly (m,c) p)\"",
        "definition poly_minus :: \"('v :: linorder,'a :: ring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_minus f g = poly_add f (monom_mult_poly (1,-1) g)\"",
        "fun poly_mult :: \"('v :: linorder, 'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_mult [] q = []\"\n| \"poly_mult (mc # p) q = poly_add (monom_mult_poly mc q) (poly_mult p q)\"",
        "definition zero_poly :: \"('v,'a)poly\"\nwhere \"zero_poly \\<equiv> []\"",
        "definition one_poly :: \"('v :: linorder,'a :: semiring_1)poly\" where \n  \"one_poly \\<equiv> [(1,1)]\"",
        "definition eq_poly :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"=p\" 51)\nwhere \"p =p q \\<equiv> \\<forall> \\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q\"",
        "fun poly_power :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> nat \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_power _ 0 = one_poly\"\n| \"poly_power p (Suc n) = poly_mult p (poly_power p n)\"",
        "fun monom_list_subst :: \"('v \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom_list \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_list_subst \\<sigma> [] = one_poly\"\n| \"monom_list_subst \\<sigma> ((x,p) # m) = poly_mult (poly_power (\\<sigma> x) p) (monom_list_subst \\<sigma> m)\"",
        "definition monom_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_subst \\<sigma> m = monom_list_subst \\<sigma> (monom_list m)\"",
        "fun poly_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('w,'a)poly\" where \n  \"poly_subst \\<sigma> [] = zero_poly\"\n| \"poly_subst \\<sigma> ((m,c) # p) = poly_add (poly_mult [(1,c)] (monom_subst \\<sigma> m)) (poly_subst \\<sigma> p)\"",
        "definition monom_vars where \"monom_vars m = set (monom_vars_list m)\"",
        "definition poly_vars_list :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v list\" where \n  \"poly_vars_list p = remdups (concat (map (monom_vars_list o fst) p))\"",
        "definition poly_vars :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v set\" where \n  \"poly_vars p = set (concat (map (monom_vars_list o fst) p))\"",
        "definition pos_assign :: \"('v,'a :: ordered_semiring_0)assign \\<Rightarrow> bool\"\nwhere \"pos_assign \\<alpha> = (\\<forall> x. \\<alpha> x \\<ge> 0)\"",
        "definition poly_ge :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"\\<ge>p\" 51)\nwhere \"p \\<ge>p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q)\"",
        "definition poly_gt :: \"('v :: linorder,'a)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \">p\" 51)\nwhere \"p >p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q)\"",
        "definition poly_weak_mono_all :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\" where \n  \"poly_weak_mono_all p \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. \\<alpha> x \\<ge> \\<beta> x) \n    \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
        "definition poly_weak_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
        "definition poly_weak_anti_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_anti_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<beta> p \\<ge> eval_poly \\<alpha> p\"",
        "definition poly_strict_mono :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_strict_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. (v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x)) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p\"",
        "definition monom_list_degree :: \"'v monom_list \\<Rightarrow> nat\" where \n  \"monom_list_degree xps \\<equiv> sum_list (map snd xps)\"",
        "definition poly_degree :: \"(_,'a) poly \\<Rightarrow> nat\" where\n  \"poly_degree p \\<equiv> max_list (map (\\<lambda> (m,c). monom_degree m) p)\"",
        "definition poly_coeff_sum :: \"('v,'a :: ordered_ab_semigroup) poly \\<Rightarrow> 'a\" where\n  \"poly_coeff_sum p \\<equiv> sum_list (map (\\<lambda> mc. max 0 (snd mc)) p)\"",
        "definition poly_split :: \"('v monom) \\<Rightarrow> ('v,'a :: zero)poly \\<Rightarrow> 'a \\<times> ('v,'a)poly\" \n  where \"poly_split m p \\<equiv> case List.extract (\\<lambda> (n,_). m = n) p of None \\<Rightarrow> (0,p) | Some (p1,(_,c),p2) \\<Rightarrow> (c, p1 @ p2)\"",
        "fun check_poly_eq :: \"('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_eq [] q = (q = [])\"\n| \"check_poly_eq ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n       None \\<Rightarrow> False\n     | Some (q1,(_,d),q2) \\<Rightarrow> c = d \\<and> check_poly_eq p (q1 @ q2))\"",
        "fun check_poly_ge :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_ge [] q = list_all (\\<lambda> (_,d). 0 \\<ge> d) q\"\n| \"check_poly_ge ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n     None \\<Rightarrow> c \\<ge> 0 \\<and> check_poly_ge p q\n   | Some (q1,(_,d),q2) \\<Rightarrow> c \\<ge> d \\<and> check_poly_ge p (q1 @ q2))\"",
        "definition check_poly_weak_mono_all :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> bool\"\nwhere \"check_poly_weak_mono_all p \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0) p\"",
        "definition check_poly_weak_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_discrete p v \\<equiv> check_poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\"",
        "definition check_poly_weak_mono_and_pos :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_and_pos discrete p \\<equiv> \n            if discrete then list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p) \\<and> eval_poly (\\<lambda> w. 0) p \\<ge>  0\n                        else check_poly_weak_mono_all p\"",
        "definition check_poly_weak_anti_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_discrete p v \\<equiv> check_poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\"",
        "definition check_poly_weak_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono p v \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0 \\<or> v \\<notin> monom_vars m) p\"",
        "definition check_poly_weak_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_smart discrete \\<equiv> if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono\"",
        "definition check_poly_weak_anti_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono p v \\<equiv> list_all (\\<lambda> (m,c). 0 \\<ge> c \\<or> v \\<notin> monom_vars m) p\"",
        "definition check_poly_weak_anti_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_smart discrete \\<equiv> if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono\"",
        "definition check_poly_gt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\"\nwhere \"check_poly_gt gt p q \\<equiv> let (a1,p1) = poly_split 1 p; (b1,q1) = poly_split 1 q in gt a1 b1 \\<and> check_poly_ge p1 q1\"",
        "fun univariate_power_list :: \"'v \\<Rightarrow> 'v monom_list \\<Rightarrow> nat option\" where\n  \"univariate_power_list x [(y,n)] = (if x = y then Some n else None)\" \n| \"univariate_power_list _ _ = None\"",
        "definition check_monom_strict_mono :: \"bool \\<Rightarrow> 'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> bool\" where\n  \"check_monom_strict_mono pm m v \\<equiv> case univariate_power v m of\n     Some p \\<Rightarrow> pm \\<or> p = 1\n   | None \\<Rightarrow> False\"",
        "definition check_poly_strict_mono :: \"bool \\<Rightarrow> ('v :: linorder, 'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono pm p v \\<equiv> list_ex (\\<lambda> (m,c). (c \\<ge> 1) \\<and> check_monom_strict_mono pm m v) p\"",
        "definition check_poly_strict_mono_discrete :: \"('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_discrete gt p v \\<equiv> check_poly_gt gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p \"",
        "definition check_poly_strict_mono_smart :: \"bool \\<Rightarrow> bool \\<Rightarrow> ('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_smart discrete pm gt p v \\<equiv> \n            if discrete then check_poly_strict_mono_discrete gt p v else check_poly_strict_mono pm p v\""
    ],
    "problem_names": [
        "lemma eval_monom_list[simp]: \"eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"",
        "lemma sum_var_list_not: \"x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0\"",
        "lemma monom_inv_Cons: assumes \"monom_inv ((x,p) # m)\" \n  and \"y \\<le> x\" shows \"y \\<notin> fst ` set m\"",
        "lemma eq_monom_sum_var_list: assumes \"monom_inv m\" and \"monom_inv n\"\n  shows \"(m = n) = (\\<forall> x. sum_var_list m x = sum_var_list n x)\" (is \"?l = ?r\")",
        "lemma monom_list_mult_list_vars: \"monom_list_vars (monom_mult_list m1 m2) = monom_list_vars m1 \\<union> monom_list_vars m2\"",
        "lemma monom_mult_list_inv: \"monom_inv m1 \\<Longrightarrow> monom_inv m2 \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)\"",
        "lemma monom_inv_ConsD: \"monom_inv (x # xs) \\<Longrightarrow> monom_inv xs\"",
        "lemma sum_var_list_monom_mult_list:  \"sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\"",
        "lemma monom_mult_list_inj: assumes m: \"monom_inv m\" and m1: \"monom_inv m1\" and m2: \"monom_inv m2\"\n  and eq: \"monom_mult_list m m1 = monom_mult_list m m2\"\n  shows \"m1 = m2\"",
        "lemma monom_mult_list[simp]: \"eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"",
        "lemma eq_monom_sum_var: \"m = n \\<longleftrightarrow> (\\<forall> x. sum_var m x = sum_var n x)\"",
        "lemma eval_monom_mult[simp]: \"eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n\"",
        "lemma sum_var_monom_mult:  \"sum_var (m * n) x = sum_var m x + sum_var n x\"",
        "lemma monom_mult_inj: fixes m1 :: \"_ monom\"\n  shows \"m * m1 = m * m2 \\<Longrightarrow> m1 = m2\"",
        "lemma one_monom_inv_sum_var_inv[simp]: \"sum_var 1 x = 0\"",
        "lemma eval_monom_1[simp]: \"eval_monom  \\<alpha> 1 = 1\"",
        "lemma var_monom_1[simp]: \"var_monom x \\<noteq> 1\"",
        "lemma eval_var_monom[simp]: \"eval_monom \\<alpha> (var_monom x) = \\<alpha> x\"",
        "lemma sum_var_monom_var: \"sum_var (var_monom x) y = (if x = y then 1 else 0)\"",
        "lemma poly_const[simp]: \"eval_poly \\<alpha> (poly_const a) = a\"",
        "lemma poly_const_inv: \"poly_inv (poly_const a)\"",
        "lemma eval_poly_append[simp]: \"eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2\"",
        "lemma poly_add_monoms: \"poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2\"",
        "lemma poly_add_inv: \"poly_inv p \\<Longrightarrow> poly_inv q \\<Longrightarrow> poly_inv (poly_add p q)\"",
        "lemma poly_add[simp]: \"eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q\"",
        "lemma monom_mult_poly_inv: \"poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m,c) p)\"",
        "lemma monom_mult_poly[simp]: \"eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\"",
        "lemma poly_minus[simp]: \"eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g\"",
        "lemma poly_minus_inv: \"poly_inv f \\<Longrightarrow> poly_inv g \\<Longrightarrow> poly_inv (poly_minus f g)\"",
        "lemma poly_mult_inv: assumes p: \"poly_inv p\" and q: \"poly_inv q\"\n  shows \"poly_inv (poly_mult p q)\"",
        "lemma poly_mult[simp]: \"eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q\"",
        "lemma zero_poly_inv: \"poly_inv zero_poly\"",
        "lemma one_poly_inv: \"poly_inv one_poly\"",
        "lemma poly_one[simp]: \"eval_poly \\<alpha> one_poly = 1\"",
        "lemma poly_zero_add: \"poly_add zero_poly p = p\"",
        "lemma poly_zero_mult: \"poly_mult zero_poly p = zero_poly\"",
        "lemma poly_one_mult: \"poly_mult one_poly p =p p\"",
        "lemma eq_poly_refl[simp]: \"p =p p\"",
        "lemma eq_poly_trans[trans]: \"\\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3\"",
        "lemma poly_add_comm: \"poly_add p q =p poly_add q p\"",
        "lemma poly_add_assoc: \"poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3\"",
        "lemma poly_mult_comm: \"poly_mult p q =p poly_mult q p\"",
        "lemma poly_mult_assoc: \"poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3\"",
        "lemma poly_distrib: \"poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)\"",
        "lemma poly_of: \"eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p\"",
        "lemma poly_of_inv: \"poly_inv (poly_of p)\"",
        "lemma poly_power[simp]: \"eval_poly \\<alpha> (poly_power p n) = (eval_poly \\<alpha> p) ^ n\"",
        "lemma poly_power_inv: assumes p: \"poly_inv p\" \n  shows \"poly_inv (poly_power p n)\"",
        "lemma monom_list_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_list_subst \\<sigma> m)\"",
        "lemma monom_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_subst \\<sigma> m)\"",
        "lemma monom_subst[simp]: \"eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) m\"",
        "lemma poly_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" and p: \"poly_inv p\"\n  shows \"poly_inv (poly_subst \\<sigma> p)\"",
        "lemma poly_subst: \"eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) p\"",
        "lemma eval_poly_subst: \n  assumes eq: \"\\<And> w. f w = eval_poly g (q w)\"\n  shows \"eval_poly f p = eval_poly g (poly_subst q p)\"",
        "lemma monom_vars_list_subst: assumes \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\" \n  shows \"monom_subst f m = monom_subst g m\"",
        "lemma eval_monom_vars_list: assumes \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"",
        "lemma monom_vars_list_1[simp]: \"monom_vars_list 1 = []\"",
        "lemma monom_vars_list_var_monom[simp]: \"monom_vars_list (var_monom x) = [x]\"",
        "lemma monom_vars_eval_monom: \n  \"(\\<And> x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m\"",
        "lemma poly_vars_list[simp]: \"set (poly_vars_list p) = poly_vars p\"",
        "lemma poly_vars: assumes eq: \"\\<And> w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"",
        "lemma poly_var: assumes pv: \"v \\<notin> poly_vars p\" and diff: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"",
        "lemma eval_poly_vars: assumes \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"",
        "lemma poly_ge_refl[simp]: \"p \\<ge>p p\"",
        "lemma poly_ge_trans[trans]: \"\\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3\"",
        "lemma pos_assign_monom_list: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom_list \\<alpha> m \\<ge> 0\"",
        "lemma pos_assign_monom: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom \\<alpha> m \\<ge> 0\"",
        "lemma pos_assign_poly:   assumes pos: \"pos_assign \\<alpha>\"\n  and p: \"p \\<ge>p zero_poly\"\n  shows \"eval_poly \\<alpha> p \\<ge> 0\"",
        "lemma poly_add_ge_mono: assumes \"p1 \\<ge>p p2\" shows \"poly_add p1 q \\<ge>p poly_add p2 q\"",
        "lemma poly_mult_ge_mono: assumes \"p1 \\<ge>p p2\" and \"q \\<ge>p zero_poly\"\n  shows \"poly_mult p1 q \\<ge>p poly_mult p2 q\"",
        "lemma poly_gt_imp_poly_ge: \"p >p q \\<Longrightarrow> p \\<ge>p q\"",
        "lemma poly_compat: \"\\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
        "lemma poly_compat2: \"\\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
        "lemma poly_gt_trans[trans]: \"\\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
        "lemma poly_GT_SN: \"SN poly_GT\"",
        "lemma eval_monom_list_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\n  shows \"eval_monom_list f m \\<ge> eval_monom_list g m\" \"eval_monom_list g m \\<ge> 0\"",
        "lemma eval_monom_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\nshows \"eval_monom f m \\<ge> eval_monom g m\" \"eval_monom g m \\<ge> 0\"",
        "lemma poly_weak_mono_all_E: assumes p: \"poly_weak_mono_all p\" and \n  ge: \"\\<And> x. f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"",
        "lemma poly_weak_mono_E: assumes p: \"poly_weak_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"",
        "lemma poly_weak_anti_mono_E: assumes p: \"poly_weak_anti_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst g p \\<ge>p poly_subst f p\"",
        "lemma poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes mono: \"\\<And> v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v\"\n  shows \"poly_weak_mono_all p\"",
        "lemma poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\" \n  assumes p: \"poly_weak_mono_all p\"\n  shows \"poly_weak_mono p v\"",
        "lemma poly_weak_mono_all_pos: \n  fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes pos_at_zero: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"\n  and mono: \"poly_weak_mono_all p\"\n  shows \"p \\<ge>p zero_poly\"",
        "lemma poly_strict_mono_E: assumes p: \"poly_strict_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v >p g v\"\n  shows \"poly_subst f p >p poly_subst g p\"",
        "lemma poly_add_gt_mono: assumes \"p1 >p p2\" shows \"poly_add p1 q >p poly_add p2 q\"",
        "lemma poly_mult_gt_mono: \n  fixes q :: \"('v :: linorder,'a)poly\"\n  assumes gt: \"p1 >p p2\" and mono: \"q \\<ge>p one_poly\"\n  shows \"poly_mult p1 q >p poly_mult p2 q\"",
        "lemma monom_list_degree: \"eval_monom_list (\\<lambda> _. x) m = x ^ monom_list_degree m\"",
        "lemma monom_list_var_monom[simp]: \"monom_list (var_monom x) = [(x,1)]\"",
        "lemma monom_list_1[simp]: \"monom_list 1 = []\"",
        "lemma monom_degree: \"eval_monom (\\<lambda> _. x) m = x ^ monom_degree m\"",
        "lemma poly_coeff_sum: \"poly_coeff_sum p \\<ge> 0\"",
        "lemma poly_degree: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  shows \"poly_coeff_sum p * (x ^ poly_degree p) \\<ge> eval_poly (\\<lambda> _. x) p\"",
        "lemma poly_degree_bound: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  and c: \"c \\<ge> poly_coeff_sum p\"\n  and d: \"d \\<ge> poly_degree p\"\n  shows \"c * (x ^ d) \\<ge> eval_poly (\\<lambda> _. x) p\"",
        "lemma poly_split: assumes \"poly_split m p = (c,q)\"\n  shows \"p =p (m,c) # q\"",
        "lemma poly_split_eval: assumes \"poly_split m p = (c,q)\" \n  shows \"eval_poly \\<alpha> p = (eval_monom \\<alpha> m * c) + eval_poly \\<alpha> q\"",
        "lemma check_poly_eq: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes chk: \"check_poly_eq p q\"\n  shows \"p =p q\"",
        "lemma check_poly_ge: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_ge p q \\<Longrightarrow> p \\<ge>p q\"",
        "lemma check_poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono_all p\" shows  \"poly_weak_mono_all p\"",
        "lemma check_poly_weak_mono_all_pos: \n  assumes \"check_poly_weak_mono_all p\" shows  \"p \\<ge>p zero_poly\"",
        "lemma check_poly_weak_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_mono_discrete p v\"\n  shows \"poly_weak_mono p v\"",
        "lemma check_poly_weak_anti_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_anti_mono_discrete p v\"\n  shows \"poly_weak_anti_mono p v\"",
        "lemma check_poly_weak_mono_and_pos: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_weak_mono_all p \\<and> (p \\<ge>p zero_poly)\"",
        "lemma check_poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono p v\" shows  \"poly_weak_mono p v\"",
        "lemma (in poly_order_carrier) check_poly_weak_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v\"",
        "lemma check_poly_weak_anti_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_anti_mono p v\" shows  \"poly_weak_anti_mono p v\"",
        "lemma (in poly_order_carrier) check_poly_weak_anti_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v\"",
        "lemma univariate_power_list: assumes \"monom_inv m\" \"univariate_power_list x m = Some n\" \n  shows \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \n   \"n \\<ge> 1\"",
        "lemma univariate_power: assumes \"univariate_power x m = Some n\" \n  shows \"sum_var m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom \\<alpha> m = ((\\<alpha> x)^n)\"\n   \"n \\<ge> 1\"",
        "lemma univariate_power_var_monom: \"univariate_power y (var_monom x) = (if x = y then Some 1 else None)\"",
        "lemma check_monom_strict_mono: fixes \\<alpha> \\<beta> :: \"('v :: linorder,'a)assign\" and v :: 'v and m :: \"'v monom\"\n  assumes check: \"check_monom_strict_mono power_mono m v\"\n  and gt: \"\\<alpha> v \\<succ> \\<beta> v\"\n  and ge: \"\\<beta> v \\<ge> 0\"\nshows \"eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\"",
        "lemma check_poly_strict_mono: \n  assumes check1: \"check_poly_strict_mono power_mono p v\"\n  and check2: \"check_poly_weak_mono_all p\"\n  shows \"poly_strict_mono p v\"",
        "lemma check_poly_gt: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_gt gt p q\" shows \"p >p q\"",
        "lemma check_poly_strict_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_strict_mono_discrete gt p v\"\n  shows \"poly_strict_mono p v\"",
        "lemma check_poly_strict_mono_smart: \n  assumes check1: \"check_poly_strict_mono_smart discrete power_mono gt p v\"\n  and check2: \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_strict_mono p v\""
    ],
    "translations": [
        [
            "",
            "section \\<open>Polynomials\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "theory Polynomials\nimports \n  \"Abstract-Rewriting.SN_Orders\"\n  Matrix.Utility \nbegin",
            0,
            "NA"
        ],
        [
            "",
            "subsection \\<open>\nPolynomials represented as trees\n\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "datatype (vars_tpoly: 'v, nums_tpoly: 'a)tpoly = PVar 'v | PNum 'a | PSum \"('v,'a)tpoly list\" | PMult \"('v,'a)tpoly list\"",
            0,
            "NA"
        ],
        [
            "",
            "type_synonym ('v,'a)assign = \"'v \\<Rightarrow> 'a\"",
            0,
            "NA"
        ],
        [
            "",
            "primrec eval_tpoly :: \"('v,'a::{monoid_add,monoid_mult})assign \\<Rightarrow> ('v,'a)tpoly \\<Rightarrow> 'a\"\nwhere \"eval_tpoly \\<alpha> (PVar x) = \\<alpha> x\"\n   |  \"eval_tpoly \\<alpha> (PNum a) = a\"\n   |  \"eval_tpoly \\<alpha> (PSum ps) = sum_list (map (eval_tpoly \\<alpha>) ps)\"\n   |  \"eval_tpoly \\<alpha> (PMult ps) = prod_list (map (eval_tpoly \\<alpha>) ps)\"",
            0,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Polynomials represented in normal form as lists of monomials\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "type_synonym 'v monom_list = \"('v \\<times> nat)list\"",
            0,
            "NA"
        ],
        [
            "",
            "context linorder\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "definition monom_inv :: \"'a monom_list \\<Rightarrow> bool\" where \n  \"monom_inv m \\<equiv> (\\<forall> (x,n) \\<in> set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m)\"",
            0,
            "NA"
        ],
        [
            "",
            "fun eval_monom_list :: \"('a,'b :: comm_semiring_1)assign \\<Rightarrow> ('a monom_list) \\<Rightarrow> 'b\" where \n  \"eval_monom_list \\<alpha> [] = 1\"\n| \"eval_monom_list \\<alpha> ((x,p) # m) = eval_monom_list \\<alpha> m * (\\<alpha> x)^p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_list[simp]: \"eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n",
            "by (induct m, auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "definition sum_var_list :: \"'a monom_list \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n  \"sum_var_list m x \\<equiv> sum_list (map (\\<lambda> (y,c). if x = y then c else 0) m)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma sum_var_list_not: \"x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0",
            "unfolding sum_var_list_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow> (\\<Sum>(y, c)\\<leftarrow>m. if x = y then c else 0) = 0",
            "by (induct m, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_inv_Cons: assumes \"monom_inv ((x,p) # m)\" \n  and \"y \\<le> x\" shows \"y \\<notin> fst ` set m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "define M where \"M = map fst m\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nM = map fst m\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "from assms[unfolded monom_inv_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\ny \\<le> x",
            "have \"distinct (x # map fst m)\" \"sorted (x # map fst m)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\ny \\<le> x\n\ngoal (1 subgoal):\n 1. distinct (x # map fst m) &&& sorted (x # map fst m)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndistinct (x # map fst m)\nsorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "with assms(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny \\<le> x\ndistinct (x # map fst m)\nsorted (x # map fst m)",
            "have \"y \\<notin> set (map fst m)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<le> x\ndistinct (x # map fst m)\nsorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (map fst m)",
            "unfolding M_def[symmetric]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<le> x\ndistinct (x # M)\nsorted (x # M)\n\ngoal (1 subgoal):\n 1. y \\<notin> set M",
            "by (induct M, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<notin> fst ` set m\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma eq_monom_sum_var_list: assumes \"monom_inv m\" and \"monom_inv n\"\n  shows \"(m = n) = (\\<forall> x. sum_var_list m x = sum_var_list n x)\" (is \"?l = ?r\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv m\nmonom_inv n\n\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)",
            "proof (induct m arbitrary: n)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv []\nmonom_inv n\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "proof (cases n)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "case (Cons yp nn)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn = yp # nn\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "obtain y p where yp: \"yp = (y,p)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y p. yp = (y, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases yp, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nyp = (y, p)\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "with Cons Nil(2)[unfolded monom_inv_def]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nn = yp # nn\n(\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n)\nyp = (y, p)",
            "have p: \"0 < p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nn = yp # nn\n(\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n)\nyp = (y, p)\n\ngoal (1 subgoal):\n 1. 0 < p",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < p\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "by (simp add: Cons, rule exI[of _ y], simp add: sum_var_list_def yp p)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)",
            "qed simp",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "case (Cons xp m)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>monom_inv m; monom_inv ?n\\<rbrakk> \\<Longrightarrow> (m = ?n) = (\\<forall>x. sum_var_list m x = sum_var_list ?n x)\nmonom_inv (xp # m)\nmonom_inv n\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "obtain x p where xp: \"xp = (x,p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases xp, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "with Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv (xp # m)\nxp = (x, p)",
            "have p: \"0 < p\" and x: \"x \\<notin> fst ` set m\" and m: \"monom_inv m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (xp # m)\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&& x \\<notin> fst ` set m &&& monom_inv m",
            "unfolding monom_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set (xp # m). 1 \\<le> n) \\<and> distinct (map fst (xp # m)) \\<and> sorted (map fst (xp # m))\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&& x \\<notin> fst ` set m &&& (\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m)",
            "by (auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < p\nx \\<notin> fst ` set m\nmonom_inv m\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "proof (cases n)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn = []\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nn = []\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "by (auto simp: xp sum_var_list_def p intro!: exI[of _ x])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "case n: (Cons yq n')",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn = yq # n'\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "from Cons(3)[unfolded n]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv (yq # n')",
            "have n': \"monom_inv n'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (yq # n')\n\ngoal (1 subgoal):\n 1. monom_inv n'",
            "by (auto simp: monom_inv_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv n'\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "proof (cases \"yq = xp\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nyq = xp\n\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "unfolding n True",
            7,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = xp # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)",
            "using Cons(1)[OF m n']",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(m = n') = (\\<forall>x. sum_var_list m x = sum_var_list n' x)\n\ngoal (1 subgoal):\n 1. (xp # m = xp # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)",
            "by (auto simp: xp sum_var_list_def)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "obtain y q where yq: \"yq = (y,q)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y q. yq = (y, q) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nyq = (y, q)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "from Cons(3)[unfolded n yq monom_inv_def]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))",
            "have q: \"q > 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))\n\ngoal (1 subgoal):\n 1. 0 < q",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < q\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "define z where \"z = min x y\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz = min x y\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "have zm: \"z \\<notin> fst ` set m\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m",
            "using Cons(2)",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (xp # m)\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m",
            "unfolding xp z_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set m",
            "by (rule monom_inv_Cons, simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "have zn': \"z \\<notin> fst ` set n'\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'",
            "using Cons(3)",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv n\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'",
            "unfolding n yq z_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv ((y, q) # n')\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set n'",
            "by (rule monom_inv_Cons, simp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<notin> fst ` set n'\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "have smz: \"sum_var_list (xp # m) z = sum_var_list [(x,p)] z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z",
            "using sum_var_list_not[OF zm]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var_list m z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z",
            "by (simp add: sum_var_list_def xp)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "have \"\\<dots> \\<noteq> sum_var_list [(y,q)] z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z",
            "using False",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z",
            "unfolding xp yq",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(y, q) \\<noteq> (x, p)\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z",
            "by (auto simp: sum_var_list_def z_def p q min_def)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "have \"sum_var_list [(y,q)] z = sum_var_list n z\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z",
            "using sum_var_list_not[OF zn']",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var_list n' z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z",
            "by (simp add: sum_var_list_def n yq)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list [(y, q)] z = sum_var_list n z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "finally",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "using False",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)",
            "unfolding n",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list (yq # n') z\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = yq # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (yq # n') x)",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "abbreviation (input) monom_list_vars :: \"'a monom_list \\<Rightarrow> 'a set\"\n  where \"monom_list_vars m \\<equiv> fst ` set m\"",
            0,
            "NA"
        ],
        [
            "",
            "fun monom_mult_list :: \"'a monom_list \\<Rightarrow> 'a monom_list \\<Rightarrow> 'a monom_list\" where \n  \"monom_mult_list [] n = n\"\n| \"monom_mult_list ((x,p) # m) n = (case n of\n     Nil \\<Rightarrow> (x,p) # m \n   | (y,q) # n' \\<Rightarrow> if x = y then (x,p + q) # monom_mult_list m n' else\n       if x < y then (x,p) # monom_mult_list m n else (y,q) # monom_mult_list ((x,p) # m) n')\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma monom_list_mult_list_vars: \"monom_list_vars (monom_mult_list m1 m2) = monom_list_vars m1 \\<union> monom_list_vars m2\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (monom_mult_list m1 m2) = fst ` set m1 \\<union> fst ` set m2",
            "by (induct m1 m2 rule: monom_mult_list.induct, auto split: list.splits)",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_list_inv: \"monom_inv m1 \\<Longrightarrow> monom_inv m2 \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monom_inv m1; monom_inv m2\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)",
            "proof (induct m1 m2 rule: monom_mult_list.induct)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)",
            "case (2 x p m n')",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m; monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa; monom_inv m; monom_inv n'\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n')\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\nmonom_inv ((x, p) # m)\nmonom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)",
            "note IH = 2(1-3)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m; monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa; monom_inv m; monom_inv n'\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n')\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)",
            "note xpm = 2(4)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv ((x, p) # m)\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)",
            "note n' = 2(5)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "proof (cases n')",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn' = []\n\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "with xpm",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv ((x, p) # m)\nn' = []",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\nn' = []\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case (Cons yq n)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn' = yq # n\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "then",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nn' = yq # n",
            "obtain y q where id: \"n' = ((y,q) # n)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nn' = yq # n\n\ngoal (1 subgoal):\n 1. (\\<And>y q. n' = (y, q) # n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases yq, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nn' = (y, q) # n\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from xpm",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv ((x, p) # m)",
            "have m: \"monom_inv m\" and p: \"p > 0\" and x: \"x \\<notin> fst ` set m\" \n      and xm: \"\\<And> z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. (monom_inv m &&& 0 < p) &&& x \\<notin> fst ` set m &&& (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)",
            "unfolding monom_inv_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m) &&& 0 < p) &&& x \\<notin> fst ` set m &&& (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)",
            "by (auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv m\n0 < p\nx \\<notin> fst ` set m\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from n'[unfolded id]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv ((y, q) # n)",
            "have n: \"monom_inv n\" and q: \"q > 0\" and y: \"y \\<notin> fst ` set n\" \n      and yn: \"\\<And> z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv ((y, q) # n)\n\ngoal (1 subgoal):\n 1. (monom_inv n &&& 0 < q) &&& y \\<notin> fst ` set n &&& (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)",
            "unfolding monom_inv_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n)) \\<and> sorted (map fst ((y, q) # n))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n) &&& 0 < q) &&& y \\<notin> fst ` set n &&& (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)",
            "by (auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv n\n0 < q\ny \\<notin> fst ` set n\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "proof (cases \"x = y\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "hence res: \"monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n",
            "by (simp add: id)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from IH(1)[OF id refl True m n]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv (monom_mult_list m n)",
            "have inv: \"monom_inv (monom_mult_list m n)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list m n)\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "unfolding res",
            7,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)",
            "using inv p x y True xm yn",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n)\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx = y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)",
            "by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "proof (cases \"x < y\")",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case True",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "hence res: \"monom_mult_list ((x, p) # m) n' = (x,p) # monom_mult_list m n'\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx < y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'",
            "by (auto simp add: id)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from IH(2)[OF id refl False True m n']",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv (monom_mult_list m n')",
            "have inv: \"monom_inv (monom_mult_list m n')\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n')\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n')",
            ".",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list m n')\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "unfolding res",
            9,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')",
            "using inv p x y True xm yn",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n')\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx < y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')",
            "unfolding id",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list m ((y, q) # n))\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx < y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m ((y, q) # n))",
            "by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "case gt: False",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> x < y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "with False",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> x < y",
            "have lt: \"y < x\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> x < y\n\ngoal (1 subgoal):\n 1. y < x",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny < x\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "hence res: \"monom_mult_list ((x, p) # m) n' = (y,q) # monom_mult_list ((x, p) # m) n\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny < x\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n",
            "using False",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny < x\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n",
            "by (auto simp add: id)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from lt",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny < x",
            "have zm: \"z \\<le> x \\<Longrightarrow> (z,b) \\<notin> set m\" for z b",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny < x\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m",
            "using xm[of z] x",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny < x\nz \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\nx \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m",
            "by force",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from zm[of y] lt",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\ny < x",
            "have ym: \"(y,b) \\<notin> set m\" for b",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\ny < x\n\ngoal (1 subgoal):\n 1. (y, b) \\<notin> set m",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(y, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from yn",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z",
            "have yn': \"(a, b) \\<in> set n \\<Longrightarrow> y \\<le> a\" for a b",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> set n \\<Longrightarrow> y \\<le> a",
            "by force",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "from IH(3)[OF id refl False gt xpm n]",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_inv (monom_mult_list ((x, p) # m) n)",
            "have inv: \"monom_inv (monom_mult_list ((x, p) # m) n)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n)",
            ".",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "define xpm where \"xpm = ((x,p) # m)\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxpm = (x, p) # m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "have xpm': \"fst ` set xpm = insert x (fst ` set m)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xpm = insert x (fst ` set m)",
            "unfolding xpm_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ((x, p) # m) = insert x (fst ` set m)",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')",
            "unfolding res",
            9,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)",
            "using inv p q x y False gt ym lt xm yn' zm xpm'",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n0 < p\n0 < q\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx \\<noteq> y\n\\<not> x < y\n(y, ?b) \\<notin> set m\ny < x\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)",
            "unfolding id xpm_def[symmetric]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv (monom_mult_list xpm n)\n0 < p\n0 < q\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx \\<noteq> y\n\\<not> x < y\n(y, ?b) \\<notin> set m\ny < x\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list xpm n)",
            "by (auto simp add: monom_inv_def monom_list_mult_list_vars)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)",
            "qed auto",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_inv_ConsD: \"monom_inv (x # xs) \\<Longrightarrow> monom_inv xs\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (x # xs) \\<Longrightarrow> monom_inv xs",
            "by (auto simp: monom_inv_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_var_list_monom_mult_list:  \"sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x",
            "proof (induct m n rule: monom_mult_list.induct)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n. \\<lbrakk>\\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m x22) x = sum_var_list m x + sum_var_list x22 x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; \\<not> xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) x22) x = sum_var_list ((xa, p) # m) x + sum_var_list x22 x\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x = sum_var_list ((xa, p) # m) x + sum_var_list n x",
            "case (2 x p m n)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x = sum_var_list m x + sum_var_list ?x22.0 x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x = sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (2 subgoals):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n. \\<lbrakk>\\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m x22) x = sum_var_list m x + sum_var_list x22 x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; \\<not> xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) x22) x = sum_var_list ((xa, p) # m) x + sum_var_list x22 x\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x = sum_var_list ((xa, p) # m) x + sum_var_list n x",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x = sum_var_list m x + sum_var_list ?x22.0 x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x = sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list ((x, p) # m) n) x = sum_var_list ((x, p) # m) x + sum_var_list n x",
            "by (cases n; cases \"hd n\", auto split: if_splits simp: sum_var_list_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsum_var_list (monom_mult_list ((x, p) # m) n) x = sum_var_list ((x, p) # m) x + sum_var_list n x\n\ngoal (1 subgoal):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x",
            "qed (auto simp: sum_var_list_def)",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_list_inj: assumes m: \"monom_inv m\" and m1: \"monom_inv m1\" and m2: \"monom_inv m2\"\n  and eq: \"monom_mult_list m m1 = monom_mult_list m m2\"\n  shows \"m1 = m2\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. m1 = m2",
            "from eq sum_var_list_monom_mult_list[of m]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmonom_mult_list m m1 = monom_mult_list m m2\nsum_var_list (monom_mult_list m ?n) ?x = sum_var_list m ?x + sum_var_list ?n ?x",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_mult_list m m1 = monom_mult_list m m2\nsum_var_list (monom_mult_list m ?n) ?x = sum_var_list m ?x + sum_var_list ?n ?x\n\ngoal (1 subgoal):\n 1. m1 = m2",
            "by (auto simp: eq_monom_sum_var_list[OF m1 m2] eq_monom_sum_var_list[OF monom_mult_list_inv[OF m m1] monom_mult_list_inv[OF m m2]])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm1 = m2\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_list[simp]: \"eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n",
            "by (induct m n rule: monom_mult_list.induct, auto split: list.splits prod.splits simp: field_simps power_add)",
            1,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "declare monom_mult_list.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "typedef (overloaded) 'v monom = \"Collect (monom_inv :: 'v :: linorder monom_list \\<Rightarrow> bool)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect monom_inv",
            "by (rule exI[of _ Nil], auto simp: monom_inv_def)",
            1,
            "NA"
        ],
        [
            "",
            "setup_lifting type_definition_monom",
            0,
            "NA"
        ],
        [
            "",
            "lift_definition eval_monom :: \"('v :: linorder,'a :: comm_semiring_1)assign \\<Rightarrow> 'v monom \\<Rightarrow> 'a\"\n  is eval_monom_list",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "lift_definition sum_var :: \"'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> nat\" is sum_var_list",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "instantiation monom :: (linorder) comm_monoid_mult\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lift_definition times_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> 'a monom\" is monom_mult_list",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2. \\<lbrakk>list1 \\<in> Collect monom_inv; list2 \\<in> Collect monom_inv\\<rbrakk> \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv",
            "using monom_mult_list_inv",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>monom_inv ?m1.0; monom_inv ?m2.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ?m1.0 ?m2.0)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2. \\<lbrakk>list1 \\<in> Collect monom_inv; list2 \\<in> Collect monom_inv\\<rbrakk> \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lift_definition one_monom :: \"'a monom\" is Nil",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Collect monom_inv",
            "by (auto simp: monom_inv_def)",
            1,
            "NA"
        ],
        [
            "",
            "instance",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, comm_monoid_mult_class)",
            "proof",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a",
            "fix a b c :: \"'a monom\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a",
            "show \"a * b * c = a * (b * c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)",
            "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\na * b * c = a * (b * c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a",
            "show \"a * b = b * a\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a",
            "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\na * b = b * a\n\ngoal (1 subgoal):\n 1. \\<And>a. 1 * a = a",
            "show \"1 * a = a\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a",
            "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list monom_mult_list.simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n1 * a = a\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "lemma eq_monom_sum_var: \"m = n \\<longleftrightarrow> (\\<forall> x. sum_var m x = sum_var n x)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var m x = sum_var n x)",
            "by (transfer, auto simp: eq_monom_sum_var_list)",
            1,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_mult[simp]: \"eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n",
            "by (transfer, rule monom_mult_list)",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_var_monom_mult:  \"sum_var (m * n) x = sum_var m x + sum_var n x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var (m * n) x = sum_var m x + sum_var n x",
            "by (transfer, rule sum_var_list_monom_mult_list)",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_inj: fixes m1 :: \"_ monom\"\n  shows \"m * m1 = m * m2 \\<Longrightarrow> m1 = m2\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. m * m1 = m * m2 \\<Longrightarrow> m1 = m2",
            "by (transfer, rule monom_mult_list_inj, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lemma one_monom_inv_sum_var_inv[simp]: \"sum_var 1 x = 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var 1 x = 0",
            "by (transfer, auto simp: sum_var_list_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_1[simp]: \"eval_monom  \\<alpha> 1 = 1\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> 1 = (1::'a)",
            "by (transfer, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lift_definition var_monom :: \"'v :: linorder \\<Rightarrow> 'v monom\" is \"\\<lambda> x. [(x,1)]\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. [(v, 1)] \\<in> Collect monom_inv",
            "by (auto simp: monom_inv_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma var_monom_1[simp]: \"var_monom x \\<noteq> 1\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. var_monom x \\<noteq> 1",
            "by (transfer, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lemma eval_var_monom[simp]: \"eval_monom \\<alpha> (var_monom x) = \\<alpha> x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (var_monom x) = \\<alpha> x",
            "by (transfer, auto)",
            1,
            "NA"
        ],
        [
            "",
            "lemma sum_var_monom_var: \"sum_var (var_monom x) y = (if x = y then 1 else 0)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var (var_monom x) y = (if x = y then 1 else 0)",
            "by (transfer, auto simp: sum_var_list_def)",
            1,
            "NA"
        ],
        [
            "",
            "instantiation monom :: (\"{equal,linorder}\")equal\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lift_definition equal_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> bool\" is \"(=)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "instance",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, equal_class)",
            "by (standard, transfer, auto)",
            1,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "type_synonym ('v,'a)poly = \"('v monom \\<times> 'a)list\"",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_inv :: \"('v,'a :: zero)poly \\<Rightarrow> bool\"\n  where \"poly_inv p \\<equiv> (\\<forall> c \\<in> snd ` set p. c \\<noteq> 0) \\<and> distinct (map fst p)\"",
            0,
            "NA"
        ],
        [
            "",
            "abbreviation eval_monomc where \"eval_monomc \\<alpha> mc \\<equiv> eval_monom \\<alpha> (fst mc) * (snd mc)\"",
            0,
            "NA"
        ],
        [
            "",
            "primrec eval_poly :: \"('v :: linorder, 'a :: comm_semiring_1)assign \\<Rightarrow> ('v,'a)poly \\<Rightarrow> 'a\" where \n  \"eval_poly \\<alpha> [] = 0\"\n| \"eval_poly \\<alpha> (mc # p) = eval_monomc \\<alpha> mc + eval_poly \\<alpha> p\"",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_const :: \"'a :: zero \\<Rightarrow> ('v :: linorder,'a)poly\" where\n  \"poly_const a = (if a = 0 then [] else [(1,a)])\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_const[simp]: \"eval_poly \\<alpha> (poly_const a) = a\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_const a) = a",
            "unfolding poly_const_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (if a = (0::'a) then [] else [(1, a)]) = a",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_const_inv: \"poly_inv (poly_const a)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_const a)",
            "unfolding poly_const_def poly_inv_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (if a = (0::'b) then [] else [(1, a)]). c \\<noteq> (0::'b)) \\<and> distinct (map fst (if a = (0::'b) then [] else [(1, a)]))",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "fun poly_add :: \"('v,'a)poly \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_add [] q = q\"\n| \"poly_add ((m,c) # p) q = (case List.extract (\\<lambda> mc. fst mc = m) q of\n    None \\<Rightarrow> (m,c) # poly_add p q\n  | Some (q1,(_,d),q2) \\<Rightarrow> if (c+d = 0) then poly_add p (q1 @ q2) else (m,c+d) # poly_add p (q1 @ q2))\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma eval_poly_append[simp]: \"eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2",
            "by (induct mc1, auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "abbreviation poly_monoms :: \"('v,'a)poly \\<Rightarrow> 'v monom set\"\n  where \"poly_monoms p \\<equiv> fst ` set p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_add_monoms: \"poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2",
            "proof (induct p1 arbitrary: p2)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2",
            "hence m: \"m \\<in> poly_monoms (mc # p1)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. m \\<in> poly_monoms (mc # p1)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm \\<in> poly_monoms (mc # p1)\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "proof (cases \"List.extract (\\<lambda> nd. fst nd = m) p2\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "case None",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "with Cons m",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\nm \\<in> poly_monoms (mc # p1)\nList.extract (\\<lambda>nd. fst nd = m) p2 = None",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\nm \\<in> poly_monoms (mc # p1)\nList.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "by (auto simp: mc)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "case (Some res)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>nd. fst nd = m) p2 = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "obtain q1 md q2 where res: \"res = (q1,md,q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "from extract_SomeE[OF Some[simplified res]] res",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np2 = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)",
            "obtain d where q: \"p2 = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np2 = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>p2 = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\np2 = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2",
            "by (simp add: mc Some res, rule subset_trans[OF Cons[of \"q1 @ q2\"]], auto simp: q)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2",
            "qed simp",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_add_inv: \"poly_inv p \\<Longrightarrow> poly_inv q \\<Longrightarrow> poly_inv (poly_add p q)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q)",
            "proof (induct p arbitrary: q)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>poly_inv p; poly_inv ?q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p ?q)\npoly_inv (mc # p)\npoly_inv q\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)",
            "with Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)",
            "have p: \"poly_inv p\" and c: \"c \\<noteq> 0\" and mp: \"\\<forall> mm \\<in> fst ` set p. (\\<not> mm = m)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p &&& c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m",
            "unfolding poly_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p) &&& c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p\nc \\<noteq> (0::'b)\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)",
            "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "case None",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "hence mq: \"\\<forall> mm \\<in> fst ` set q. \\<not> mm = m\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m",
            "by (auto simp: extract_None_iff)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "fix mm",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "assume \"mm \\<in> fst ` set (poly_add p q)\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "then",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm \\<in> poly_monoms (poly_add p q)",
            "obtain dd where \"(mm,dd) \\<in> set (poly_add p q)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms (poly_add p q)\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (poly_add p q) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(mm, dd) \\<in> set (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "with poly_add_monoms",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p q)",
            "have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p q)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q",
            "by force",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "hence \"\\<not> mm = m\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "using mp mq",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "note main = this",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)",
            "using Cons(1)[OF p Cons(3)]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (poly_add p q)\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)",
            "unfolding poly_inv_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p q))\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add (mc # p) q))",
            "using main",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p q))\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add (mc # p) q))",
            "by (auto simp add: None mc c)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "case (Some res)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "obtain q1 md q2 where res: \"res = (q1,md,q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "from extract_SomeE[OF Some[simplified res]] res",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)",
            "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "from q Cons(3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq = q1 @ (m, d) # q2\npoly_inv q",
            "have q1q2: \"poly_inv (q1 @ q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ (m, d) # q2\npoly_inv q\n\ngoal (1 subgoal):\n 1. poly_inv (q1 @ q2)",
            "unfolding poly_inv_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ (m, d) # q2\n(\\<forall>c\\<in>snd ` set q. c \\<noteq> (0::'b)) \\<and> distinct (map fst q)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (q1 @ q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ q2))",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "from Cons(1)[OF p q1q2]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (poly_add p (q1 @ q2))",
            "have main1: \"poly_inv (poly_add p (q1 @ q2))\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add p (q1 @ q2))",
            ".",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "fix mm",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "assume \"mm \\<in> fst ` set (poly_add p (q1 @ q2))\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "then",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))",
            "obtain dd where \"(mm,dd) \\<in> set (poly_add p (q1 @ q2))\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (poly_add p (q1 @ q2)) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "with poly_add_monoms",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))",
            "have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)",
            "by force",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "hence \"mm \\<noteq> m\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "proof",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "assume \"mm \\<in> poly_monoms p\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms p\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "thus ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "using mp",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms p\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "assume member: \"mm \\<in> poly_monoms (q1 @ q2)\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "from member",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm \\<in> poly_monoms (q1 @ q2)",
            "have \"mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m",
            "thus \"mm \\<noteq> m\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "proof",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m",
            "assume \"mm \\<in> poly_monoms q2\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms q2\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m",
            "with Cons(3)[simplified q]",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q2",
            "show ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "unfolding poly_inv_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ (m, d) # q2))\nmm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m",
            "next",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m",
            "assume \"mm \\<in> poly_monoms q1\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m",
            "with Cons(3)[simplified q]",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q1",
            "show ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "unfolding poly_inv_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ (m, d) # q2))\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "note main2 = this",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)",
            "using  main1[unfolded poly_inv_def] main2",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p (q1 @ q2)). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p (q1 @ q2)))\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)",
            "by (auto simp: poly_inv_def mc Some res)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)",
            "qed simp",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_add[simp]: \"eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q",
            "proof (induct p arbitrary: q)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_add p ?q) = eval_poly \\<alpha> p + eval_poly \\<alpha> ?q\n\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "case None",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "by (simp add: Cons[of q] mc None field_simps)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "case (Some res)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "obtain q1 md q2 where res: \"res = (q1,md,q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "from extract_SomeE[OF Some[simplified res]] res",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)",
            "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "fix x",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "assume c: \"c + d = 0\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc + d = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "have \"c * x + d * x = (c + d) * x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. c * x + d * x = (c + d) * x",
            "by (auto simp: field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "have \"\\<dots> = 0 * x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (c + d) * x = (0::'a) * x",
            "by (simp only: c)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(c + d) * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "finally",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nc * x + d * x = (0::'a) * x",
            "have \"c * x + d * x = 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc * x + d * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. c * x + d * x = (0::'a)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * x + d * x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "note id = this",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q",
            "by (simp add: Cons[of \"q1 @ q2\"] mc Some res, simp only: q, simp add: field_simps, auto simp: field_simps id)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q",
            "qed simp",
            2,
            "NA"
        ],
        [
            "",
            "declare poly_add.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "fun monom_mult_poly :: \"('v :: linorder monom \\<times> 'a) \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"monom_mult_poly _ [] = []\"\n| \"monom_mult_poly (m,c) ((m',d) # p) = (if c * d = 0 then monom_mult_poly (m,c) p else (m * m', c * d) # monom_mult_poly (m,c) p)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_poly_inv: \"poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m,c) p)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) [])",
            "by (simp add: poly_inv_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "case (Cons md p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)\npoly_inv (md # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "obtain m' d where md: \"md = (m',d)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m' d. md = (m', d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "with Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (md # p)\nmd = (m', d)",
            "have p: \"poly_inv p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (md # p)\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. poly_inv p",
            "unfolding poly_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (md # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (md # p))\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "from Cons(1)[OF p]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (monom_mult_poly (m, c) p)",
            "have prod: \"poly_inv (monom_mult_poly (m,c) p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) p)",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "fix mm",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "assume \"mm \\<in> fst ` set (monom_mult_poly (m,c) p)\" \n       and two: \"mm = m * m'\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "then",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'",
            "obtain dd where one: \"(mm,dd) \\<in> set (monom_mult_poly (m,c) p)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (monom_mult_poly (m, c) p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "have \"poly_monoms (monom_mult_poly (m,c) p) \\<subseteq> (*) m ` poly_monoms p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p",
            "proof (induct p, simp)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow> poly_monoms (monom_mult_poly (m, c) (a # p)) \\<subseteq> (*) m ` poly_monoms (a # p)",
            "case (Cons md p)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow> poly_monoms (monom_mult_poly (m, c) (a # p)) \\<subseteq> (*) m ` poly_monoms (a # p)",
            "thus ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) (md # p)) \\<subseteq> (*) m ` poly_monoms (md # p)",
            "by (cases md, auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) (md # p)) \\<subseteq> (*) m ` poly_monoms (md # p)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "with one",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p",
            "have \"mm \\<in> (*) m ` poly_monoms p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<in> (*) m ` poly_monoms p",
            "by force",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "then",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm \\<in> (*) m ` poly_monoms p",
            "obtain mmm where mmm: \"mmm \\<in> poly_monoms p\" and mm: \"mm = m * mmm\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. (\\<And>mmm. \\<lbrakk>mmm \\<in> poly_monoms p; mm = m * mmm\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmmm \\<in> poly_monoms p\nmm = m * mmm\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "from Cons(2)[simplified md] mmm",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv ((m', d) # p)\nmmm \\<in> poly_monoms p",
            "have not1: \"\\<not> mmm = m'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv ((m', d) # p)\nmmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'",
            "unfolding poly_inv_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set ((m', d) # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst ((m', d) # p))\nmmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "from mm two",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmm = m * mmm\nmm = m * m'",
            "have \"m * mmm = m * m'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmm = m * mmm\nmm = m * m'\n\ngoal (1 subgoal):\n 1. m * mmm = m * m'",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm * mmm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "from monom_mult_inj[OF this] not1",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nmmm = m'\nmmm \\<noteq> m'",
            "have False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmmm = m'\nmmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. False",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p); ?mm2 = m * m'\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p); ?mm2 = m * m'\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) (md # p))",
            "by (simp add: md prod, intro impI, auto simp: poly_inv_def prod[simplified poly_inv_def])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) (md # p))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_mult_poly[simp]: \"eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p",
            "proof (cases mc)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p",
            "case (Pair m c)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p",
            "proof (simp add: Pair, induct p)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)",
            "case (Cons nd q)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) q) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> q\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)",
            "obtain n d where nd: \"nd = (n,d)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d. nd = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases nd, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nnd = (n, d)\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "proof (cases \"c * d = 0\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * d \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "thus ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc * d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "by (simp add: nd Cons field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * d = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "let ?l = \"c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n))\"",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "have \"?l = (c * d) * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)",
            "by (simp only: field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "have \"\\<dots> = 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)",
            "by (simp only: True, simp add: field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "finally",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)",
            "have l: \"?l = 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)",
            "by (simp add: nd Cons True, simp add: field_simps l)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []",
            "qed simp",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "declare monom_mult_poly.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_minus :: \"('v :: linorder,'a :: ring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_minus f g = poly_add f (monom_mult_poly (1,-1) g)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_minus[simp]: \"eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g",
            "unfolding poly_minus_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add f (monom_mult_poly (1, - (1::'a)) g)) = eval_poly \\<alpha> f - eval_poly \\<alpha> g",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_minus_inv: \"poly_inv f \\<Longrightarrow> poly_inv g \\<Longrightarrow> poly_inv (poly_minus f g)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk> \\<Longrightarrow> poly_inv (poly_minus f g)",
            "unfolding poly_minus_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add f (monom_mult_poly (1, - (1::'b)) g))",
            "by (intro poly_add_inv monom_mult_poly_inv)",
            1,
            "NA"
        ],
        [
            "",
            "fun poly_mult :: \"('v :: linorder, 'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_mult [] q = []\"\n| \"poly_mult (mc # p) q = poly_add (monom_mult_poly mc q) (poly_mult p q)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_mult_inv: assumes p: \"poly_inv p\" and q: \"poly_inv q\"\n  shows \"poly_inv (poly_mult p q)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)",
            "using p",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult [] q)",
            "by (simp add: poly_inv_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_mult [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (poly_mult p q)\npoly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "with Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)",
            "have p: \"poly_inv p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p",
            "unfolding poly_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult (mc # p) q)",
            "by (simp add: mc, rule poly_add_inv[OF monom_mult_poly_inv[OF q] Cons(1)[OF p]])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_mult (mc # p) q)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_mult[simp]: \"eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q",
            "by (induct p, auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "declare poly_mult.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "definition zero_poly :: \"('v,'a)poly\"\nwhere \"zero_poly \\<equiv> []\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma zero_poly_inv: \"poly_inv zero_poly\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv zero_poly",
            "unfolding zero_poly_def poly_inv_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set []. c \\<noteq> (0::'b)) \\<and> distinct (map fst [])",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "definition one_poly :: \"('v :: linorder,'a :: semiring_1)poly\" where \n  \"one_poly \\<equiv> [(1,1)]\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma one_poly_inv: \"poly_inv one_poly\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv one_poly",
            "unfolding one_poly_def poly_inv_def monom_inv_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, 1::'b)]. c \\<noteq> (0::'b)) \\<and> distinct (map fst [(1, 1::'b)])",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_one[simp]: \"eval_poly \\<alpha> one_poly = 1\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> one_poly = (1::'a)",
            "unfolding one_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [(1, 1::'a)] = (1::'a)",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_zero_add: \"poly_add zero_poly p = p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add zero_poly p = p",
            "unfolding zero_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add [] p = p",
            "using poly_add.simps",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_add [] ?q = ?q\npoly_add ((?m, ?c) # ?p) ?q = (case List.extract (\\<lambda>mc. fst mc = ?m) ?q of None \\<Rightarrow> (?m, ?c) # poly_add ?p ?q | Some (q1, (x, d), q2) \\<Rightarrow> if ?c + d = (0::?'a) then poly_add ?p (q1 @ q2) else (?m, ?c + d) # poly_add ?p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_add [] p = p",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_zero_mult: \"poly_mult zero_poly p = zero_poly\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult zero_poly p = zero_poly",
            "unfolding zero_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult [] p = []",
            "using poly_mult.simps",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_mult [] ?q = []\npoly_mult (?mc # ?p) ?q = poly_add (monom_mult_poly ?mc ?q) (poly_mult ?p ?q)\n\ngoal (1 subgoal):\n 1. poly_mult [] p = []",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "definition eq_poly :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"=p\" 51)\nwhere \"p =p q \\<equiv> \\<forall> \\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_one_mult: \"poly_mult one_poly p =p p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult one_poly p =p p",
            "unfolding eq_poly_def one_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult [(1, 1::'b)] p) = eval_poly \\<alpha> p",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma eq_poly_refl[simp]: \"p =p p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p =p p",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> p",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma eq_poly_trans[trans]: \"\\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. eval_poly \\<alpha> p1 = eval_poly \\<alpha> p2; \\<forall>\\<alpha>. eval_poly \\<alpha> p2 = eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. eval_poly \\<alpha> p1 = eval_poly \\<alpha> p3",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_add_comm: \"poly_add p q =p poly_add q p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q =p poly_add q p",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> (poly_add q p)",
            "by (auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_add_assoc: \"poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_add p1 (poly_add p2 p3)) = eval_poly \\<alpha> (poly_add (poly_add p1 p2) p3)",
            "by (auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_mult_comm: \"poly_mult p q =p poly_mult q p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p q =p poly_mult q p",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> (poly_mult q p)",
            "by (auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_mult_assoc: \"poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p1 (poly_mult p2 p3)) = eval_poly \\<alpha> (poly_mult (poly_mult p1 p2) p3)",
            "by (auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_distrib: \"poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p (poly_add q1 q2)) = eval_poly \\<alpha> (poly_add (poly_mult p q1) (poly_mult p q2))",
            "by (auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Computing normal forms of polynomials\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "fun\n  poly_of :: \"('v :: linorder,'a :: comm_semiring_1)tpoly \\<Rightarrow> ('v,'a)poly\"\nwhere \"poly_of (PNum i) = (if i = 0 then [] else [(1,i)])\"\n    | \"poly_of (PVar x) = [(var_monom x,1)]\"\n    | \"poly_of (PSum []) = zero_poly\" \n    | \"poly_of (PSum (p # ps)) = (poly_add (poly_of p) (poly_of (PSum ps)))\"\n    | \"poly_of (PMult []) = one_poly\" \n    | \"poly_of (PMult (p # ps)) = (poly_mult (poly_of p) (poly_of (PMult ps)))\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_of: \"eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p",
            "by (induct p rule: poly_of.induct, (simp add: zero_poly_def one_poly_def)+)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_of_inv: \"poly_inv (poly_of p)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_of p)",
            "by (induct p rule: poly_of.induct, \n    simp add: poly_inv_def monom_inv_def,\n    simp add: poly_inv_def monom_inv_def,\n    simp add: zero_poly_inv,\n    simp add: poly_add_inv,\n    simp add: one_poly_inv,\n    simp add: poly_mult_inv)",
            1,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Powers and substitutions of polynomials\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "fun poly_power :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> nat \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_power _ 0 = one_poly\"\n| \"poly_power p (Suc n) = poly_mult p (poly_power p n)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_power[simp]: \"eval_poly \\<alpha> (poly_power p n) = (eval_poly \\<alpha> p) ^ n\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_power p n) = eval_poly \\<alpha> p ^ n",
            "by (induct n, auto simp: one_poly_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_power_inv: assumes p: \"poly_inv p\" \n  shows \"poly_inv (poly_power p n)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_power p n)",
            "by (induct n, simp add: one_poly_inv, simp add: poly_mult_inv[OF p])",
            1,
            "NA"
        ],
        [
            "",
            "declare poly_power.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "fun monom_list_subst :: \"('v \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom_list \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_list_subst \\<sigma> [] = one_poly\"\n| \"monom_list_subst \\<sigma> ((x,p) # m) = poly_mult (poly_power (\\<sigma> x) p) (monom_list_subst \\<sigma> m)\"",
            0,
            "NA"
        ],
        [
            "",
            "lift_definition monom_list :: \"'v :: linorder monom \\<Rightarrow> 'v monom_list\" is \"\\<lambda> x. x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "definition monom_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_subst \\<sigma> m = monom_list_subst \\<sigma> (monom_list m)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma monom_list_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_list_subst \\<sigma> m)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> m)",
            "proof (induct m)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> [])",
            "by (simp add: one_poly_inv)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "case (Cons xp m)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> m)\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "obtain x p where xp: \"xp = (x,p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases xp, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (xp # m))",
            "by (simp add: xp, rule poly_mult_inv[OF poly_power_inv[OF sub] Cons])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> (xp # m))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_subst \\<sigma> m)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_subst \\<sigma> m)",
            "unfolding monom_subst_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (monom_list m))",
            "by (rule monom_list_subst_inv[OF sub])",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_subst[simp]: \"eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m",
            "unfolding monom_subst_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_list_subst \\<sigma> (monom_list m)) = eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m",
            "proof (transfer fixing: \\<alpha> \\<sigma>, clarsimp)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m",
            "fix m",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m",
            "show \"monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m",
            "by (induct m, simp add: one_poly_def, auto simp: field_simps monom_inv_ConsD)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "fun poly_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('w,'a)poly\" where \n  \"poly_subst \\<sigma> [] = zero_poly\"\n| \"poly_subst \\<sigma> ((m,c) # p) = poly_add (poly_mult [(1,c)] (monom_subst \\<sigma> m)) (poly_subst \\<sigma> p)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" and p: \"poly_inv p\"\n  shows \"poly_inv (poly_subst \\<sigma> p)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)",
            "using p",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> [])",
            "by (simp add: zero_poly_inv)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p)\npoly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "with Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)",
            "have c: \"c \\<noteq> 0\" and p: \"poly_inv p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&& poly_inv p",
            "unfolding poly_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'c)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&& (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'c)) \\<and> distinct (map fst p)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc \\<noteq> (0::'c)\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "from c",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nc \\<noteq> (0::'c)",
            "have c: \"poly_inv [(1,c)]\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. poly_inv [(1, c)]",
            "unfolding poly_inv_def monom_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, c)]. c \\<noteq> (0::'c)) \\<and> distinct (map fst [(1, c)])",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv [(1, c)]\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> (mc # p))",
            "by (simp add: mc, rule poly_add_inv[OF poly_mult_inv[OF c monom_subst_inv[OF sub]] Cons(1)[OF p]])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_inv (poly_subst \\<sigma> (mc # p))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_subst: \"eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) p",
            "by (induct p, simp add: zero_poly_def, auto simp: field_simps)",
            1,
            "NA"
        ],
        [
            "",
            "lemma eval_poly_subst: \n  assumes eq: \"\\<And> w. f w = eval_poly g (q w)\"\n  shows \"eval_poly f p = eval_poly g (poly_subst q p)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst q p)",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])",
            "by (simp add: zero_poly_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f [] = eval_poly g (poly_subst q [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst q p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "have id: \"eval_monom f m =  eval_monom (\\<lambda>v. eval_poly g (q v)) m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m",
            "proof (transfer fixing: f g q, clarsimp)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m",
            "fix m",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m",
            "show \"eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m",
            "proof (induct m)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)",
            "case (Cons wp m)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)",
            "obtain w p where wp: \"wp = (w,p)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w p. wp = (w, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases wp, auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwp = (w, p)\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f (wp # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)",
            "by (simp add: wp Cons eq)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list f (wp # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)\n\ngoal (1 subgoal):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []",
            "qed simp",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))",
            "by (simp add: mc Cons id, simp add: field_simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lift_definition monom_vars_list :: \"'v :: linorder monom \\<Rightarrow> 'v list\" is \"map fst\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_vars_list_subst: assumes \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\" \n  shows \"monom_subst f m = monom_subst g m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m",
            "unfolding monom_subst_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)",
            "proof (transfer fixing: f g)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m",
            "fix m :: \"'a monom_list\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m",
            "assume eq: \"\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m",
            "thus \"monom_list_subst f m = monom_list_subst g m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m",
            "proof (induct m)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)",
            "case (Cons wn m)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m\n?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)",
            "hence rec: \"monom_list_subst f m = monom_list_subst g m\" and eq: \"f (fst wn) = g (fst wn)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m\n?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m &&& f (fst wn) = g (fst wn)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_list_subst f m = monom_list_subst g m\nf (fst wn) = g (fst wn)\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)",
            "proof (cases wn)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. wn = (a, b) \\<Longrightarrow> monom_list_subst f (wn # m) = monom_list_subst g (wn # m)",
            "case (Pair w n)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwn = (w, n)\n\ngoal (1 subgoal):\n 1. \\<And>a b. wn = (a, b) \\<Longrightarrow> monom_list_subst f (wn # m) = monom_list_subst g (wn # m)",
            "with eq rec",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf (fst wn) = g (fst wn)\nmonom_list_subst f m = monom_list_subst g m\nwn = (w, n)",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (fst wn) = g (fst wn)\nmonom_list_subst f m = monom_list_subst g m\nwn = (w, n)\n\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []",
            "qed simp",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_list_subst f m = monom_list_subst g m\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_vars_list: assumes \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs",
            "proof (transfer fixing: \\<alpha> \\<beta>)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs",
            "fix xs :: \"'a monom_list\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs",
            "assume eq: \"\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs",
            "thus \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs",
            "proof (induct xs)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)",
            "case (Cons xi xs)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)",
            "hence IH: \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)",
            "obtain x i where xi: \"xi = (x,i)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x i. xi = (x, i) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxi = (x, i)\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)",
            "from Cons(2) xi",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\nxi = (x, i)",
            "have \"\\<alpha> x = \\<beta> x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\nxi = (x, i)\n\ngoal (1 subgoal):\n 1. \\<alpha> x = \\<beta> x",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<alpha> x = \\<beta> x\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)",
            "with IH",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)",
            "unfolding xi",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> ((x, i) # xs) = eval_monom_list \\<beta> ((x, i) # xs)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []",
            "qed simp",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition monom_vars where \"monom_vars m = set (monom_vars_list m)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma monom_vars_list_1[simp]: \"monom_vars_list 1 = []\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list 1 = []",
            "by transfer auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_vars_list_var_monom[simp]: \"monom_vars_list (var_monom x) = [x]\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list (var_monom x) = [x]",
            "by transfer auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_vars_eval_monom: \n  \"(\\<And> x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m",
            "by (rule eval_monom_vars_list, auto simp: monom_vars_def)",
            1,
            "NA"
        ],
        [
            "",
            "definition poly_vars_list :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v list\" where \n  \"poly_vars_list p = remdups (concat (map (monom_vars_list o fst) p))\"",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_vars :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v set\" where \n  \"poly_vars p = set (concat (map (monom_vars_list o fst) p))\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_vars_list[simp]: \"set (poly_vars_list p) = poly_vars p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (poly_vars_list p) = poly_vars p",
            "unfolding poly_vars_list_def poly_vars_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. set (remdups (concat (map (monom_vars_list \\<circ> fst) p))) = set (concat (map (monom_vars_list \\<circ> fst) p))",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_vars: assumes eq: \"\\<And> w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p",
            "using eq",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> poly_vars p \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)",
            "hence rec: \"poly_subst f p = poly_subst g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p",
            "unfolding poly_vars_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (concat (map (monom_vars_list \\<circ> fst) p)) \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> set (concat (map (monom_vars_list \\<circ> fst) (mc # p))) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst f p = poly_subst g p\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)",
            "proof (cases mc)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)",
            "case (Pair m c)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)",
            "with Cons(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)",
            "have \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w",
            "unfolding poly_vars_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (concat (map (monom_vars_list \\<circ> fst) (mc # p))) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)",
            "hence \"monom_subst f m = monom_subst g m\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m",
            "by (rule monom_vars_list_subst)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmonom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)",
            "with rec Pair",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_subst f p = poly_subst g p\nmc = (m, c)\nmonom_subst f m = monom_subst g m",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_subst f p = poly_subst g p\nmc = (m, c)\nmonom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []",
            "qed simp",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_var: assumes pv: \"v \\<notin> poly_vars p\" and diff: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p",
            "proof (rule poly_vars)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w",
            "fix w",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w",
            "assume \"w \\<in> poly_vars p\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w",
            "thus \"f w = g w\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nw \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. f w = g w",
            "using pv diff",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nw \\<in> poly_vars p\nv \\<notin> poly_vars p\nv \\<noteq> ?w \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. f w = g w",
            "by (cases \"v = w\", auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g w\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma eval_poly_vars: assumes \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<beta> []",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> [] = eval_poly \\<beta> []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "case (Cons m p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "from Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x",
            "have \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x",
            "unfolding poly_vars_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> set (concat (map (monom_vars_list \\<circ> fst) (m # p))) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (concat (map (monom_vars_list \\<circ> fst) p)) \\<Longrightarrow> \\<alpha> x = \\<beta> x",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "from Cons(1)[OF this]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> x \\<in> poly_vars p) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p",
            "have IH: \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> x \\<in> poly_vars p) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "obtain xs c where m: \"m = (xs,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs c. m = (xs, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm = (xs, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "from Cons(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x",
            "have \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x",
            "unfolding poly_vars_def m",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> set (concat (map (monom_vars_list \\<circ> fst) ((xs, c) # p))) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "hence \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs",
            "by (rule eval_monom_vars_list)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)",
            "unfolding eval_poly.simps IH m",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (xs, c) + eval_poly \\<beta> p = eval_monomc \\<beta> (xs, c) + eval_poly \\<beta> p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "declare poly_subst.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "subsection \\<open>\n  Polynomial orders\n\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "definition pos_assign :: \"('v,'a :: ordered_semiring_0)assign \\<Rightarrow> bool\"\nwhere \"pos_assign \\<alpha> = (\\<forall> x. \\<alpha> x \\<ge> 0)\"",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_ge :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"\\<ge>p\" 51)\nwhere \"p \\<ge>p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_ge_refl[simp]: \"p \\<ge>p p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p p",
            "unfolding poly_ge_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p",
            "using ge_refl",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_ge_trans[trans]: \"\\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3",
            "unfolding poly_ge_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1",
            "using ge_trans",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y \\<le> ?x; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma pos_assign_monom_list: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom_list \\<alpha> m \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> m",
            "proof (induct m)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []",
            "by (simp add: one_ge_zero)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> []\n\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)",
            "case (Cons xp m)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> m\n\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "proof (cases xp)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "case (Pair x p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "from pos[unfolded pos_assign_def]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> \\<alpha> x",
            "have ge: \"\\<alpha> x \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "have ge: \"\\<alpha> x ^ p \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ p",
            "proof (induct p)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "case 0",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "thus ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0",
            "by (simp add: one_ge_zero)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "case (Suc p)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "from ge_trans[OF times_left_mono[OF ge Suc] times_right_mono[OF ge_refl ge]]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ Suc p",
            "by (simp add: field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ Suc p\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "from ge_trans[OF times_right_mono[OF Cons ge] times_left_mono[OF ge_refl Cons]]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)",
            "by (simp add: Pair)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma pos_assign_monom: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom \\<alpha> m \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m",
            "by (transfer fixing: \\<alpha>, rule pos_assign_monom_list[OF pos])",
            1,
            "NA"
        ],
        [
            "",
            "lemma pos_assign_poly:   assumes pos: \"pos_assign \\<alpha>\"\n  and p: \"p \\<ge>p zero_poly\"\n  shows \"eval_poly \\<alpha> p \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p",
            "from p[unfolded poly_ge_def zero_poly_def] pos",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_add_ge_mono: assumes \"p1 \\<ge>p p2\" shows \"poly_add p1 q \\<ge>p poly_add p2 q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np1 \\<ge>p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q",
            "unfolding poly_ge_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_add p2 q) \\<le> eval_poly \\<alpha> (poly_add p1 q)",
            "by (auto simp: field_simps plus_left_mono)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_mult_ge_mono: assumes \"p1 \\<ge>p p2\" and \"q \\<ge>p zero_poly\"\n  shows \"poly_mult p1 q \\<ge>p poly_mult p2 q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np1 \\<ge>p p2\nq \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q",
            "unfolding poly_ge_def zero_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_mult p2 q) \\<le> eval_poly \\<alpha> (poly_mult p1 q)",
            "by (auto simp: times_left_mono)",
            1,
            "NA"
        ],
        [
            "",
            "context poly_order_carrier\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_gt :: \"('v :: linorder,'a)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \">p\" 51)\nwhere \"p >p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_gt_imp_poly_ge: \"p >p q \\<Longrightarrow> p \\<ge>p q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p >p q \\<Longrightarrow> p \\<ge>p q",
            "unfolding poly_ge_def poly_gt_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p",
            "using gt_imp_ge",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<succ> ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "abbreviation poly_GT :: \"('v :: linorder,'a)poly rel\"\nwhere \"poly_GT \\<equiv> {(p,q) | p q. p >p q \\<and> q \\<ge>p zero_poly}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_compat: \"\\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3",
            "unfolding poly_ge_def poly_gt_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "using compat",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y \\<le> ?x; ?y \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_compat2: \"\\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3",
            "unfolding poly_ge_def poly_gt_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "using compat2",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?x \\<succ> ?y; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_gt_trans[trans]: \"\\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3",
            "unfolding poly_gt_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "using gt_trans",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?x \\<succ> ?y; ?y \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_GT_SN: \"SN poly_GT\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. SN poly_GT",
            "proof",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "fix f :: \"nat \\<Rightarrow> ('c :: linorder,'a)poly\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "assume f: \"\\<forall> i. (f i, f (Suc i)) \\<in> poly_GT\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "have pos: \"pos_assign ((\\<lambda> x. 0) :: ('v,'a)assign)\" (is \"pos_assign ?ass\")",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>x. 0::'a)",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)",
            "using ge_refl",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "obtain g where g: \"\\<And> i. g i = eval_poly ?ass (f i)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. (\\<And>i. g i = eval_poly (\\<lambda>x. 0::'a) (f i)) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng ?i3 = eval_poly (\\<lambda>x. 0::'a) (f ?i3)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "from f pos",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\npos_assign (\\<lambda>x. 0::'a)",
            "have \"\\<forall> i. g (Suc i) \\<ge> 0 \\<and> g i \\<succ> g (Suc i)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)",
            "unfolding poly_gt_def g",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> {(p, q) |p q. (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and> q \\<ge>p zero_poly}\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and> eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ> eval_poly (\\<lambda>x. 0::'a) (f (Suc i))",
            "using pos_assign_poly",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> {(p, q) |p q. (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and> q \\<ge>p zero_poly}\npos_assign (\\<lambda>x. 0::'a)\n\\<lbrakk>pos_assign ?\\<alpha>; ?p \\<ge>p zero_poly\\<rbrakk> \\<Longrightarrow> (0::?'b) \\<le> eval_poly ?\\<alpha> ?p\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and> eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ> eval_poly (\\<lambda>x. 0::'a) (f (Suc i))",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False",
            "with SN",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)",
            "show False",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False",
            "unfolding SN_defs",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<nexists>f. f 0 \\<in> UNIV \\<and> (\\<forall>i. (f i, f (Suc i)) \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_list_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\n  shows \"eval_monom_list f m \\<ge> eval_monom_list g m\" \"eval_monom_list g m \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&& (0::'a) \\<le> eval_monom_list g m",
            "proof (atomize(full), induct m)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []",
            "using one_ge_zero",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::?'a) \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []",
            "by (auto simp: ge_refl)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "case (Cons xd m)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "hence IH1: \" eval_monom_list f m \\<ge> eval_monom_list g m\" and IH2: \"eval_monom_list g m \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&& (0::'a) \\<le> eval_monom_list g m",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list g m \\<le> eval_monom_list f m\n(0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "obtain x d where xd: \"xd = (x,d)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x d. xd = (x, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nxd = (x, d)\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "from pow_mono[OF fg g, of x d]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d",
            "have fgd: \"f x ^ d \\<ge> g x ^ d\" and gd: \"g x ^ d \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. g x ^ d \\<le> f x ^ d &&& (0::'a) \\<le> g x ^ d",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng x ^ d \\<le> f x ^ d\n(0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and> (0::'a) \\<le> eval_monom_list g (xd # m)",
            "unfolding xd eval_monom_list.simps",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m * g x ^ d \\<le> eval_monom_list f m * f x ^ d \\<and> (0::'a) \\<le> eval_monom_list g m * g x ^ d",
            "proof (rule conjI, rule ge_trans[OF times_left_mono[OF pow_ge_zero IH1] times_right_mono[OF IH2 fgd]])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> f x\n 2. (0::'a) \\<le> eval_monom_list g m * g x ^ d",
            "show \"f x \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> f x",
            "by (rule ge_trans[OF fg g])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> f x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d",
            "show \"eval_monom_list g m * g x ^ d \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d",
            "by (rule mult_ge_zero[OF IH2 gd])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list g m * g x ^ d\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and> (0::'a) \\<le> eval_monom_list g (xd # m)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma eval_monom_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\nshows \"eval_monom f m \\<ge> eval_monom g m\" \"eval_monom g m \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m &&& (0::'a) \\<le> eval_monom g m",
            "by (atomize(full), transfer fixing: f g, insert eval_monom_list_mono[of g f, OF fg g], auto)",
            1,
            "NA"
        ],
        [
            "",
            "definition poly_weak_mono_all :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\" where \n  \"poly_weak_mono_all p \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. \\<alpha> x \\<ge> \\<beta> x) \n    \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_mono_all_E: assumes p: \"poly_weak_mono_all p\" and \n  ge: \"\\<And> x. f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p",
            "unfolding poly_ge_def poly_subst",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p",
            "proof (intro allI impI, rule p[unfolded poly_weak_mono_all_def, rule_format])",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "fix \\<alpha> :: \"('c,'b)assign\" and x",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) \\<ge> eval_poly \\<alpha> (g x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)",
            "using ge[of x]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> zero_poly \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "fix \\<alpha> :: \"('c,'b)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "assume alpha: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "show \"eval_poly \\<alpha> (g x) \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using ge[of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def zero_poly_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using alpha",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition poly_weak_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_mono_E: assumes p: \"poly_weak_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p",
            "unfolding poly_ge_def poly_subst",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p",
            "proof (intro allI impI, rule p[unfolded poly_weak_mono_def, rule_format])",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "fix \\<alpha> :: \"('c,'b)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "using fgv",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "fix \\<alpha> :: \"('c,'b)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "assume alpha: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "show \"eval_poly \\<alpha> (g x) \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using g[of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def zero_poly_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using alpha",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "fix \\<alpha> :: \"('c,'b)assign\" and x",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "assume v: \"v \\<noteq> x\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "using fgw[OF v]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition poly_weak_anti_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_anti_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<beta> p \\<ge> eval_poly \\<alpha> p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_anti_mono_E: assumes p: \"poly_weak_anti_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst g p \\<ge>p poly_subst f p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst g p \\<ge>p poly_subst f p",
            "unfolding poly_ge_def poly_subst",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p",
            "proof (intro allI impI, rule p[unfolded poly_weak_anti_mono_def, rule_format])",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "fix \\<alpha> :: \"('c,'b)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "using fgv",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "fix \\<alpha> :: \"('c,'b)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "assume alpha: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "show \"eval_poly \\<alpha> (g x) \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using g[of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def zero_poly_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "using alpha",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "fix \\<alpha> :: \"('c,'b)assign\" and x",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "assume v: \"v \\<noteq> x\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "using fgw[OF v]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes mono: \"\\<And> v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v\"\n  shows \"poly_weak_mono_all p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p",
            "unfolding poly_weak_mono_all_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix \\<alpha> \\<beta> :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume all: \"\\<forall> x. \\<alpha> x \\<ge> \\<beta> x\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x. \\<beta> x \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume pos: \"pos_assign \\<beta>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "let ?ab = \"\\<lambda> vs v. if (v \\<in> set vs) then \\<alpha> v else \\<beta> v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix vs :: \"'v list\"",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume \"set vs \\<subseteq> poly_vars p\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "hence \"eval_poly (?ab vs) p \\<ge> eval_poly \\<beta> p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nset vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p",
            "proof (induct vs)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "case Nil",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset [] \\<subseteq> poly_vars p\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p",
            "by (simp add: ge_refl)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "case (Cons v vs)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\nset (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "hence subset: \"set vs \\<subseteq> poly_vars p\"  and v: \"v \\<in> poly_vars p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nset vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\nset (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> poly_vars p &&& v \\<in> poly_vars p",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset vs \\<subseteq> poly_vars p\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>va. if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va) p",
            "proof (rule ge_trans[OF mono[OF v, unfolded poly_weak_mono_def, rule_format] Cons(1)[OF subset]])",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. pos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n 3. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)",
            "show \"pos_assign (?ab vs)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)",
            "unfolding pos_assign_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "proof",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "fix x",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "from pos[unfolded pos_assign_def]",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> \\<beta> x",
            "have beta: \"\\<beta> x \\<ge> 0\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<beta> x",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "from ge_trans[OF all[rule_format] this]",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> \\<alpha> x",
            "have alpha: \"\\<alpha> x \\<ge> 0\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x",
            ".",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "from alpha beta",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> \\<alpha> x\n(0::'a) \\<le> \\<beta> x",
            "show \"?ab vs x \\<ge> 0\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> \\<alpha> x\n(0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n\ngoal (2 subgoals):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)",
            "show \"(?ab (v # vs) v) \\<ge> (?ab vs v)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)",
            "using all ge_refl",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. \\<beta> x \\<le> \\<alpha> x\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "fix x",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "assume \"v \\<noteq> x\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "thus \"(?ab (v # vs) x) = (?ab vs x)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>va. if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va) p\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nset ?vs2 \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set ?vs2 then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from this[of \"poly_vars_list p\", unfolded poly_vars_list]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_vars p \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p",
            "have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p \\<ge> eval_poly \\<beta> p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_vars p \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "also",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p",
            "by (rule eval_poly_vars, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "finally",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\" \n  assumes p: \"poly_weak_mono_all p\"\n  shows \"poly_weak_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v",
            "unfolding poly_weak_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix \\<alpha> \\<beta> :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume all: \"\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume pos: \"pos_assign \\<beta>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume v: \"\\<alpha> v \\<ge> \\<beta> v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<beta> v \\<le> \\<alpha> v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (rule p[unfolded poly_weak_mono_all_def, rule_format, OF _ pos])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x",
            "show \"\\<alpha> x \\<ge> \\<beta> x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x",
            "using v all ge_refl[of \"\\<beta> x\"]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<beta> v \\<le> \\<alpha> v\n\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n\\<beta> x \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<beta> x \\<le> \\<alpha> x\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_weak_mono_all_pos: \n  fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes pos_at_zero: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"\n  and mono: \"poly_weak_mono_all p\"\n  shows \"p \\<ge>p zero_poly\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly",
            "unfolding poly_ge_def zero_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI, simp)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p",
            "fix  \\<alpha> :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p",
            "assume pos: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p",
            "show \"eval_poly \\<alpha> p \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "proof -",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "let ?id = \"\\<lambda> w. poly_of (PVar w)\"",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "let ?z = \"\\<lambda> w. zero_poly\"",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "have \"poly_subst ?id p \\<ge>p poly_subst ?z p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p",
            "by (rule poly_weak_mono_all_E[OF mono],  \n        simp, simp add: poly_ge_def zero_poly_def pos_assign_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "hence \"eval_poly \\<alpha> (poly_subst ?id p) \\<ge> eval_poly \\<alpha> (poly_subst ?z p)\" (is \"_ \\<ge> ?res\")",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)",
            "unfolding poly_ge_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)",
            "using pos",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "also",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "have \"?res = eval_poly (\\<lambda> w. 0) p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p",
            "by (simp add: poly_subst zero_poly_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "also",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "have \"\\<dots> \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p",
            "by (rule pos_at_zero)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "finally",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p",
            "by  (simp add: poly_subst)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "context poly_order_carrier\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_strict_mono :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_strict_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. (v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x)) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_strict_mono_E: assumes p: \"poly_strict_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v >p g v\"\n  shows \"poly_subst f p >p poly_subst g p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p >p poly_subst g p",
            "unfolding poly_gt_def poly_subst",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p \\<succ> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p",
            "proof (intro allI impI, rule p[unfolded poly_strict_mono_def, rule_format])",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)",
            "fix \\<alpha> :: \"('c,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)",
            "using fgv",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v >p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)",
            "unfolding poly_gt_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "fix \\<alpha> :: \"('c,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "assume alpha: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "show \"eval_poly \\<alpha> (g x) \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "using g[of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def zero_poly_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "using alpha",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "fix \\<alpha> :: \"('c,'a)assign\" and x",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "assume v: \"v \\<noteq> x\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "using fgw[OF v]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "unfolding poly_ge_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_add_gt_mono: assumes \"p1 >p p2\" shows \"poly_add p1 q >p poly_add p2 q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np1 >p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q",
            "unfolding poly_gt_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_add p1 q) \\<succ> eval_poly \\<alpha> (poly_add p2 q)",
            "by (auto simp: field_simps plus_gt_left_mono)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_mult_gt_mono: \n  fixes q :: \"('v :: linorder,'a)poly\"\n  assumes gt: \"p1 >p p2\" and mono: \"q \\<ge>p one_poly\"\n  shows \"poly_mult p1 q >p poly_mult p2 q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q >p poly_mult p2 q",
            "proof (unfold poly_gt_def, intro impI allI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "fix \\<alpha> :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "assume p: \"pos_assign \\<alpha>\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "with gt",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np1 >p p2\npos_assign \\<alpha>",
            "have gt: \"eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np1 >p p2\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2",
            "unfolding poly_gt_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "from mono p",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq \\<ge>p one_poly\npos_assign \\<alpha>",
            "have one: \"eval_poly \\<alpha> q \\<ge> 1\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq \\<ge>p one_poly\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q",
            "unfolding poly_ge_def one_poly_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [(1, 1::'a)] \\<le> eval_poly \\<alpha> q\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "show \"eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "using times_gt_mono[OF gt one]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly \\<alpha> p1 * eval_poly \\<alpha> q \\<succ> eval_poly \\<alpha> p2 * eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Degree of polynomials\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "definition monom_list_degree :: \"'v monom_list \\<Rightarrow> nat\" where \n  \"monom_list_degree xps \\<equiv> sum_list (map snd xps)\"",
            0,
            "NA"
        ],
        [
            "",
            "lift_definition monom_degree :: \"'v :: linorder monom \\<Rightarrow> nat\" is monom_list_degree",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "definition poly_degree :: \"(_,'a) poly \\<Rightarrow> nat\" where\n  \"poly_degree p \\<equiv> max_list (map (\\<lambda> (m,c). monom_degree m) p)\"",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_coeff_sum :: \"('v,'a :: ordered_ab_semigroup) poly \\<Rightarrow> 'a\" where\n  \"poly_coeff_sum p \\<equiv> sum_list (map (\\<lambda> mc. max 0 (snd mc)) p)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma monom_list_degree: \"eval_monom_list (\\<lambda> _. x) m = x ^ monom_list_degree m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ monom_list_degree m",
            "unfolding monom_list_degree_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)",
            "proof (induct m)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))",
            "case (Cons mc m)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) (mc # m) = x ^ sum_list (map snd (mc # m))",
            "by (cases mc, auto simp: power_add field_simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) (mc # m) = x ^ sum_list (map snd (mc # m))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma monom_list_var_monom[simp]: \"monom_list (var_monom x) = [(x,1)]\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_list (var_monom x) = [(x, 1)]",
            "by (transfer, simp)",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_list_1[simp]: \"monom_list 1 = []\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. monom_list 1 = []",
            "by (transfer, simp)",
            1,
            "NA"
        ],
        [
            "",
            "lemma monom_degree: \"eval_monom (\\<lambda> _. x) m = x ^ monom_degree m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom (\\<lambda>_. x) m = x ^ monom_degree m",
            "by (transfer, rule monom_list_degree)",
            1,
            "NA"
        ],
        [
            "",
            "lemma poly_coeff_sum: \"poly_coeff_sum p \\<ge> 0\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> poly_coeff_sum p",
            "unfolding poly_coeff_sum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))",
            "by (simp add: ge_refl)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "have \"(\\<Sum>mc\\<leftarrow>mc # p. max 0 (snd mc)) = max 0 (snd mc) + (\\<Sum>mc\\<leftarrow>p. max 0 (snd mc))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "also",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "have \"\\<dots> \\<ge> 0 + 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + (0::'a) \\<le> max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))",
            "by (rule ge_trans[OF plus_left_mono plus_right_mono[OF Cons]], auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) + (0::'a) \\<le> max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))",
            "finally",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_degree: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  shows \"poly_coeff_sum p * (x ^ poly_degree p) \\<ge> eval_poly (\\<lambda> _. x) p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p",
            "proof (induct p)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []",
            "by (simp add: ge_refl poly_degree_def poly_coeff_sum_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "from ge_trans[OF x one_ge_zero]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> x",
            "have x0: \"x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x",
            ".",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "have id1: \"eval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m  * c + eval_poly (\\<lambda>_. x) p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p",
            "unfolding mc",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) ((m, c) # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p",
            "by (simp add: monom_degree)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "have id2: \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = \n    x ^ max (monom_degree m) (poly_degree p) * (max 0 c) + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)",
            "unfolding poly_coeff_sum_def poly_degree_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) * x ^ max_list (map (\\<lambda>(m, c). monom_degree m) (mc # p)) = x ^ max (monom_degree m) (max_list (map (\\<lambda>(m, c). monom_degree m) p)) * max (0::'a) c + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) * x ^ max (monom_degree m) (max_list (map (\\<lambda>(m, c). monom_degree m) p))",
            "by (simp add: mc field_simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)",
            "show \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) \\<ge> eval_poly (\\<lambda>_. x) (mc # p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p) \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)",
            "unfolding id1 id2",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)",
            "proof (rule ge_trans[OF plus_left_mono plus_right_mono])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. x ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n 2. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)",
            "show \"x ^ max (monom_degree m) (poly_degree p) * max 0 c \\<ge> x ^ monom_degree m * c\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c",
            "by (rule ge_trans[OF times_left_mono[OF _ pow_mono_exp] times_right_mono[OF pow_ge_zero]], insert x x0, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)",
            "show \"poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p) \\<ge> eval_poly (\\<lambda>_. x) p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)",
            "by (rule ge_trans[OF times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x]] Cons], auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly (\\<lambda>_. x) (mc # p) \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_degree_bound: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  and c: \"c \\<ge> poly_coeff_sum p\"\n  and d: \"d \\<ge> poly_degree p\"\n  shows \"c * (x ^ d) \\<ge> eval_poly (\\<lambda> _. x) p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> c * x ^ d",
            "by (rule ge_trans[OF ge_trans[OF \n    times_left_mono[OF pow_ge_zero[OF ge_trans[OF x one_ge_zero]] c]   \n    times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x d]]] poly_degree[OF x]])",
            1,
            "NA"
        ],
        [
            "",
            "subsection \\<open>Executable and sufficient criteria to compare polynomials and ensure monotonicity\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "definition poly_split :: \"('v monom) \\<Rightarrow> ('v,'a :: zero)poly \\<Rightarrow> 'a \\<times> ('v,'a)poly\" \n  where \"poly_split m p \\<equiv> case List.extract (\\<lambda> (n,_). m = n) p of None \\<Rightarrow> (0,p) | Some (p1,(_,c),p2) \\<Rightarrow> (c, p1 @ p2)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma poly_split: assumes \"poly_split m p = (c,q)\"\n  shows \"p =p (m,c) # q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q",
            "proof (cases \"List.extract (\\<lambda> (n,_). m = n) p\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "case None",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "with assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_split m p = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None",
            "have \"(c,q) = (0,p)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_split m p = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)",
            "unfolding poly_split_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(case List.extract (\\<lambda>(n, uu_). m = n) p of None \\<Rightarrow> (0::'a, p) | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(c, q) = (0::'a, p)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. p =p (m, c) # q",
            "unfolding eq_poly_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\np =p (m, c) # q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "case (Some res)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "obtain p1 mc p2 where \"res = (p1,mc,p2)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mc p2. res = (p1, mc, p2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "with extract_SomeE[OF Some[simplified this]]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np = p1 @ mc # p2 \\<and> (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and> \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\nres = (p1, mc, p2)",
            "obtain a where p: \"p = p1 @ (m,a) # p2\" and res: \"res = (p1,(m,a),p2)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np = p1 @ mc # p2 \\<and> (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and> \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\nres = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>p = p1 @ (m, a) # p2; res = (p1, (m, a), p2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\np = p1 @ (m, a) # p2\nres = (p1, (m, a), p2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "from Some res assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\npoly_split m p = (c, q)",
            "have c: \"c = a\" and q: \"q = p1 @ p2\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\npoly_split m p = (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2",
            "unfolding poly_split_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\n(case List.extract (\\<lambda>(n, uu_). m = n) p of None \\<Rightarrow> (0::'a, p) | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) = (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc = a\nq = p1 @ p2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q",
            "unfolding eq_poly_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)",
            "by (simp add: p c q field_simps)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\np =p (m, c) # q\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma poly_split_eval: assumes \"poly_split m p = (c,q)\" \n  shows \"eval_poly \\<alpha> p = (eval_monom \\<alpha> m * c) + eval_poly \\<alpha> q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q",
            "using poly_split[OF assms]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np =p (m, c) # q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "fun check_poly_eq :: \"('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_eq [] q = (q = [])\"\n| \"check_poly_eq ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n       None \\<Rightarrow> False\n     | Some (q1,(_,d),q2) \\<Rightarrow> c = d \\<and> check_poly_eq p (q1 @ q2))\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_eq: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes chk: \"check_poly_eq p q\"\n  shows \"p =p q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p =p q",
            "unfolding eq_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q",
            "proof",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q",
            "fix \\<alpha>",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q",
            "from chk",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_eq p q",
            "show \"eval_poly \\<alpha> p = eval_poly \\<alpha> q\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_eq p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> q",
            "proof (induct p arbitrary: q)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_eq [] q \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_eq [] q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_eq [] q \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_eq [] q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<alpha> q",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> [] = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "case (Cons mc p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_eq p ?q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> ?q\ncheck_poly_eq (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "obtain m c where mc: \"mc = (m,c)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "case None",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "with Cons(2)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "unfolding mc",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_eq ((m, c) # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((m, c) # p) = eval_poly \\<alpha> q",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "case (Some res)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "obtain q1 md q2 where \"res = (q1,md,q2)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "with extract_SomeE[OF Some[simplified this]]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)",
            "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "from Cons(2) Some mc res",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)",
            "have rec: \"check_poly_eq p (q1 @ q2)\" and c: \"c = d\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_eq p (q1 @ q2) &&& c = d",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_eq p (q1 @ q2)\nc = d\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "from Cons(1)[OF rec]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)",
            "have p: \"eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q",
            "unfolding mc eval_poly.simps c p q",
            7,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (m, d) + eval_poly \\<alpha> (q1 @ q2) = eval_poly \\<alpha> (q1 @ (m, d) # q2)",
            "by (simp add: ac_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "declare check_poly_eq.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "fun check_poly_ge :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_ge [] q = list_all (\\<lambda> (_,d). 0 \\<ge> d) q\"\n| \"check_poly_ge ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n     None \\<Rightarrow> c \\<ge> 0 \\<and> check_poly_ge p q\n   | Some (q1,(_,d),q2) \\<Rightarrow> c \\<ge> d \\<and> check_poly_ge p (q1 @ q2))\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_ge: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_ge p q \\<Longrightarrow> p \\<ge>p q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q",
            "proof (induct p arbitrary: q)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "case Nil",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_ge [] q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "hence \"\\<forall> (n,d) \\<in> set q. 0 \\<ge> d\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_ge [] q\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)",
            "using list_all_iff[of _ q]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_ge [] q\nlist_all ?P q = Ball (set q) ?P\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "hence \"[] \\<ge>p q\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q",
            "proof (induct q)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p []\n 2. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p []\n 2. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p []",
            "by (simp)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p []\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "case (Cons nd q)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "hence rec: \"[] \\<ge>p q\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q",
            "proof (cases nd)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q",
            "case (Pair n d)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nnd = (n, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q",
            "with Cons",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\nnd = (n, d)",
            "have ge: \"0 \\<ge> d\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\nnd = (n, d)\n\ngoal (1 subgoal):\n 1. d \\<le> (0::'a)",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nd \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q",
            "proof (simp only: Pair, unfold poly_ge_def, intro allI impI)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "fix \\<alpha> :: \"('v,'a)assign\"",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "assume pos: \"pos_assign \\<alpha>\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "have ge: \"0 \\<ge> eval_monom \\<alpha> n * d\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)",
            "using times_right_mono[OF pos_assign_monom[OF pos, of n] ge]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> n * d \\<le> eval_monom \\<alpha> n * (0::'a)\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> n * d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "from rec[unfolded poly_ge_def] pos",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\npos_assign \\<alpha>",
            "have ge2: \"0 \\<ge> eval_poly \\<alpha> q\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> (0::'a)",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> q \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "show \"eval_poly \\<alpha> [] \\<ge> eval_poly \\<alpha> ((n,d) # q)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> n * d + eval_poly \\<alpha> q \\<le> (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p nd # q\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p nd # q\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "case (Cons mc p)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_ge p ?q \\<Longrightarrow> p \\<ge>p ?q\ncheck_poly_ge (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "obtain m c where mc: \"mc = (m,c)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q",
            "show ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q",
            "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "case None",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "with Cons(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None",
            "have rec: \"check_poly_ge p q\" and c: \"c \\<ge> 0\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c",
            "using mc",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_ge p q\n(0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "from Cons(1)[OF rec]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np \\<ge>p q",
            "have rec: \"p \\<ge>p q\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p q\n\ngoal (1 subgoal):\n 1. p \\<ge>p q",
            ".",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\np \\<ge>p q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q",
            "proof (simp only: mc, unfold poly_ge_def, intro allI impI)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "fix \\<alpha> :: \"('v,'a)assign\"",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "assume pos: \"pos_assign \\<alpha>\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "have ge: \"eval_monom \\<alpha> m * c \\<ge> 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c",
            "using times_right_mono[OF pos_assign_monom[OF pos, of m] c]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> m * (0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "from rec",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np \\<ge>p q",
            "have pq: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p",
            "unfolding poly_ge_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p",
            "using pos",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF pq]]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) + eval_poly \\<alpha> q \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "case (Some res)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "obtain q1 md q2 where \"res = (q1,md,q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases res, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "with extract_SomeE[OF Some[simplified this]]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)",
            "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases md, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "from Cons(2) Some mc res",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)",
            "have rec: \"check_poly_ge p (q1 @ q2)\" and c: \"c \\<ge> d\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_ge p (q1 @ q2) &&& d \\<le> c",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_ge p (q1 @ q2)\nd \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "from Cons(1)[OF rec]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np \\<ge>p q1 @ q2",
            "have p: \"p \\<ge>p q1 @ q2\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. p \\<ge>p q1 @ q2",
            ".",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q",
            "proof (simp only: mc, unfold poly_ge_def, intro allI impI)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "fix \\<alpha> :: \"('v,'a)assign\"",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "assume pos: \"pos_assign \\<alpha>\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "have ge: \"eval_monom \\<alpha> m * c \\<ge> eval_monom \\<alpha> m * d\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c",
            "using times_right_mono[OF pos_assign_monom[OF pos, of m] c]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "from p",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np \\<ge>p q1 @ q2",
            "have ge2: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> (q1 @ q2)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p",
            "unfolding poly_ge_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p",
            "using pos",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom \\<alpha> m * d + eval_poly \\<alpha> (q1 @ q2) \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)",
            "by (simp add: q field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "declare check_poly_ge.simps[simp del]",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_mono_all :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> bool\"\nwhere \"check_poly_weak_mono_all p \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0) p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono_all p\" shows  \"poly_weak_mono_all p\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p",
            "unfolding poly_weak_mono_all_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume fg: \"\\<forall> x. f x \\<ge> g x\"\n  and pos: \"pos_assign g\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x. g x \\<le> f x\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "hence fg: \"\\<And> x. f x \\<ge> g x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. g x \\<le> f x\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from pos[unfolded pos_assign_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x",
            "have g: \"\\<And> x. g x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono_all p",
            "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c",
            "unfolding check_poly_weak_mono_all_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'a) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c",
            "by (auto simp: list_all_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "thus \"eval_poly f p \\<ge> eval_poly g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "proof (induct p)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g [] \\<le> eval_poly f []",
            "by (simp add: ge_refl)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g [] \\<le> eval_poly f []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "case (Cons mc p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "hence IH: \"eval_poly f p \\<ge> eval_poly g p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "proof (cases mc)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "case (Pair m c)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "with Cons",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\nmc = (m, c)",
            "have c: \"c \\<ge> 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "unfolding Pair eval_poly.simps fst_conv snd_conv",
            7,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p \\<le> eval_monom f m * c + eval_poly f p",
            "proof (rule ge_trans[OF plus_left_mono[OF times_left_mono[OF c]] plus_right_mono[OF IH]])",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m",
            "show \"eval_monom f m \\<ge> eval_monom g m\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m",
            "by (rule eval_monom_mono(1)[OF fg g])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom g m \\<le> eval_monom f m\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_mono_all_pos: \n  assumes \"check_poly_weak_mono_all p\" shows  \"p \\<ge>p zero_poly\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly",
            "unfolding zero_poly_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p []",
            "proof (rule check_poly_ge)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. check_poly_ge p []",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono_all p",
            "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c",
            "unfolding check_poly_weak_mono_all_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'b) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c",
            "by (auto simp: list_all_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []",
            "thus \"check_poly_ge p []\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []",
            "by (induct p, simp add: check_poly_ge.simps,  clarify, auto simp: check_poly_ge.simps extract_Nil_code)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_ge p []\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_discrete p v \\<equiv> check_poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\"",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_mono_and_pos :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_and_pos discrete p \\<equiv> \n            if discrete then list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p) \\<and> eval_poly (\\<lambda> w. 0) p \\<ge>  0\n                        else check_poly_weak_mono_all p\"",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_anti_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_discrete p v \\<equiv> check_poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\"",
            0,
            "NA"
        ],
        [
            "",
            "context poly_order_carrier\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_mono_discrete p v\"\n  shows \"poly_weak_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v",
            "unfolding poly_weak_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from fgw",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w",
            "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from assms check_poly_ge",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndiscrete\ncheck_poly_weak_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q",
            "have ge: \"poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_ge ?p1 p\")",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_weak_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p",
            "unfolding check_poly_weak_mono_discrete_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_ge (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) p\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from discrete[OF \\<open>discrete\\<close> v]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)",
            "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "show \"eval_poly f p \\<ge> eval_poly g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "proof (cases k')",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "case 0",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "fix x",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have \"f x = g x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f x = g x",
            "using id 0 w",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x",
            "by (cases \"x = v\", auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "hence \"f = g\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = g\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "using ge_refl",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = g\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "case (Suc k)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "with id",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k",
            "have \"f v = (((+) 1)^^(Suc k))  (g v)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "with w gass",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)",
            "show \"eval_poly f p \\<ge> eval_poly g p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "proof (induct k arbitrary: f g rule: less_induct)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "case (less k)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "proof (cases k)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "case 0",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "with less",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0",
            "have id0: \"f v = 1 + g v\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have id1: \"eval_poly f p = eval_poly g ?p1\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "proof (rule eval_poly_subst)",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "proof (cases \"w = v\")",
            11,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case True",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: True id0 zero_poly_def)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "next",
            12,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case False",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "with less",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v",
            "have \"f w = g w\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w",
            "by simp",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "thus ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: False)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have \"eval_poly g ?p1 \\<ge> eval_poly g p\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "using ge less",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "unfolding poly_ge_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "with id1",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "case (Suc kk)",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have \"(1 :: 'a) + g v \\<ge> 1 + 0\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v",
            "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "also",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have \"1 + (0 :: 'a) = 1\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "also",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have \"\\<dots> \\<ge> 0\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)",
            "by (rule one_ge_zero)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "finally",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v",
            "have g'pos: \"pos_assign g'\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "using less(3)",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "unfolding pos_assign_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x",
            "by (simp add: g')",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "{",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "assume \"v \\<noteq> w\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "hence \"f w = g' w\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w",
            "unfolding g'",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)",
            "by (simp add: less)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "}",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "note w = this",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "from Suc",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have kk: \"kk < k\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "from less(1)[OF kk w g'pos] eq",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "have rec1: \"eval_poly f p \\<ge> eval_poly g' p\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly f p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "{",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "assume \"v \\<noteq> w\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "hence \"g' w = g w\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w",
            "unfolding g'",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "}",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "note w = this",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "from Suc",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have z: \"0 < k\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "from less(1)[OF z w less(3)] g'",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)",
            "have rec2: \"eval_poly g' p \\<ge> eval_poly g p\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g' p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "by (rule ge_trans[OF rec1 rec2])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_anti_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_anti_mono_discrete p v\"\n  shows \"poly_weak_anti_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v",
            "unfolding poly_weak_anti_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "from fgw",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w",
            "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "from assms check_poly_ge",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndiscrete\ncheck_poly_weak_anti_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q",
            "have ge: \"poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\" (is \"poly_ge p ?p1\")",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_weak_anti_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p",
            "unfolding check_poly_weak_anti_mono_discrete_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_ge p (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\np \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "from discrete[OF \\<open>discrete\\<close> v]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)",
            "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "show \"eval_poly g p \\<ge> eval_poly f p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "proof (cases k')",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "case 0",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "fix x",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have \"f x = g x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f x = g x",
            "using id 0 w",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x",
            "by (cases \"x = v\", auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "hence \"f = g\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g",
            "..",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = g\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "using ge_refl",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = g\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "case (Suc k)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "with id",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k",
            "have \"f v = (((+) 1)^^(Suc k))  (g v)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "with w gass",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)",
            "show \"eval_poly g p \\<ge> eval_poly f p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "proof (induct k arbitrary: f g rule: less_induct)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "case (less k)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "show ?case",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "proof (cases k)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "case 0",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "with less",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0",
            "have id0: \"f v = 1 + g v\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have id1: \"eval_poly f p = eval_poly g ?p1\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "proof (rule eval_poly_subst)",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "proof (cases \"w = v\")",
            11,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case True",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: True id0 zero_poly_def)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "next",
            12,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case False",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "with less",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v",
            "have \"f w = g w\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w",
            "by simp",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "thus ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: False)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have \"eval_poly g p \\<ge> eval_poly g ?p1\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p",
            "using ge less",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p",
            "unfolding poly_ge_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly \\<alpha> p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "with id1",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "case (Suc kk)",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have \"(1 :: 'a) + g v \\<ge> 1 + 0\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v",
            "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "also",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have \"(1 :: 'a) + 0 = 1\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "also",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have \"\\<dots> \\<ge> 0\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)",
            "by (rule one_ge_zero)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "finally",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v",
            "have g'pos: \"pos_assign g'\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "using less(3)",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "unfolding pos_assign_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x",
            "by (simp add: g')",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "{",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "assume \"v \\<noteq> w\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "hence \"f w = g' w\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w",
            "unfolding g'",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)",
            "by (simp add: less)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "}",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "note w = this",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "from Suc",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have kk: \"kk < k\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "from less(1)[OF kk w g'pos] eq",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "have rec1: \"eval_poly g' p \\<ge> eval_poly f p\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g' p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "{",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "fix w",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "assume \"v \\<noteq> w\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "hence \"g' w = g w\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w",
            "unfolding g'",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "}",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "note w = this",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "from Suc",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have z: \"0 < k\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "from less(1)[OF z w less(3)] g'",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)",
            "have rec2: \"eval_poly g p \\<ge> eval_poly g' p\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly g p",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g' p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "by (rule ge_trans[OF rec2 rec1])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_mono_and_pos: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_weak_mono_all p \\<and> (p \\<ge>p zero_poly)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "proof (cases discrete)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> discrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "with assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono_and_pos discrete p\n\\<not> discrete",
            "have c: \"check_poly_weak_mono_all p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono_and_pos discrete p\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p",
            "unfolding check_poly_weak_mono_and_pos_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nif discrete then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and> (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p else check_poly_weak_mono_all p\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "from check_poly_weak_mono_all[OF c] check_poly_weak_mono_all_pos[OF c]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_weak_mono_all p\np \\<ge>p zero_poly",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_weak_mono_all p\np \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndiscrete\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "with assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono_and_pos discrete p\ndiscrete",
            "have c: \"list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p)\" and g: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono_and_pos discrete p\ndiscrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&& (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p",
            "unfolding check_poly_weak_mono_and_pos_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nif discrete then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and> (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p else check_poly_weak_mono_all p\ndiscrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&& (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlist_all (check_poly_weak_mono_discrete p) (poly_vars_list p)\n(0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "have m: \"poly_weak_mono_all p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p",
            "proof (rule poly_weak_mono)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "fix v :: 'v",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "assume v: \"v \\<in> poly_vars p\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "show \"poly_weak_mono p v\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v",
            "by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono p v\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "have m': \"poly_weak_mono_all  p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p",
            "proof (rule poly_weak_mono)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "fix v :: 'v",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "assume v: \"v \\<in> poly_vars p\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v",
            "show \"poly_weak_mono p v\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v",
            "by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono p v\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "from poly_weak_mono_all_pos[OF g m'] m",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np \\<ge>p zero_poly\npoly_weak_mono_all p",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np \\<ge>p zero_poly\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono p v \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0 \\<or> v \\<notin> monom_vars m) p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono p v\" shows  \"poly_weak_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v",
            "unfolding poly_weak_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from pos[unfolded pos_assign_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x",
            "have g: \"\\<And> x. g x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono p v",
            "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0 \\<or> v \\<notin> monom_vars m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m",
            "unfolding check_poly_weak_mono_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m",
            "by (auto simp: list_all_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p",
            "thus \"eval_poly f p \\<ge> eval_poly g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "proof (induct p)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "case (Cons mc p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "hence IH: \"eval_poly f p \\<ge> eval_poly g p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "obtain m c where mc: \"mc = (m,c)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "with Cons",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)",
            "have c: \"c \\<ge> 0 \\<or> v \\<notin> monom_vars m\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)",
            "unfolding mc eval_poly.simps fst_conv snd_conv",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p \\<le> eval_monom f m * c + eval_poly f p",
            "proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c",
            "from c",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m",
            "show \"eval_monom f m * c \\<ge> eval_monom g m * c\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c",
            "proof",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "assume c: \"c \\<ge> 0\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c",
            "proof (rule times_left_mono[OF c], rule eval_monom_mono(1)[OF _ g])",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x",
            "fix x",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x",
            "show \"f x \\<ge> g x\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x",
            "using ge fg[of x]",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng v \\<le> f v\nv \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x",
            "by (cases \"x = v\", auto simp: ge_refl)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng x \\<le> f x\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "assume v: \"v \\<notin> monom_vars m\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "have \"eval_monom f m = eval_monom g m\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m",
            "by (rule monom_vars_eval_monom, insert fg v, fast)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c",
            "thus ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c",
            "by (simp add: ge_refl)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []",
            "qed (simp add: ge_refl)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_smart discrete \\<equiv> if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma (in poly_order_carrier) check_poly_weak_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v",
            "unfolding check_poly_weak_mono_smart_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono) p v \\<Longrightarrow> poly_weak_mono p v",
            "using check_poly_weak_mono check_poly_weak_mono_discrete",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono ?p ?v \\<Longrightarrow> poly_weak_mono ?p ?v\n\\<lbrakk>discrete; check_poly_weak_mono_discrete ?p ?v\\<rbrakk> \\<Longrightarrow> poly_weak_mono ?p ?v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono) p v \\<Longrightarrow> poly_weak_mono p v",
            "by (cases discrete, auto)",
            1,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_anti_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono p v \\<equiv> list_all (\\<lambda> (m,c). 0 \\<ge> c \\<or> v \\<notin> monom_vars m) p\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_poly_weak_anti_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_anti_mono p v\" shows  \"poly_weak_anti_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v",
            "unfolding poly_weak_anti_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "from pos[unfolded pos_assign_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x",
            "have g: \"\\<And> x. g x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_anti_mono p v",
            "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> 0 \\<ge> c \\<or> v \\<notin> monom_vars m\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m",
            "unfolding check_poly_weak_anti_mono_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m",
            "by (auto simp: list_all_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p",
            "thus \"eval_poly g p \\<ge> eval_poly f p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "proof (induct p)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<le> eval_poly g []",
            "by (simp add: ge_refl)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f [] \\<le> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "case (Cons mc p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "hence IH: \"eval_poly g p \\<ge> eval_poly f p\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "obtain m c where mc: \"mc = (m,c)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "with Cons",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)",
            "have c: \"0 \\<ge> c \\<or> v \\<notin> monom_vars m\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<le> eval_poly g (mc # p)",
            "unfolding mc eval_poly.simps fst_conv snd_conv",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c + eval_poly f p \\<le> eval_monom g m * c + eval_poly g p",
            "proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c",
            "from c",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m",
            "show \"eval_monom g m * c \\<ge> eval_monom f m * c\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c",
            "proof",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "assume c: \"0 \\<ge> c\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nc \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c",
            "proof (rule times_left_anti_mono[OF eval_monom_mono(1)[OF _ g] c])",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x",
            "fix x",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x",
            "show \"f x \\<ge> g x\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x",
            "using ge fg[of x]",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng v \\<le> f v\nv \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x",
            "by (cases \"x = v\", auto simp: ge_refl)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng x \\<le> f x\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "assume v: \"v \\<notin> monom_vars m\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "have \"eval_monom f m = eval_monom g m\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m",
            "by (rule monom_vars_eval_monom, insert fg v, fast)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c",
            "thus ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c",
            "by (simp add: ge_refl)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f (mc # p) \\<le> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition check_poly_weak_anti_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_smart discrete \\<equiv> if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma (in poly_order_carrier) check_poly_weak_anti_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v",
            "unfolding check_poly_weak_anti_mono_smart_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono) p v \\<Longrightarrow> poly_weak_anti_mono p v",
            "using check_poly_weak_anti_mono[of p v] check_poly_weak_anti_mono_discrete[of p v]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_anti_mono p v \\<Longrightarrow> poly_weak_anti_mono p v\n\\<lbrakk>discrete; check_poly_weak_anti_mono_discrete p v\\<rbrakk> \\<Longrightarrow> poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono) p v \\<Longrightarrow> poly_weak_anti_mono p v",
            "by (cases discrete, auto)",
            1,
            "NA"
        ],
        [
            "",
            "definition check_poly_gt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\"\nwhere \"check_poly_gt gt p q \\<equiv> let (a1,p1) = poly_split 1 p; (b1,q1) = poly_split 1 q in gt a1 b1 \\<and> check_poly_ge p1 q1\"",
            0,
            "NA"
        ],
        [
            "",
            "fun univariate_power_list :: \"'v \\<Rightarrow> 'v monom_list \\<Rightarrow> nat option\" where\n  \"univariate_power_list x [(y,n)] = (if x = y then Some n else None)\" \n| \"univariate_power_list _ _ = None\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma univariate_power_list: assumes \"monom_inv m\" \"univariate_power_list x m = Some n\" \n  shows \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \n   \"n \\<ge> 1\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n",
            "have m: \"m = [(x,n)]\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. m = [(x, n)]",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv m\nunivariate_power_list x m = Some n\n\ngoal (1 subgoal):\n 1. m = [(x, n)]",
            "by (induct x m rule: univariate_power_list.induct, auto split: if_splits)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm = [(x, n)]\n\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n",
            "show \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\"\n    \"n \\<ge> 1\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n",
            "using assms(1)",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmonom_inv m\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n",
            "unfolding m monom_inv_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set [(x, n)]. 1 \\<le> n) \\<and> distinct (map fst [(x, n)]) \\<and> sorted (map fst [(x, n)])\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> [(x, n)] = \\<alpha> x ^ n &&& sum_var_list [(x, n)] = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n",
            "by (auto simp: sum_var_list_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom_list \\<alpha> m = \\<alpha> x ^ n\nsum_var_list m = (\\<lambda>y. if x = y then n else 0)\n1 \\<le> n\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lift_definition univariate_power :: \"'v :: linorder \\<Rightarrow> 'v monom \\<Rightarrow> nat option\" \n  is univariate_power_list",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            ".",
            1,
            "NA"
        ],
        [
            "",
            "lemma univariate_power: assumes \"univariate_power x m = Some n\" \n  shows \"sum_var m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom \\<alpha> m = ((\\<alpha> x)^n)\"\n   \"n \\<ge> 1\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. sum_var m = (\\<lambda>y. if x = y then n else 0) &&& eval_monom \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n",
            "by (atomize(full), insert assms, transfer, auto dest: univariate_power_list)",
            1,
            "NA"
        ],
        [
            "",
            "lemma univariate_power_var_monom: \"univariate_power y (var_monom x) = (if x = y then Some 1 else None)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. univariate_power y (var_monom x) = (if x = y then Some 1 else None)",
            "by (transfer, auto)",
            1,
            "NA"
        ],
        [
            "",
            "definition check_monom_strict_mono :: \"bool \\<Rightarrow> 'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> bool\" where\n  \"check_monom_strict_mono pm m v \\<equiv> case univariate_power v m of\n     Some p \\<Rightarrow> pm \\<or> p = 1\n   | None \\<Rightarrow> False\"",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_strict_mono :: \"bool \\<Rightarrow> ('v :: linorder, 'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono pm p v \\<equiv> list_ex (\\<lambda> (m,c). (c \\<ge> 1) \\<and> check_monom_strict_mono pm m v) p\"",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_strict_mono_discrete :: \"('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_discrete gt p v \\<equiv> check_poly_gt gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p \"",
            0,
            "NA"
        ],
        [
            "",
            "definition check_poly_strict_mono_smart :: \"bool \\<Rightarrow> bool \\<Rightarrow> ('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_smart discrete pm gt p v \\<equiv> \n            if discrete then check_poly_strict_mono_discrete gt p v else check_poly_strict_mono pm p v\"",
            0,
            "NA"
        ],
        [
            "",
            "context poly_order_carrier\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lemma check_monom_strict_mono: fixes \\<alpha> \\<beta> :: \"('v :: linorder,'a)assign\" and v :: 'v and m :: \"'v monom\"\n  assumes check: \"check_monom_strict_mono power_mono m v\"\n  and gt: \"\\<alpha> v \\<succ> \\<beta> v\"\n  and ge: \"\\<beta> v \\<ge> 0\"\nshows \"eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "from check[unfolded check_monom_strict_mono_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncase univariate_power v m of None \\<Rightarrow> False | Some p \\<Rightarrow> power_mono \\<or> p = 1",
            "obtain n where\n    uni: \"univariate_power v m = Some n\" and 1: \"\\<not> power_mono \\<Longrightarrow> n = 1\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncase univariate_power v m of None \\<Rightarrow> False | Some p \\<Rightarrow> power_mono \\<or> p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>n. \\<lbrakk>univariate_power v m = Some n; \\<not> power_mono \\<Longrightarrow> n = 1\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (auto split: option.splits)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nunivariate_power v m = Some n\n\\<not> power_mono \\<Longrightarrow> n = 1\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "from univariate_power[OF uni]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsum_var m = (\\<lambda>y. if v = y then n else 0)\neval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n1 \\<le> n",
            "have n1: \"n \\<ge> 1\" and eval: \"eval_monom a m = a v ^ n\" for a :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsum_var m = (\\<lambda>y. if v = y then n else 0)\neval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n1 \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n &&& eval_monom a m = a v ^ n",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n1 \\<le> n\neval_monom ?a3 m = ?a3 v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "proof (cases power_mono)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> power_mono\n\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "with gt 1[OF this]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "unfolding eval",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npower_mono\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "from power_mono[OF True gt ge n1]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m",
            "unfolding eval",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n",
            ".",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_strict_mono: \n  assumes check1: \"check_poly_strict_mono power_mono p v\"\n  and check2: \"check_poly_weak_mono_all p\"\n  shows \"poly_strict_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v",
            "unfolding poly_strict_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "fix f g :: \"('b,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and pos: \"pos_assign g\"\n  and fgv: \"f v \\<succ> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\nf v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from pos[unfolded pos_assign_def]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x",
            "have g: \"\\<And> x. g x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "fix w",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "have \"f w \\<ge> g w\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g w \\<le> f w",
            "proof (cases \"v = w\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w",
            "with fgw ge_refl",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n?x \\<le> ?x\nv \\<noteq> w",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n?x \\<le> ?x\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng w \\<le> f w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv = w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w",
            "from fgv[unfolded True]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf w \\<succ> g w",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf w \\<succ> g w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w",
            "by (rule gt_imp_ge)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng w \\<le> f w\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng w \\<le> f w\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "note fgw2 = this",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "let ?e = \"eval_poly\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "show \"?e f p \\<succ> ?e g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "using check1[unfolded check_poly_strict_mono_def, simplified list_ex_iff]\n      check2[unfolded check_poly_weak_mono_all_def, simplified list_all_iff, THEN bspec]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x \\<in> set p \\<Longrightarrow> case ?x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "proof (induct p)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set []. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set [] \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "case Nil",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>set []. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set [] \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set []. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set [] \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "thus ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>a\\<in>set []. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set [] \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<succ> eval_poly g []",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f [] \\<succ> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "case (Cons mc p)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>\\<exists>a\\<in>set p. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "obtain m c where mc: \"mc = (m,c)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases mc, auto)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "proof (cases \"c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "hence c: \"c \\<ge> 1\" and m: \"check_monom_strict_mono power_mono m v\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> c &&& check_monom_strict_mono power_mono m v",
            "by blast+",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) \\<le> c\ncheck_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from times_gt_mono[OF check_monom_strict_mono[OF m, of f g, OF fgv g] c]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_monom f m * c \\<succ> eval_monom g m * c",
            "have gt: \"eval_monom f m * c \\<succ> eval_monom g m * c\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<succ> eval_monom g m * c",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from Cons(3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a",
            "have \"check_poly_weak_mono_all p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p",
            "unfolding check_poly_weak_mono_all_def list_all_iff",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>(m, y)\\<in>set p. (0::'a) \\<le> y",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncheck_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from check_poly_weak_mono_all[OF this, unfolded poly_weak_mono_all_def, rule_format, OF fgw2 pos]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly g p \\<le> eval_poly f p",
            "have ge: \"?e f p \\<ge> ?e g p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from compat2[OF plus_gt_left_mono[OF gt] plus_right_mono[OF ge]]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "unfolding mc",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f ((m, c) # p) \\<succ> eval_poly g ((m, c) # p)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "with Cons(2) mc",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\nmc = (m, c)\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)",
            "have \"\\<exists> mc \\<in> set p. (\\<lambda> (m,c). c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v) mc\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\nmc = (m, c)\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<exists>mc\\<in>set p. case mc of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>mc\\<in>set p. case mc of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from Cons(1)[OF this] Cons(3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a",
            "have rec: \"?e f p \\<succ> ?e g p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from Cons(3) mc",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\nmc = (m, c)",
            "have c: \"c \\<ge> 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from times_left_mono[OF c eval_monom_mono(1)[OF fgw2 g]]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c",
            "have ge: \"eval_monom f m * c \\<ge> eval_monom g m * c\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c",
            ".",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "from compat2[OF plus_gt_left_mono[OF rec] plus_right_mono[OF ge]]",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly f p + eval_monom f m * c \\<succ> eval_poly g p + eval_monom g m * c",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly f p + eval_monom f m * c \\<succ> eval_poly g p + eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)",
            "by (simp add: mc field_simps)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_gt: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_gt gt p q\" shows \"p >p q\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p >p q",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. p >p q",
            "obtain a1 p1 where p: \"poly_split 1 p = (a1,p1)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 p1. poly_split 1 p = (a1, p1) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_split 1 p = (a1, p1)\n\ngoal (1 subgoal):\n 1. p >p q",
            "obtain b1 q1 where q: \"poly_split 1 q = (b1,q1)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b1 q1. poly_split 1 q = (b1, q1) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_split 1 q = (b1, q1)\n\ngoal (1 subgoal):\n 1. p >p q",
            "from p q assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\ncheck_poly_gt (\\<succ>) p q",
            "have gt: \"a1 \\<succ> b1\" and ge: \"p1 \\<ge>p q1\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\ncheck_poly_gt (\\<succ>) p q\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1",
            "unfolding check_poly_gt_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\nlet (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1",
            "using check_poly_ge[of p1 q1]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\nlet (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\ncheck_poly_ge p1 q1 \\<Longrightarrow> p1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\na1 \\<succ> b1\np1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. p >p q",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. p >p q",
            "proof (unfold poly_gt_def, intro impI allI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "fix \\<alpha> :: \"('v,'a)assign\"",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "assume \"pos_assign \\<alpha>\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "with ge",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\np1 \\<ge>p q1\npos_assign \\<alpha>",
            "have ge: \"eval_poly \\<alpha> p1 \\<ge> eval_poly \\<alpha> q1\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\np1 \\<ge>p q1\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1",
            "unfolding poly_ge_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "from plus_gt_left_mono[OF gt] compat[OF plus_left_mono[OF ge]]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\na1 + ?z \\<succ> b1 + ?z\neval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow> eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z",
            "have gt: \"a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na1 + ?z \\<succ> b1 + ?z\neval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow> eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z\n\ngoal (1 subgoal):\n 1. a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1",
            "by (force simp: field_simps)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "show \"eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q",
            "by (simp add: poly_split[OF p, unfolded eq_poly_def] poly_split[OF q, unfolded eq_poly_def] gt)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\np >p q\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_strict_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_strict_mono_discrete gt p v\"\n  shows \"poly_strict_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v",
            "unfolding poly_strict_mono_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "proof (intro allI impI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "fix f g :: \"('v,'a)assign\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<succ> g v\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\nf v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from gass",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\npos_assign g",
            "have g: \"\\<And> x. g x \\<ge> 0\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "unfolding pos_assign_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x",
            "..",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from fgw",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w",
            "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from assms check_poly_gt",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ndiscrete\ncheck_poly_strict_mono_discrete (\\<succ>) p v\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q",
            "have gt: \"poly_gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_gt ?p1 p\")",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_strict_mono_discrete (\\<succ>) p v\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p",
            "unfolding check_poly_strict_mono_discrete_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ndiscrete\ncheck_poly_gt (\\<succ>) (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) p\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from discrete[OF \\<open>discrete\\<close> gt_imp_ge[OF v]]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)",
            "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "assume \"k' = 0\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "from v[unfolded id this]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n((+) (1::'a) ^^ 0) (g v) \\<succ> g v",
            "have \"g v \\<succ> g v\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n((+) (1::'a) ^^ 0) (g v) \\<succ> g v\n\ngoal (1 subgoal):\n 1. g v \\<succ> g v",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "hence False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng v \\<succ> g v\n\ngoal (1 subgoal):\n 1. False",
            "using SN g[of v]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng v \\<succ> g v\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n(0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False",
            "unfolding SN_defs",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng v \\<succ> g v\n\\<nexists>f. f 0 \\<in> UNIV \\<and> (\\<forall>i. (f i, f (Suc i)) \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n(0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "with id",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0 \\<Longrightarrow> False",
            "obtain k where id: \"f v = (((+) 1)^^(Suc k)) (g v)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>k. f v = ((+) (1::'a) ^^ Suc k) (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (cases k', auto)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p",
            "with w gass",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)",
            "show \"eval_poly f p \\<succ> eval_poly g p\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "proof (induct k arbitrary: f g rule: less_induct)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "case (less k)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "show ?case",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "proof (cases k)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "case 0",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "with less(4)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0",
            "have id0: \"f v = 1 + g v\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have id1: \"eval_poly f p = eval_poly g ?p1\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)",
            "proof (rule eval_poly_subst)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "fix w",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "proof (cases \"w = v\")",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case True",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "show ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: True id0 zero_poly_def)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "next",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "case False",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "with less",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v",
            "have \"f w = g w\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w",
            "by simp",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "thus ?thesis",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))",
            "by (simp add: False)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have \"eval_poly g ?p1 \\<succ> eval_poly g p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p",
            "using gt less",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p",
            "unfolding poly_gt_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly \\<alpha> p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "with id1",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "case (Suc kk)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have \"(1 :: 'a) + g v \\<ge> 1 + 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v",
            "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have \"(1 :: 'a) + 0 = 1\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "also",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have \"\\<dots> \\<ge> 0\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)",
            "by (rule one_ge_zero)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "finally",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v",
            "have g'pos: \"pos_assign g'\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "using less(3)",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'",
            "unfolding pos_assign_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x",
            "by (simp add: g')",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "fix w",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "assume \"v \\<noteq> w\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "hence \"f w = g' w\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w",
            "unfolding g'",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)",
            "by (simp add: less)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "note w = this",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "from Suc",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have kk: \"kk < k\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "from less(1)[OF kk w g'pos] eq",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)",
            "have rec1: \"eval_poly f p \\<succ> eval_poly g' p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g' p",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "fix w",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "assume \"v \\<noteq> w\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "hence \"g' w = g w\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w",
            "unfolding g'",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "note w = this",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "from Suc",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nk = Suc kk",
            "have z: \"0 < k\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "from less(1)[OF z w less(3)] g'",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)",
            "have rec2: \"eval_poly g' p \\<succ> eval_poly g p\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<succ> eval_poly g p",
            "by simp",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly g' p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p",
            "by (rule gt_trans[OF rec1 rec2])",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma check_poly_strict_mono_smart: \n  assumes check1: \"check_poly_strict_mono_smart discrete power_mono gt p v\"\n  and check2: \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_strict_mono p v\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v",
            "proof (cases discrete)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ndiscrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v",
            "with check1[unfolded check_poly_strict_mono_smart_def]\n    check_poly_strict_mono_discrete[OF True]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nif discrete then check_poly_strict_mono_discrete (\\<succ>) p v else check_poly_strict_mono power_mono p v\ncheck_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow> poly_strict_mono ?p ?v\ndiscrete",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nif discrete then check_poly_strict_mono_discrete (\\<succ>) p v else check_poly_strict_mono power_mono p v\ncheck_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow> poly_strict_mono ?p ?v\ndiscrete\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_strict_mono p v\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v",
            "from check_poly_strict_mono[OF check1[unfolded check_poly_strict_mono_smart_def, simplified False, simplified]]\n    check2[unfolded check_poly_weak_mono_and_pos_def, simplified False, simplified]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncheck_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\ncheck_poly_weak_mono_all p",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncheck_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\npoly_strict_mono p v\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ]
    ],
    "whole_thing": "<\\STATESEP>section \\<open>Polynomials\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>theory Polynomials\nimports \n  \"Abstract-Rewriting.SN_Orders\"\n  Matrix.Utility \nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>subsection \\<open>\nPolynomials represented as trees\n\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>datatype (vars_tpoly: 'v, nums_tpoly: 'a)tpoly = PVar 'v | PNum 'a | PSum \"('v,'a)tpoly list\" | PMult \"('v,'a)tpoly list\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>type_synonym ('v,'a)assign = \"'v \\<Rightarrow> 'a\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>primrec eval_tpoly :: \"('v,'a::{monoid_add,monoid_mult})assign \\<Rightarrow> ('v,'a)tpoly \\<Rightarrow> 'a\"\nwhere \"eval_tpoly \\<alpha> (PVar x) = \\<alpha> x\"\n   |  \"eval_tpoly \\<alpha> (PNum a) = a\"\n   |  \"eval_tpoly \\<alpha> (PSum ps) = sum_list (map (eval_tpoly \\<alpha>) ps)\"\n   |  \"eval_tpoly \\<alpha> (PMult ps) = prod_list (map (eval_tpoly \\<alpha>) ps)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>subsection \\<open>Polynomials represented in normal form as lists of monomials\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>type_synonym 'v monom_list = \"('v \\<times> nat)list\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>context linorder\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition monom_inv :: \"'a monom_list \\<Rightarrow> bool\" where \n  \"monom_inv m \\<equiv> (\\<forall> (x,n) \\<in> set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun eval_monom_list :: \"('a,'b :: comm_semiring_1)assign \\<Rightarrow> ('a monom_list) \\<Rightarrow> 'b\" where \n  \"eval_monom_list \\<alpha> [] = 1\"\n| \"eval_monom_list \\<alpha> ((x,p) # m) = eval_monom_list \\<alpha> m * (\\<alpha> x)^p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma eval_monom_list[simp]: \"eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n<\\STATESEP>by (induct m, auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition sum_var_list :: \"'a monom_list \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n  \"sum_var_list m x \\<equiv> sum_list (map (\\<lambda> (y,c). if x = y then c else 0) m)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma sum_var_list_not: \"x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0<\\STATESEP>unfolding sum_var_list_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow> (\\<Sum>(y, c)\\<leftarrow>m. if x = y then c else 0) = 0<\\STATESEP>by (induct m, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_inv_Cons: assumes \"monom_inv ((x,p) # m)\" \n  and \"y \\<le> x\" shows \"y \\<notin> fst ` set m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>define M where \"M = map fst m\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nM = map fst m\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>from assms[unfolded monom_inv_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\ny \\<le> x<\\STATESEP>have \"distinct (x # map fst m)\" \"sorted (x # map fst m)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\ny \\<le> x\n\ngoal (1 subgoal):\n 1. distinct (x # map fst m) &&& sorted (x # map fst m)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ndistinct (x # map fst m)\nsorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>with assms(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ny \\<le> x\ndistinct (x # map fst m)\nsorted (x # map fst m)<\\STATESEP>have \"y \\<notin> set (map fst m)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ny \\<le> x\ndistinct (x # map fst m)\nsorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (map fst m)<\\STATESEP>unfolding M_def[symmetric]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ny \\<le> x\ndistinct (x # M)\nsorted (x # M)\n\ngoal (1 subgoal):\n 1. y \\<notin> set M<\\STATESEP>by (induct M, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ny \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ny \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ny \\<notin> fst ` set m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma eq_monom_sum_var_list: assumes \"monom_inv m\" and \"monom_inv n\"\n  shows \"(m = n) = (\\<forall> x. sum_var_list m x = sum_var_list n x)\" (is \"?l = ?r\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv m\nmonom_inv n\n\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)<\\STATESEP>proof (induct m arbitrary: n)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nmonom_inv []\nmonom_inv n\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>proof (cases n)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>case (Cons yp nn)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nn = yp # nn\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>obtain y p where yp: \"yp = (y,p)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y p. yp = (y, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases yp, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nyp = (y, p)\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>with Cons Nil(2)[unfolded monom_inv_def]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nn = yp # nn\n(\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n)\nyp = (y, p)<\\STATESEP>have p: \"0 < p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nn = yp # nn\n(\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n)\nyp = (y, p)\n\ngoal (1 subgoal):\n 1. 0 < p<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n0 < p\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>by (simp add: Cons, rule exI[of _ y], simp add: sum_var_list_def yp p)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. n = [] \\<Longrightarrow> ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)<\\STATESEP>qed simp<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>case (Cons xp m)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>monom_inv m; monom_inv ?n\\<rbrakk> \\<Longrightarrow> (m = ?n) = (\\<forall>x. sum_var_list m x = sum_var_list ?n x)\nmonom_inv (xp # m)\nmonom_inv n\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>obtain x p where xp: \"xp = (x,p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases xp, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>with Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv (xp # m)\nxp = (x, p)<\\STATESEP>have p: \"0 < p\" and x: \"x \\<notin> fst ` set m\" and m: \"monom_inv m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (xp # m)\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&& x \\<notin> fst ` set m &&& monom_inv m<\\STATESEP>unfolding monom_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set (xp # m). 1 \\<le> n) \\<and> distinct (map fst (xp # m)) \\<and> sorted (map fst (xp # m))\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&& x \\<notin> fst ` set m &&& (\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m)<\\STATESEP>by (auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n0 < p\nx \\<notin> fst ` set m\nmonom_inv m\n\ngoal (1 subgoal):\n 1. \\<And>a m n. \\<lbrakk>\\<And>n. \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x); monom_inv (a # m); monom_inv n\\<rbrakk> \\<Longrightarrow> (a # m = n) = (\\<forall>x. sum_var_list (a # m) x = sum_var_list n x)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>proof (cases n)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nn = []\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nn = []\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>by (auto simp: xp sum_var_list_def p intro!: exI[of _ x])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>case n: (Cons yq n')<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nn = yq # n'\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>from Cons(3)[unfolded n]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv (yq # n')<\\STATESEP>have n': \"monom_inv n'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (yq # n')\n\ngoal (1 subgoal):\n 1. monom_inv n'<\\STATESEP>by (auto simp: monom_inv_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_inv n'\n\ngoal (1 subgoal):\n 1. \\<And>a list. n = a # list \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>proof (cases \"yq = xp\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nyq = xp\n\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>unfolding n True<\\STATESEP>7<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = xp # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)<\\STATESEP>using Cons(1)[OF m n']<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(m = n') = (\\<forall>x. sum_var_list m x = sum_var_list n' x)\n\ngoal (1 subgoal):\n 1. (xp # m = xp # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)<\\STATESEP>by (auto simp: xp sum_var_list_def)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>obtain y q where yq: \"yq = (y,q)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y q. yq = (y, q) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nyq = (y, q)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>from Cons(3)[unfolded n yq monom_inv_def]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))<\\STATESEP>have q: \"q > 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))\n\ngoal (1 subgoal):\n 1. 0 < q<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n0 < q\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>define z where \"z = min x y\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nz = min x y\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>have zm: \"z \\<notin> fst ` set m\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m<\\STATESEP>using Cons(2)<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (xp # m)\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m<\\STATESEP>unfolding xp z_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set m<\\STATESEP>by (rule monom_inv_Cons, simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nz \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>have zn': \"z \\<notin> fst ` set n'\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'<\\STATESEP>using Cons(3)<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv n\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'<\\STATESEP>unfolding n yq z_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv ((y, q) # n')\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set n'<\\STATESEP>by (rule monom_inv_Cons, simp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nz \\<notin> fst ` set n'\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>have smz: \"sum_var_list (xp # m) z = sum_var_list [(x,p)] z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z<\\STATESEP>using sum_var_list_not[OF zm]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nsum_var_list m z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z<\\STATESEP>by (simp add: sum_var_list_def xp)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nsum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>have \"\\<dots> \\<noteq> sum_var_list [(y,q)] z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z<\\STATESEP>using False<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z<\\STATESEP>unfolding xp yq<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(y, q) \\<noteq> (x, p)\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z<\\STATESEP>by (auto simp: sum_var_list_def z_def p q min_def)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nsum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>have \"sum_var_list [(y,q)] z = sum_var_list n z\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z<\\STATESEP>using sum_var_list_not[OF zn']<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nsum_var_list n' z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z<\\STATESEP>by (simp add: sum_var_list_def n yq)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nsum_var_list [(y, q)] z = sum_var_list n z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow> (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>finally<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>using False<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list n z\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)<\\STATESEP>unfolding n<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nsum_var_list (xp # m) z \\<noteq> sum_var_list (yq # n') z\nyq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = yq # n') = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (yq # n') x)<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>abbreviation (input) monom_list_vars :: \"'a monom_list \\<Rightarrow> 'a set\"\n  where \"monom_list_vars m \\<equiv> fst ` set m\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun monom_mult_list :: \"'a monom_list \\<Rightarrow> 'a monom_list \\<Rightarrow> 'a monom_list\" where \n  \"monom_mult_list [] n = n\"\n| \"monom_mult_list ((x,p) # m) n = (case n of\n     Nil \\<Rightarrow> (x,p) # m \n   | (y,q) # n' \\<Rightarrow> if x = y then (x,p + q) # monom_mult_list m n' else\n       if x < y then (x,p) # monom_mult_list m n else (y,q) # monom_mult_list ((x,p) # m) n')\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma monom_list_mult_list_vars: \"monom_list_vars (monom_mult_list m1 m2) = monom_list_vars m1 \\<union> monom_list_vars m2\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (monom_mult_list m1 m2) = fst ` set m1 \\<union> fst ` set m2<\\STATESEP>by (induct m1 m2 rule: monom_mult_list.induct, auto split: list.splits)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_mult_list_inv: \"monom_inv m1 \\<Longrightarrow> monom_inv m2 \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monom_inv m1; monom_inv m2\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)<\\STATESEP>proof (induct m1 m2 rule: monom_mult_list.induct)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>case (2 x p m n')<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m; monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa; monom_inv m; monom_inv n'\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n')\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\nmonom_inv ((x, p) # m)\nmonom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>note IH = 2(1-3)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m; monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa; monom_inv m; monom_inv n'\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n')\n\\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>note xpm = 2(4)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nmonom_inv ((x, p) # m)\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>note n' = 2(5)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nmonom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n. \\<lbrakk>\\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa; monom_inv m; monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m x22); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa; monom_inv m; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list m n); \\<And>x21 x22 xa y. \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22); monom_inv ((x, p) # m); monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>proof (cases n')<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nn' = []\n\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>with xpm<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv ((x, p) # m)\nn' = []<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\nn' = []\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case (Cons yq n)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nn' = yq # n\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>then<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nn' = yq # n<\\STATESEP>obtain y q where id: \"n' = ((y,q) # n)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nn' = yq # n\n\ngoal (1 subgoal):\n 1. (\\<And>y q. n' = (y, q) # n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases yq, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nn' = (y, q) # n\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from xpm<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv ((x, p) # m)<\\STATESEP>have m: \"monom_inv m\" and p: \"p > 0\" and x: \"x \\<notin> fst ` set m\" \n      and xm: \"\\<And> z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. (monom_inv m &&& 0 < p) &&& x \\<notin> fst ` set m &&& (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)<\\STATESEP>unfolding monom_inv_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and> distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and> distinct (map fst m) \\<and> sorted (map fst m) &&& 0 < p) &&& x \\<notin> fst ` set m &&& (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)<\\STATESEP>by (auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_inv m\n0 < p\nx \\<notin> fst ` set m\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from n'[unfolded id]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv ((y, q) # n)<\\STATESEP>have n: \"monom_inv n\" and q: \"q > 0\" and y: \"y \\<notin> fst ` set n\" \n      and yn: \"\\<And> z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv ((y, q) # n)\n\ngoal (1 subgoal):\n 1. (monom_inv n &&& 0 < q) &&& y \\<notin> fst ` set n &&& (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)<\\STATESEP>unfolding monom_inv_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set ((y, q) # n). 1 \\<le> n) \\<and> distinct (map fst ((y, q) # n)) \\<and> sorted (map fst ((y, q) # n))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and> distinct (map fst n) \\<and> sorted (map fst n) &&& 0 < q) &&& y \\<notin> fst ` set n &&& (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)<\\STATESEP>by (auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_inv n\n0 < q\ny \\<notin> fst ` set n\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list. n' = a # list \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>proof (cases \"x = y\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>hence res: \"monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx = y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n<\\STATESEP>by (simp add: id)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from IH(1)[OF id refl True m n]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv (monom_mult_list m n)<\\STATESEP>have inv: \"monom_inv (monom_mult_list m n)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list m n)\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>unfolding res<\\STATESEP>7<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)<\\STATESEP>using inv p x y True xm yn<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n)\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx = y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)<\\STATESEP>by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>proof (cases \"x < y\")<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case True<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nx < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>hence res: \"monom_mult_list ((x, p) # m) n' = (x,p) # monom_mult_list m n'\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx < y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'<\\STATESEP>by (auto simp add: id)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from IH(2)[OF id refl False True m n']<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv (monom_mult_list m n')<\\STATESEP>have inv: \"monom_inv (monom_mult_list m n')\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n')\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n')<\\STATESEP>.<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list m n')\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>unfolding res<\\STATESEP>9<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')<\\STATESEP>using inv p x y True xm yn<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list m n')\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx < y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')<\\STATESEP>unfolding id<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list m ((y, q) # n))\n0 < p\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx < y\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m ((y, q) # n))<\\STATESEP>by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>case gt: False<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n\\<not> x < y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>with False<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> y\n\\<not> x < y<\\STATESEP>have lt: \"y < x\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> y\n\\<not> x < y\n\ngoal (1 subgoal):\n 1. y < x<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ny < x\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>hence res: \"monom_mult_list ((x, p) # m) n' = (y,q) # monom_mult_list ((x, p) # m) n\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\ny < x\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n<\\STATESEP>using False<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\ny < x\nx \\<noteq> y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n<\\STATESEP>by (auto simp add: id)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from lt<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\ny < x<\\STATESEP>have zm: \"z \\<le> x \\<Longrightarrow> (z,b) \\<notin> set m\" for z b<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\ny < x\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m<\\STATESEP>using xm[of z] x<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\ny < x\nz \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\nx \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m<\\STATESEP>by force<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from zm[of y] lt<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\ny \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\ny < x<\\STATESEP>have ym: \"(y,b) \\<notin> set m\" for b<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\ny \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\ny < x\n\ngoal (1 subgoal):\n 1. (y, b) \\<notin> set m<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(y, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from yn<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z<\\STATESEP>have yn': \"(a, b) \\<in> set n \\<Longrightarrow> y \\<le> a\" for a b<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> set n \\<Longrightarrow> y \\<le> a<\\STATESEP>by force<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>from IH(3)[OF id refl False gt xpm n]<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nmonom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>have inv: \"monom_inv (monom_mult_list ((x, p) # m) n)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n)<\\STATESEP>.<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>define xpm where \"xpm = ((x,p) # m)\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nxpm = (x, p) # m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>have xpm': \"fst ` set xpm = insert x (fst ` set m)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xpm = insert x (fst ` set m)<\\STATESEP>unfolding xpm_def<\\STATESEP>9<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ((x, p) # m) = insert x (fst ` set m)<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')<\\STATESEP>unfolding res<\\STATESEP>9<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)<\\STATESEP>using inv p q x y False gt ym lt xm yn' zm xpm'<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list ((x, p) # m) n)\n0 < p\n0 < q\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx \\<noteq> y\n\\<not> x < y\n(y, ?b) \\<notin> set m\ny < x\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)<\\STATESEP>unfolding id xpm_def[symmetric]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv (monom_mult_list xpm n)\n0 < p\n0 < q\nx \\<notin> fst ` set m\ny \\<notin> fst ` set n\nx \\<noteq> y\n\\<not> x < y\n(y, ?b) \\<notin> set m\ny < x\n?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n(?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\nfst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list xpm n)<\\STATESEP>by (auto simp add: monom_inv_def monom_list_mult_list_vars)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmonom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>n. \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list [] n)<\\STATESEP>qed auto<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_inv_ConsD: \"monom_inv (x # xs) \\<Longrightarrow> monom_inv xs\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (x # xs) \\<Longrightarrow> monom_inv xs<\\STATESEP>by (auto simp: monom_inv_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_var_list_monom_mult_list:  \"sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x<\\STATESEP>proof (induct m n rule: monom_mult_list.induct)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n. \\<lbrakk>\\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m x22) x = sum_var_list m x + sum_var_list x22 x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; \\<not> xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) x22) x = sum_var_list ((xa, p) # m) x + sum_var_list x22 x\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x = sum_var_list ((xa, p) # m) x + sum_var_list n x<\\STATESEP>case (2 x p m n)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x = sum_var_list m x + sum_var_list ?x22.0 x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x = sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (2 subgoals):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n. \\<lbrakk>\\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m x22) x = sum_var_list m x + sum_var_list x22 x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x; \\<And>x21 x22 xaa y. \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa; \\<not> xa < xaa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) x22) x = sum_var_list ((xa, p) # m) x + sum_var_list x22 x\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x = sum_var_list ((xa, p) # m) x + sum_var_list n x<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x = sum_var_list m x + sum_var_list ?x22.0 x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\n\\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa; \\<not> x < ?xa\\<rbrakk> \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x = sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list ((x, p) # m) n) x = sum_var_list ((x, p) # m) x + sum_var_list n x<\\STATESEP>by (cases n; cases \"hd n\", auto split: if_splits simp: sum_var_list_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsum_var_list (monom_mult_list ((x, p) # m) n) x = sum_var_list ((x, p) # m) x + sum_var_list n x\n\ngoal (1 subgoal):\n 1. \\<And>n. sum_var_list (monom_mult_list [] n) x = sum_var_list [] x + sum_var_list n x<\\STATESEP>qed (auto simp: sum_var_list_def)<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_mult_list_inj: assumes m: \"monom_inv m\" and m1: \"monom_inv m1\" and m2: \"monom_inv m2\"\n  and eq: \"monom_mult_list m m1 = monom_mult_list m m2\"\n  shows \"m1 = m2\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. m1 = m2<\\STATESEP>from eq sum_var_list_monom_mult_list[of m]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nmonom_mult_list m m1 = monom_mult_list m m2\nsum_var_list (monom_mult_list m ?n) ?x = sum_var_list m ?x + sum_var_list ?n ?x<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nmonom_mult_list m m1 = monom_mult_list m m2\nsum_var_list (monom_mult_list m ?n) ?x = sum_var_list m ?x + sum_var_list ?n ?x\n\ngoal (1 subgoal):\n 1. m1 = m2<\\STATESEP>by (auto simp: eq_monom_sum_var_list[OF m1 m2] eq_monom_sum_var_list[OF monom_mult_list_inv[OF m m1] monom_mult_list_inv[OF m m2]])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nm1 = m2\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_mult_list[simp]: \"eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n<\\STATESEP>by (induct m n rule: monom_mult_list.induct, auto split: list.splits prod.splits simp: field_simps power_add)<\\STATESEP>1<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>declare monom_mult_list.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>typedef (overloaded) 'v monom = \"Collect (monom_inv :: 'v :: linorder monom_list \\<Rightarrow> bool)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect monom_inv<\\STATESEP>by (rule exI[of _ Nil], auto simp: monom_inv_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>setup_lifting type_definition_monom<\\STATESEP>0<\\TRANSEP><\\STATESEP>lift_definition eval_monom :: \"('v :: linorder,'a :: comm_semiring_1)assign \\<Rightarrow> 'v monom \\<Rightarrow> 'a\"\n  is eval_monom_list<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>lift_definition sum_var :: \"'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> nat\" is sum_var_list<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>instantiation monom :: (linorder) comm_monoid_mult\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lift_definition times_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> 'a monom\" is monom_mult_list<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2. \\<lbrakk>list1 \\<in> Collect monom_inv; list2 \\<in> Collect monom_inv\\<rbrakk> \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv<\\STATESEP>using monom_mult_list_inv<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>monom_inv ?m1.0; monom_inv ?m2.0\\<rbrakk> \\<Longrightarrow> monom_inv (monom_mult_list ?m1.0 ?m2.0)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2. \\<lbrakk>list1 \\<in> Collect monom_inv; list2 \\<in> Collect monom_inv\\<rbrakk> \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lift_definition one_monom :: \"'a monom\" is Nil<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Collect monom_inv<\\STATESEP>by (auto simp: monom_inv_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>instance<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, comm_monoid_mult_class)<\\STATESEP>proof<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a<\\STATESEP>fix a b c :: \"'a monom\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a<\\STATESEP>show \"a * b * c = a * (b * c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)<\\STATESEP>by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\na * b * c = a * (b * c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a<\\STATESEP>show \"a * b = b * a\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a<\\STATESEP>by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\na * b = b * a\n\ngoal (1 subgoal):\n 1. \\<And>a. 1 * a = a<\\STATESEP>show \"1 * a = a\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a<\\STATESEP>by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list monom_mult_list.simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n1 * a = a\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma eq_monom_sum_var: \"m = n \\<longleftrightarrow> (\\<forall> x. sum_var m x = sum_var n x)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var m x = sum_var n x)<\\STATESEP>by (transfer, auto simp: eq_monom_sum_var_list)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eval_monom_mult[simp]: \"eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n<\\STATESEP>by (transfer, rule monom_mult_list)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_var_monom_mult:  \"sum_var (m * n) x = sum_var m x + sum_var n x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var (m * n) x = sum_var m x + sum_var n x<\\STATESEP>by (transfer, rule sum_var_list_monom_mult_list)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_mult_inj: fixes m1 :: \"_ monom\"\n  shows \"m * m1 = m * m2 \\<Longrightarrow> m1 = m2\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. m * m1 = m * m2 \\<Longrightarrow> m1 = m2<\\STATESEP>by (transfer, rule monom_mult_list_inj, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma one_monom_inv_sum_var_inv[simp]: \"sum_var 1 x = 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var 1 x = 0<\\STATESEP>by (transfer, auto simp: sum_var_list_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eval_monom_1[simp]: \"eval_monom  \\<alpha> 1 = 1\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> 1 = (1::'a)<\\STATESEP>by (transfer, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lift_definition var_monom :: \"'v :: linorder \\<Rightarrow> 'v monom\" is \"\\<lambda> x. [(x,1)]\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. [(v, 1)] \\<in> Collect monom_inv<\\STATESEP>by (auto simp: monom_inv_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma var_monom_1[simp]: \"var_monom x \\<noteq> 1\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. var_monom x \\<noteq> 1<\\STATESEP>by (transfer, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eval_var_monom[simp]: \"eval_monom \\<alpha> (var_monom x) = \\<alpha> x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (var_monom x) = \\<alpha> x<\\STATESEP>by (transfer, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma sum_var_monom_var: \"sum_var (var_monom x) y = (if x = y then 1 else 0)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var (var_monom x) y = (if x = y then 1 else 0)<\\STATESEP>by (transfer, auto simp: sum_var_list_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>instantiation monom :: (\"{equal,linorder}\")equal\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lift_definition equal_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> bool\" is \"(=)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>instance<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, equal_class)<\\STATESEP>by (standard, transfer, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>type_synonym ('v,'a)poly = \"('v monom \\<times> 'a)list\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_inv :: \"('v,'a :: zero)poly \\<Rightarrow> bool\"\n  where \"poly_inv p \\<equiv> (\\<forall> c \\<in> snd ` set p. c \\<noteq> 0) \\<and> distinct (map fst p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>abbreviation eval_monomc where \"eval_monomc \\<alpha> mc \\<equiv> eval_monom \\<alpha> (fst mc) * (snd mc)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>primrec eval_poly :: \"('v :: linorder, 'a :: comm_semiring_1)assign \\<Rightarrow> ('v,'a)poly \\<Rightarrow> 'a\" where \n  \"eval_poly \\<alpha> [] = 0\"\n| \"eval_poly \\<alpha> (mc # p) = eval_monomc \\<alpha> mc + eval_poly \\<alpha> p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_const :: \"'a :: zero \\<Rightarrow> ('v :: linorder,'a)poly\" where\n  \"poly_const a = (if a = 0 then [] else [(1,a)])\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_const[simp]: \"eval_poly \\<alpha> (poly_const a) = a\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_const a) = a<\\STATESEP>unfolding poly_const_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (if a = (0::'a) then [] else [(1, a)]) = a<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_const_inv: \"poly_inv (poly_const a)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_const a)<\\STATESEP>unfolding poly_const_def poly_inv_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (if a = (0::'b) then [] else [(1, a)]). c \\<noteq> (0::'b)) \\<and> distinct (map fst (if a = (0::'b) then [] else [(1, a)]))<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>fun poly_add :: \"('v,'a)poly \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_add [] q = q\"\n| \"poly_add ((m,c) # p) q = (case List.extract (\\<lambda> mc. fst mc = m) q of\n    None \\<Rightarrow> (m,c) # poly_add p q\n  | Some (q1,(_,d),q2) \\<Rightarrow> if (c+d = 0) then poly_add p (q1 @ q2) else (m,c+d) # poly_add p (q1 @ q2))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma eval_poly_append[simp]: \"eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2<\\STATESEP>by (induct mc1, auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>abbreviation poly_monoms :: \"('v,'a)poly \\<Rightarrow> 'v monom set\"\n  where \"poly_monoms p \\<equiv> fst ` set p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_add_monoms: \"poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2<\\STATESEP>proof (induct p1 arbitrary: p2)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2<\\STATESEP>hence m: \"m \\<in> poly_monoms (mc # p1)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. m \\<in> poly_monoms (mc # p1)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nm \\<in> poly_monoms (mc # p1)\n\ngoal (2 subgoals):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2. (\\<And>p2. poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2) \\<Longrightarrow> poly_monoms (poly_add (a # p1) p2) \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>proof (cases \"List.extract (\\<lambda> nd. fst nd = m) p2\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>case None<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>with Cons m<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\nm \\<in> poly_monoms (mc # p1)\nList.extract (\\<lambda>nd. fst nd = m) p2 = None<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\npoly_monoms (poly_add p ?p2.0) \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\nm \\<in> poly_monoms (mc # p1)\nList.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>by (auto simp: mc)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>case (Some res)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>nd. fst nd = m) p2 = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>obtain q1 md q2 where res: \"res = (q1,md,q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>from extract_SomeE[OF Some[simplified res]] res<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\np2 = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)<\\STATESEP>obtain d where q: \"p2 = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\np2 = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>p2 = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\np2 = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow> poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2<\\STATESEP>by (simp add: mc Some res, rule subset_trans[OF Cons[of \"q1 @ q2\"]], auto simp: q)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_monoms (poly_add (mc # p) p2) \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>p2. poly_monoms (poly_add [] p2) \\<subseteq> poly_monoms [] \\<union> poly_monoms p2<\\STATESEP>qed simp<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_add_inv: \"poly_inv p \\<Longrightarrow> poly_inv q \\<Longrightarrow> poly_inv (poly_add p q)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q)<\\STATESEP>proof (induct p arbitrary: q)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>poly_inv p; poly_inv ?q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p ?q)\npoly_inv (mc # p)\npoly_inv q\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)<\\STATESEP>with Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)<\\STATESEP>have p: \"poly_inv p\" and c: \"c \\<noteq> 0\" and mp: \"\\<forall> mm \\<in> fst ` set p. (\\<not> mm = m)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p &&& c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m<\\STATESEP>unfolding poly_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p) &&& c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv p\nc \\<noteq> (0::'b)\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add p q); poly_inv (a # p); poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add (a # p) q)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)<\\STATESEP>proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>case None<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>hence mq: \"\\<forall> mm \\<in> fst ` set q. \\<not> mm = m\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m<\\STATESEP>by (auto simp: extract_None_iff)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>fix mm<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>assume \"mm \\<in> fst ` set (poly_add p q)\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>then<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nmm \\<in> poly_monoms (poly_add p q)<\\STATESEP>obtain dd where \"(mm,dd) \\<in> set (poly_add p q)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms (poly_add p q)\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (poly_add p q) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(mm, dd) \\<in> set (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>with poly_add_monoms<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p q)<\\STATESEP>have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p q)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q<\\STATESEP>by force<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>hence \"\\<not> mm = m\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>using mp mq<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>note main = this<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> poly_inv (poly_add (mc # p) q)\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)<\\STATESEP>using Cons(1)[OF p Cons(3)]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (poly_add p q)\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)<\\STATESEP>unfolding poly_inv_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p q))\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add (mc # p) q))<\\STATESEP>using main<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p q))\n?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add (mc # p) q))<\\STATESEP>by (auto simp add: None mc c)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>case (Some res)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>obtain q1 md q2 where res: \"res = (q1,md,q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>from extract_SomeE[OF Some[simplified res]] res<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)<\\STATESEP>obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>from q Cons(3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nq = q1 @ (m, d) # q2\npoly_inv q<\\STATESEP>have q1q2: \"poly_inv (q1 @ q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ (m, d) # q2\npoly_inv q\n\ngoal (1 subgoal):\n 1. poly_inv (q1 @ q2)<\\STATESEP>unfolding poly_inv_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ (m, d) # q2\n(\\<forall>c\\<in>snd ` set q. c \\<noteq> (0::'b)) \\<and> distinct (map fst q)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (q1 @ q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ q2))<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_inv (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>from Cons(1)[OF p q1q2]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (poly_add p (q1 @ q2))<\\STATESEP>have main1: \"poly_inv (poly_add p (q1 @ q2))\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add p (q1 @ q2))<\\STATESEP>.<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>fix mm<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>assume \"mm \\<in> fst ` set (poly_add p (q1 @ q2))\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>then<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))<\\STATESEP>obtain dd where \"(mm,dd) \\<in> set (poly_add p (q1 @ q2))\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (poly_add p (q1 @ q2)) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>with poly_add_monoms<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))<\\STATESEP>have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\npoly_monoms (poly_add ?p1.0 ?p2.0) \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n(mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)<\\STATESEP>by force<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>hence \"mm \\<noteq> m\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>proof<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>assume \"mm \\<in> poly_monoms p\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms p\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>thus ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>using mp<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms p\n\\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>assume member: \"mm \\<in> poly_monoms (q1 @ q2)\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>from member<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nmm \\<in> poly_monoms (q1 @ q2)<\\STATESEP>have \"mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>thus \"mm \\<noteq> m\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>proof<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>assume \"mm \\<in> poly_monoms q2\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms q2\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>with Cons(3)[simplified q]<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q2<\\STATESEP>show ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>unfolding poly_inv_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ (m, d) # q2))\nmm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>next<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>assume \"mm \\<in> poly_monoms q1\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m<\\STATESEP>with Cons(3)[simplified q]<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q1<\\STATESEP>show ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (q1 @ (m, d) # q2)\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>unfolding poly_inv_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and> distinct (map fst (q1 @ (m, d) # q2))\nmm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nmm \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>note main2 = this<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> poly_inv (poly_add (mc # p) q)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)<\\STATESEP>using  main1[unfolded poly_inv_def] main2<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (poly_add p (q1 @ q2)). c \\<noteq> (0::'b)) \\<and> distinct (map fst (poly_add p (q1 @ q2)))\n?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)<\\STATESEP>by (auto simp: poly_inv_def mc Some res)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>q. \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add [] q)<\\STATESEP>qed simp<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_add[simp]: \"eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q<\\STATESEP>proof (induct p arbitrary: q)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_add p ?q) = eval_poly \\<alpha> p + eval_poly \\<alpha> ?q\n\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q. (\\<And>q. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow> eval_poly \\<alpha> (poly_add (a # p) q) = eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>case None<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>by (simp add: Cons[of q] mc None field_simps)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>case (Some res)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>obtain q1 md q2 where res: \"res = (q1,md,q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>from extract_SomeE[OF Some[simplified res]] res<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)<\\STATESEP>obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>fix x<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>assume c: \"c + d = 0\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc + d = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>have \"c * x + d * x = (c + d) * x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. c * x + d * x = (c + d) * x<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nc * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>have \"\\<dots> = 0 * x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (c + d) * x = (0::'a) * x<\\STATESEP>by (simp only: c)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(c + d) * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>finally<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nc * x + d * x = (0::'a) * x<\\STATESEP>have \"c * x + d * x = 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nc * x + d * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. c * x + d * x = (0::'a)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nc * x + d * x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>note id = this<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nc + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q<\\STATESEP>by (simp add: Cons[of \"q1 @ q2\"] mc Some res, simp only: q, simp add: field_simps, auto simp: field_simps id)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_add (mc # p) q) = eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>q. eval_poly \\<alpha> (poly_add [] q) = eval_poly \\<alpha> [] + eval_poly \\<alpha> q<\\STATESEP>qed simp<\\STATESEP>2<\\TRANSEP><\\STATESEP>declare poly_add.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun monom_mult_poly :: \"('v :: linorder monom \\<times> 'a) \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"monom_mult_poly _ [] = []\"\n| \"monom_mult_poly (m,c) ((m',d) # p) = (if c * d = 0 then monom_mult_poly (m,c) p else (m * m', c * d) # monom_mult_poly (m,c) p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma monom_mult_poly_inv: \"poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m,c) p)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) [])<\\STATESEP>by (simp add: poly_inv_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>case (Cons md p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)\npoly_inv (md # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>obtain m' d where md: \"md = (m',d)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m' d. md = (m', d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>with Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (md # p)\nmd = (m', d)<\\STATESEP>have p: \"poly_inv p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (md # p)\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. poly_inv p<\\STATESEP>unfolding poly_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (md # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (md # p))\nmd = (m', d)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>from Cons(1)[OF p]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (monom_mult_poly (m, c) p)<\\STATESEP>have prod: \"poly_inv (monom_mult_poly (m,c) p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) p)<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>fix mm<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>assume \"mm \\<in> fst ` set (monom_mult_poly (m,c) p)\" \n       and two: \"mm = m * m'\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>then<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'<\\STATESEP>obtain dd where one: \"(mm,dd) \\<in> set (monom_mult_poly (m,c) p)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> poly_monoms (monom_mult_poly (m, c) p)\nmm = m * m'\n\ngoal (1 subgoal):\n 1. (\\<And>dd. (mm, dd) \\<in> set (monom_mult_poly (m, c) p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>have \"poly_monoms (monom_mult_poly (m,c) p) \\<subseteq> (*) m ` poly_monoms p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p<\\STATESEP>proof (induct p, simp)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow> poly_monoms (monom_mult_poly (m, c) (a # p)) \\<subseteq> (*) m ` poly_monoms (a # p)<\\STATESEP>case (Cons md p)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow> poly_monoms (monom_mult_poly (m, c) (a # p)) \\<subseteq> (*) m ` poly_monoms (a # p)<\\STATESEP>thus ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) (md # p)) \\<subseteq> (*) m ` poly_monoms (md # p)<\\STATESEP>by (cases md, auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) (md # p)) \\<subseteq> (*) m ` poly_monoms (md # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>with one<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p<\\STATESEP>have \"mm \\<in> (*) m ` poly_monoms p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(mm, dd) \\<in> set (monom_mult_poly (m, c) p)\npoly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<in> (*) m ` poly_monoms p<\\STATESEP>by force<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>then<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmm \\<in> (*) m ` poly_monoms p<\\STATESEP>obtain mmm where mmm: \"mmm \\<in> poly_monoms p\" and mm: \"mm = m * mmm\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. (\\<And>mmm. \\<lbrakk>mmm \\<in> poly_monoms p; mm = m * mmm\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmmm \\<in> poly_monoms p\nmm = m * mmm\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>from Cons(2)[simplified md] mmm<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\npoly_inv ((m', d) # p)\nmmm \\<in> poly_monoms p<\\STATESEP>have not1: \"\\<not> mmm = m'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\npoly_inv ((m', d) # p)\nmmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'<\\STATESEP>unfolding poly_inv_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set ((m', d) # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst ((m', d) # p))\nmmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>from mm two<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmm = m * mmm\nmm = m * m'<\\STATESEP>have \"m * mmm = m * m'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmm = m * mmm\nmm = m * m'\n\ngoal (1 subgoal):\n 1. m * mmm = m * m'<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nm * mmm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>from monom_mult_inj[OF this] not1<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nmmm = m'\nmmm \\<noteq> m'<\\STATESEP>have False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nmmm = m'\nmmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p); ?mm2 = m * m'\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p); ?mm2 = m * m'\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) (md # p))<\\STATESEP>by (simp add: md prod, intro impI, auto simp: poly_inv_def prod[simplified poly_inv_def])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_mult_poly (m, c) (md # p))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_mult_poly[simp]: \"eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p<\\STATESEP>proof (cases mc)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p<\\STATESEP>case (Pair m c)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p<\\STATESEP>proof (simp add: Pair, induct p)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)<\\STATESEP>case (Cons nd q)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) q) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> q\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)<\\STATESEP>obtain n d where nd: \"nd = (n,d)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d. nd = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases nd, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nnd = (n, d)\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p. eval_poly \\<alpha> (monom_mult_poly (m, c) p) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>proof (cases \"c * d = 0\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc * d \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>thus ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nc * d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>by (simp add: nd Cons field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc * d = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>let ?l = \"c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n))\"<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>have \"?l = (c * d) * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)<\\STATESEP>by (simp only: field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>have \"\\<dots> = 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)<\\STATESEP>by (simp only: True, simp add: field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nc * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>finally<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)<\\STATESEP>have l: \"?l = 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nc * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow> eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)<\\STATESEP>by (simp add: nd Cons True, simp add: field_simps l)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) = eval_monom \\<alpha> m * c * eval_poly \\<alpha> []<\\STATESEP>qed simp<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>declare monom_mult_poly.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_minus :: \"('v :: linorder,'a :: ring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_minus f g = poly_add f (monom_mult_poly (1,-1) g)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_minus[simp]: \"eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g<\\STATESEP>unfolding poly_minus_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add f (monom_mult_poly (1, - (1::'a)) g)) = eval_poly \\<alpha> f - eval_poly \\<alpha> g<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_minus_inv: \"poly_inv f \\<Longrightarrow> poly_inv g \\<Longrightarrow> poly_inv (poly_minus f g)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk> \\<Longrightarrow> poly_inv (poly_minus f g)<\\STATESEP>unfolding poly_minus_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk> \\<Longrightarrow> poly_inv (poly_add f (monom_mult_poly (1, - (1::'b)) g))<\\STATESEP>by (intro poly_add_inv monom_mult_poly_inv)<\\STATESEP>1<\\TRANSEP><\\STATESEP>fun poly_mult :: \"('v :: linorder, 'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_mult [] q = []\"\n| \"poly_mult (mc # p) q = poly_add (monom_mult_poly mc q) (poly_mult p q)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_mult_inv: assumes p: \"poly_inv p\" and q: \"poly_inv q\"\n  shows \"poly_inv (poly_mult p q)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)<\\STATESEP>using p<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\npoly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult [] q)<\\STATESEP>by (simp add: poly_inv_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_mult [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (poly_mult p q)\npoly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>with Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)<\\STATESEP>have p: \"poly_inv p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p<\\STATESEP>unfolding poly_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and> distinct (map fst p)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_mult (a # p) q)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult (mc # p) q)<\\STATESEP>by (simp add: mc, rule poly_add_inv[OF monom_mult_poly_inv[OF q] Cons(1)[OF p]])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_mult (mc # p) q)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_mult[simp]: \"eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q<\\STATESEP>by (induct p, auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>declare poly_mult.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition zero_poly :: \"('v,'a)poly\"\nwhere \"zero_poly \\<equiv> []\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma zero_poly_inv: \"poly_inv zero_poly\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv zero_poly<\\STATESEP>unfolding zero_poly_def poly_inv_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set []. c \\<noteq> (0::'b)) \\<and> distinct (map fst [])<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition one_poly :: \"('v :: linorder,'a :: semiring_1)poly\" where \n  \"one_poly \\<equiv> [(1,1)]\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma one_poly_inv: \"poly_inv one_poly\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv one_poly<\\STATESEP>unfolding one_poly_def poly_inv_def monom_inv_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, 1::'b)]. c \\<noteq> (0::'b)) \\<and> distinct (map fst [(1, 1::'b)])<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_one[simp]: \"eval_poly \\<alpha> one_poly = 1\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> one_poly = (1::'a)<\\STATESEP>unfolding one_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [(1, 1::'a)] = (1::'a)<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_zero_add: \"poly_add zero_poly p = p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add zero_poly p = p<\\STATESEP>unfolding zero_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add [] p = p<\\STATESEP>using poly_add.simps<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\npoly_add [] ?q = ?q\npoly_add ((?m, ?c) # ?p) ?q = (case List.extract (\\<lambda>mc. fst mc = ?m) ?q of None \\<Rightarrow> (?m, ?c) # poly_add ?p ?q | Some (q1, (x, d), q2) \\<Rightarrow> if ?c + d = (0::?'a) then poly_add ?p (q1 @ q2) else (?m, ?c + d) # poly_add ?p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_add [] p = p<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_zero_mult: \"poly_mult zero_poly p = zero_poly\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult zero_poly p = zero_poly<\\STATESEP>unfolding zero_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult [] p = []<\\STATESEP>using poly_mult.simps<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\npoly_mult [] ?q = []\npoly_mult (?mc # ?p) ?q = poly_add (monom_mult_poly ?mc ?q) (poly_mult ?p ?q)\n\ngoal (1 subgoal):\n 1. poly_mult [] p = []<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition eq_poly :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"=p\" 51)\nwhere \"p =p q \\<equiv> \\<forall> \\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_one_mult: \"poly_mult one_poly p =p p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult one_poly p =p p<\\STATESEP>unfolding eq_poly_def one_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult [(1, 1::'b)] p) = eval_poly \\<alpha> p<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eq_poly_refl[simp]: \"p =p p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p =p p<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> p<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eq_poly_trans[trans]: \"\\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. eval_poly \\<alpha> p1 = eval_poly \\<alpha> p2; \\<forall>\\<alpha>. eval_poly \\<alpha> p2 = eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. eval_poly \\<alpha> p1 = eval_poly \\<alpha> p3<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_add_comm: \"poly_add p q =p poly_add q p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q =p poly_add q p<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> (poly_add q p)<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_add_assoc: \"poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_add p1 (poly_add p2 p3)) = eval_poly \\<alpha> (poly_add (poly_add p1 p2) p3)<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_mult_comm: \"poly_mult p q =p poly_mult q p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p q =p poly_mult q p<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> (poly_mult q p)<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_mult_assoc: \"poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p1 (poly_mult p2 p3)) = eval_poly \\<alpha> (poly_mult (poly_mult p1 p2) p3)<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_distrib: \"poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> (poly_mult p (poly_add q1 q2)) = eval_poly \\<alpha> (poly_add (poly_mult p q1) (poly_mult p q2))<\\STATESEP>by (auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>subsection \\<open>Computing normal forms of polynomials\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>fun\n  poly_of :: \"('v :: linorder,'a :: comm_semiring_1)tpoly \\<Rightarrow> ('v,'a)poly\"\nwhere \"poly_of (PNum i) = (if i = 0 then [] else [(1,i)])\"\n    | \"poly_of (PVar x) = [(var_monom x,1)]\"\n    | \"poly_of (PSum []) = zero_poly\" \n    | \"poly_of (PSum (p # ps)) = (poly_add (poly_of p) (poly_of (PSum ps)))\"\n    | \"poly_of (PMult []) = one_poly\" \n    | \"poly_of (PMult (p # ps)) = (poly_mult (poly_of p) (poly_of (PMult ps)))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_of: \"eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p<\\STATESEP>by (induct p rule: poly_of.induct, (simp add: zero_poly_def one_poly_def)+)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_of_inv: \"poly_inv (poly_of p)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_of p)<\\STATESEP>by (induct p rule: poly_of.induct, \n    simp add: poly_inv_def monom_inv_def,\n    simp add: poly_inv_def monom_inv_def,\n    simp add: zero_poly_inv,\n    simp add: poly_add_inv,\n    simp add: one_poly_inv,\n    simp add: poly_mult_inv)<\\STATESEP>1<\\TRANSEP><\\STATESEP>subsection \\<open>Powers and substitutions of polynomials\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>fun poly_power :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> nat \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_power _ 0 = one_poly\"\n| \"poly_power p (Suc n) = poly_mult p (poly_power p n)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_power[simp]: \"eval_poly \\<alpha> (poly_power p n) = (eval_poly \\<alpha> p) ^ n\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_power p n) = eval_poly \\<alpha> p ^ n<\\STATESEP>by (induct n, auto simp: one_poly_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_power_inv: assumes p: \"poly_inv p\" \n  shows \"poly_inv (poly_power p n)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_power p n)<\\STATESEP>by (induct n, simp add: one_poly_inv, simp add: poly_mult_inv[OF p])<\\STATESEP>1<\\TRANSEP><\\STATESEP>declare poly_power.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun monom_list_subst :: \"('v \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom_list \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_list_subst \\<sigma> [] = one_poly\"\n| \"monom_list_subst \\<sigma> ((x,p) # m) = poly_mult (poly_power (\\<sigma> x) p) (monom_list_subst \\<sigma> m)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lift_definition monom_list :: \"'v :: linorder monom \\<Rightarrow> 'v monom_list\" is \"\\<lambda> x. x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition monom_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_subst \\<sigma> m = monom_list_subst \\<sigma> (monom_list m)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma monom_list_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_list_subst \\<sigma> m)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> m)<\\STATESEP>proof (induct m)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> [])<\\STATESEP>by (simp add: one_poly_inv)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>case (Cons xp m)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> m)\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>obtain x p where xp: \"xp = (x,p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases xp, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m. poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow> poly_inv (monom_list_subst \\<sigma> (a # m))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (xp # m))<\\STATESEP>by (simp add: xp, rule poly_mult_inv[OF poly_power_inv[OF sub] Cons])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (monom_list_subst \\<sigma> (xp # m))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_subst \\<sigma> m)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_subst \\<sigma> m)<\\STATESEP>unfolding monom_subst_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (monom_list m))<\\STATESEP>by (rule monom_list_subst_inv[OF sub])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_subst[simp]: \"eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m<\\STATESEP>unfolding monom_subst_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_list_subst \\<sigma> (monom_list m)) = eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m<\\STATESEP>proof (transfer fixing: \\<alpha> \\<sigma>, clarsimp)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m<\\STATESEP>fix m<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m<\\STATESEP>show \"monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m<\\STATESEP>by (induct m, simp add: one_poly_def, auto simp: field_simps monom_inv_ConsD)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmonom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>fun poly_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('w,'a)poly\" where \n  \"poly_subst \\<sigma> [] = zero_poly\"\n| \"poly_subst \\<sigma> ((m,c) # p) = poly_add (poly_mult [(1,c)] (monom_subst \\<sigma> m)) (poly_subst \\<sigma> p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" and p: \"poly_inv p\"\n  shows \"poly_inv (poly_subst \\<sigma> p)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)<\\STATESEP>using p<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\npoly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> [])<\\STATESEP>by (simp add: zero_poly_inv)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npoly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p)\npoly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>with Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_inv (mc # p)\nmc = (m, c)<\\STATESEP>have c: \"c \\<noteq> 0\" and p: \"poly_inv p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_inv (mc # p)\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&& poly_inv p<\\STATESEP>unfolding poly_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'c)) \\<and> distinct (map fst (mc # p))\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&& (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'c)) \\<and> distinct (map fst p)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nc \\<noteq> (0::'c)\npoly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>from c<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nc \\<noteq> (0::'c)<\\STATESEP>have c: \"poly_inv [(1,c)]\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nc \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. poly_inv [(1, c)]<\\STATESEP>unfolding poly_inv_def monom_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nc \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, c)]. c \\<noteq> (0::'c)) \\<and> distinct (map fst [(1, c)])<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv [(1, c)]\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p); poly_inv (a # p)\\<rbrakk> \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> (mc # p))<\\STATESEP>by (simp add: mc, rule poly_add_inv[OF poly_mult_inv[OF c monom_subst_inv[OF sub]] Cons(1)[OF p]])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_inv (poly_subst \\<sigma> (mc # p))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_subst: \"eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) p<\\STATESEP>by (induct p, simp add: zero_poly_def, auto simp: field_simps)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma eval_poly_subst: \n  assumes eq: \"\\<And> w. f w = eval_poly g (q w)\"\n  shows \"eval_poly f p = eval_poly g (poly_subst q p)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst q p)<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])<\\STATESEP>by (simp add: zero_poly_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly f [] = eval_poly g (poly_subst q [])\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst q p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>have id: \"eval_monom f m =  eval_monom (\\<lambda>v. eval_poly g (q v)) m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m<\\STATESEP>proof (transfer fixing: f g q, clarsimp)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m<\\STATESEP>fix m<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. monom_inv m \\<Longrightarrow> eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m<\\STATESEP>show \"eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m<\\STATESEP>proof (induct m)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)<\\STATESEP>case (Cons wp m)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)<\\STATESEP>obtain w p where wp: \"wp = (w,p)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w p. wp = (w, p) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases wp, auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nwp = (w, p)\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow> eval_monom_list f (a # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f (wp # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)<\\STATESEP>by (simp add: wp Cons eq)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_monom_list f (wp # m) = eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)\n\ngoal (1 subgoal):\n 1. eval_monom_list f [] = eval_monom_list (\\<lambda>v. eval_poly g (q v)) []<\\STATESEP>qed simp<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow> eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))<\\STATESEP>by (simp add: mc Cons id, simp add: field_simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lift_definition monom_vars_list :: \"'v :: linorder monom \\<Rightarrow> 'v list\" is \"map fst\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_vars_list_subst: assumes \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\" \n  shows \"monom_subst f m = monom_subst g m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m<\\STATESEP>unfolding monom_subst_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)<\\STATESEP>proof (transfer fixing: f g)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m<\\STATESEP>fix m :: \"'a monom_list\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m<\\STATESEP>assume eq: \"\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>m. \\<lbrakk>m \\<in> Collect monom_inv; \\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m<\\STATESEP>thus \"monom_list_subst f m = monom_list_subst g m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m<\\STATESEP>proof (induct m)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)<\\STATESEP>case (Cons wn m)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m\n?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)<\\STATESEP>hence rec: \"monom_list_subst f m = monom_list_subst g m\" and eq: \"f (fst wn) = g (fst wn)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m\n?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m &&& f (fst wn) = g (fst wn)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_list_subst f m = monom_list_subst g m\nf (fst wn) = g (fst wn)\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m. \\<lbrakk>(\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m; \\<And>w. w \\<in> set (map fst (a # m)) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> monom_list_subst f (a # m) = monom_list_subst g (a # m)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)<\\STATESEP>proof (cases wn)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. wn = (a, b) \\<Longrightarrow> monom_list_subst f (wn # m) = monom_list_subst g (wn # m)<\\STATESEP>case (Pair w n)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nwn = (w, n)\n\ngoal (1 subgoal):\n 1. \\<And>a b. wn = (a, b) \\<Longrightarrow> monom_list_subst f (wn # m) = monom_list_subst g (wn # m)<\\STATESEP>with eq rec<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nf (fst wn) = g (fst wn)\nmonom_list_subst f m = monom_list_subst g m\nwn = (w, n)<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nf (fst wn) = g (fst wn)\nmonom_list_subst f m = monom_list_subst g m\nwn = (w, n)\n\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nmonom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmonom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> f w = g w) \\<Longrightarrow> monom_list_subst f [] = monom_list_subst g []<\\STATESEP>qed simp<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmonom_list_subst f m = monom_list_subst g m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma eval_monom_vars_list: assumes \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs<\\STATESEP>proof (transfer fixing: \\<alpha> \\<beta>)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs<\\STATESEP>fix xs :: \"'a monom_list\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs<\\STATESEP>assume eq: \"\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. \\<And>xs. \\<lbrakk>xs \\<in> Collect monom_inv; \\<And>x. x \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs<\\STATESEP>thus \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs<\\STATESEP>proof (induct xs)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)<\\STATESEP>case (Cons xi xs)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)<\\STATESEP>hence IH: \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)<\\STATESEP>obtain x i where xi: \"xi = (x,i)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x i. xi = (x, i) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nxi = (x, i)\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)<\\STATESEP>from Cons(2) xi<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\nxi = (x, i)<\\STATESEP>have \"\\<alpha> x = \\<beta> x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\nxi = (x, i)\n\ngoal (1 subgoal):\n 1. \\<alpha> x = \\<beta> x<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<alpha> x = \\<beta> x\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs. \\<lbrakk>(\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs; \\<And>w. w \\<in> set (map fst (a # xs)) \\<Longrightarrow> \\<alpha> w = \\<beta> w\\<rbrakk> \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) = eval_monom_list \\<beta> (a # xs)<\\STATESEP>with IH<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)<\\STATESEP>unfolding xi<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> ((x, i) # xs) = eval_monom_list \\<beta> ((x, i) # xs)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> set (map fst []) \\<Longrightarrow> \\<alpha> w = \\<beta> w) \\<Longrightarrow> eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []<\\STATESEP>qed simp<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition monom_vars where \"monom_vars m = set (monom_vars_list m)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma monom_vars_list_1[simp]: \"monom_vars_list 1 = []\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list 1 = []<\\STATESEP>by transfer auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_vars_list_var_monom[simp]: \"monom_vars_list (var_monom x) = [x]\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list (var_monom x) = [x]<\\STATESEP>by transfer auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_vars_eval_monom: \n  \"(\\<And> x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m<\\STATESEP>by (rule eval_monom_vars_list, auto simp: monom_vars_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition poly_vars_list :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v list\" where \n  \"poly_vars_list p = remdups (concat (map (monom_vars_list o fst) p))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_vars :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v set\" where \n  \"poly_vars p = set (concat (map (monom_vars_list o fst) p))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_vars_list[simp]: \"set (poly_vars_list p) = poly_vars p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (poly_vars_list p) = poly_vars p<\\STATESEP>unfolding poly_vars_list_def poly_vars_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. set (remdups (concat (map (monom_vars_list \\<circ> fst) p))) = set (concat (map (monom_vars_list \\<circ> fst) p))<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_vars: assumes eq: \"\\<And> w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p<\\STATESEP>using eq<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> poly_vars p \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)<\\STATESEP>hence rec: \"poly_subst f p = poly_subst g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p<\\STATESEP>unfolding poly_vars_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>w. w \\<in> set (concat (map (monom_vars_list \\<circ> fst) p)) \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p\n?w \\<in> set (concat (map (monom_vars_list \\<circ> fst) (mc # p))) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_subst f p = poly_subst g p\n\ngoal (2 subgoals):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f p = poly_subst g p; \\<And>w. w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk> \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>proof (cases mc)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>case (Pair m c)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>with Cons(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)<\\STATESEP>have \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w<\\STATESEP>unfolding poly_vars_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (concat (map (monom_vars_list \\<circ> fst) (mc # p))) \\<Longrightarrow> f ?w = g ?w\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>hence \"monom_subst f m = monom_subst g m\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m<\\STATESEP>by (rule monom_vars_list_subst)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmonom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>with rec Pair<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\npoly_subst f p = poly_subst g p\nmc = (m, c)\nmonom_subst f m = monom_subst g m<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\npoly_subst f p = poly_subst g p\nmc = (m, c)\nmonom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow> poly_subst f [] = poly_subst g []<\\STATESEP>qed simp<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_var: assumes pv: \"v \\<notin> poly_vars p\" and diff: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p<\\STATESEP>proof (rule poly_vars)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w<\\STATESEP>fix w<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w<\\STATESEP>assume \"w \\<in> poly_vars p\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nw \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w<\\STATESEP>thus \"f w = g w\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nw \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. f w = g w<\\STATESEP>using pv diff<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nw \\<in> poly_vars p\nv \\<notin> poly_vars p\nv \\<noteq> ?w \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. f w = g w<\\STATESEP>by (cases \"v = w\", auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf w = g w\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma eval_poly_vars: assumes \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (2 subgoals):\n 1. (\\<And>x. x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<beta> []<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> [] = eval_poly \\<beta> []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>case (Cons m p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>from Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x<\\STATESEP>have \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x<\\STATESEP>unfolding poly_vars_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> set (concat (map (monom_vars_list \\<circ> fst) (m # p))) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (concat (map (monom_vars_list \\<circ> fst) p)) \\<Longrightarrow> \\<alpha> x = \\<beta> x<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>from Cons(1)[OF this]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> x \\<in> poly_vars p) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p<\\STATESEP>have IH: \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> x \\<in> poly_vars p) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>obtain xs c where m: \"m = (xs,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs c. m = (xs, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nm = (xs, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>from Cons(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x<\\STATESEP>have \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x<\\STATESEP>unfolding poly_vars_def m<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> set (concat (map (monom_vars_list \\<circ> fst) ((xs, c) # p))) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>hence \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs<\\STATESEP>by (rule eval_monom_vars_list)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x) \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<beta> p; \\<And>x. x \\<in> poly_vars (a # p) \\<Longrightarrow> \\<alpha> x = \\<beta> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<beta> (a # p)<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)<\\STATESEP>unfolding eval_poly.simps IH m<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (xs, c) + eval_poly \\<beta> p = eval_monomc \\<beta> (xs, c) + eval_poly \\<beta> p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>declare poly_subst.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>subsection \\<open>\n  Polynomial orders\n\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>definition pos_assign :: \"('v,'a :: ordered_semiring_0)assign \\<Rightarrow> bool\"\nwhere \"pos_assign \\<alpha> = (\\<forall> x. \\<alpha> x \\<ge> 0)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_ge :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"\\<ge>p\" 51)\nwhere \"p \\<ge>p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_ge_refl[simp]: \"p \\<ge>p p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p p<\\STATESEP>unfolding poly_ge_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p<\\STATESEP>using ge_refl<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_ge_trans[trans]: \"\\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3<\\STATESEP>unfolding poly_ge_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1<\\STATESEP>using ge_trans<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y \\<le> ?x; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma pos_assign_monom_list: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom_list \\<alpha> m \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> m<\\STATESEP>proof (induct m)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []<\\STATESEP>by (simp add: one_ge_zero)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> []\n\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)<\\STATESEP>case (Cons xp m)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> m\n\ngoal (1 subgoal):\n 1. \\<And>a m. (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>proof (cases xp)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>case (Pair x p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nxp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> \\<alpha> x<\\STATESEP>have ge: \"\\<alpha> x \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>have ge: \"\\<alpha> x ^ p \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ p<\\STATESEP>proof (induct p)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>case 0<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>thus ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0<\\STATESEP>by (simp add: one_ge_zero)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>case (Suc p)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>p. (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow> (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>from ge_trans[OF times_left_mono[OF ge Suc] times_right_mono[OF ge_refl ge]]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ Suc p<\\STATESEP>by (simp add: field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ Suc p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>a b. xp = (a, b) \\<Longrightarrow> (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>from ge_trans[OF times_right_mono[OF Cons ge] times_left_mono[OF ge_refl Cons]]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)<\\STATESEP>by (simp add: Pair)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma pos_assign_monom: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom \\<alpha> m \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m<\\STATESEP>by (transfer fixing: \\<alpha>, rule pos_assign_monom_list[OF pos])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma pos_assign_poly:   assumes pos: \"pos_assign \\<alpha>\"\n  and p: \"p \\<ge>p zero_poly\"\n  shows \"eval_poly \\<alpha> p \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p<\\STATESEP>from p[unfolded poly_ge_def zero_poly_def] pos<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha><\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_add_ge_mono: assumes \"p1 \\<ge>p p2\" shows \"poly_add p1 q \\<ge>p poly_add p2 q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\np1 \\<ge>p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q<\\STATESEP>unfolding poly_ge_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_add p2 q) \\<le> eval_poly \\<alpha> (poly_add p1 q)<\\STATESEP>by (auto simp: field_simps plus_left_mono)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_mult_ge_mono: assumes \"p1 \\<ge>p p2\" and \"q \\<ge>p zero_poly\"\n  shows \"poly_mult p1 q \\<ge>p poly_mult p2 q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\np1 \\<ge>p p2\nq \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_mult p2 q) \\<le> eval_poly \\<alpha> (poly_mult p1 q)<\\STATESEP>by (auto simp: times_left_mono)<\\STATESEP>1<\\TRANSEP><\\STATESEP>context poly_order_carrier\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_gt :: \"('v :: linorder,'a)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \">p\" 51)\nwhere \"p >p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_gt_imp_poly_ge: \"p >p q \\<Longrightarrow> p \\<ge>p q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p >p q \\<Longrightarrow> p \\<ge>p q<\\STATESEP>unfolding poly_ge_def poly_gt_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p<\\STATESEP>using gt_imp_ge<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?x \\<succ> ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>abbreviation poly_GT :: \"('v :: linorder,'a)poly rel\"\nwhere \"poly_GT \\<equiv> {(p,q) | p q. p >p q \\<and> q \\<ge>p zero_poly}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_compat: \"\\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3<\\STATESEP>unfolding poly_ge_def poly_gt_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>using compat<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y \\<le> ?x; ?y \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_compat2: \"\\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3<\\STATESEP>unfolding poly_ge_def poly_gt_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>using compat2<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?x \\<succ> ?y; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_gt_trans[trans]: \"\\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3<\\STATESEP>unfolding poly_gt_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>using gt_trans<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?x \\<succ> ?y; ?y \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2; \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk> \\<Longrightarrow> \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_GT_SN: \"SN poly_GT\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. SN poly_GT<\\STATESEP>proof<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>fix f :: \"nat \\<Rightarrow> ('c :: linorder,'a)poly\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>assume f: \"\\<forall> i. (f i, f (Suc i)) \\<in> poly_GT\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>have pos: \"pos_assign ((\\<lambda> x. 0) :: ('v,'a)assign)\" (is \"pos_assign ?ass\")<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>x. 0::'a)<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)<\\STATESEP>using ge_refl<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>obtain g where g: \"\\<And> i. g i = eval_poly ?ass (f i)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. (\\<And>i. g i = eval_poly (\\<lambda>x. 0::'a) (f i)) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ng ?i3 = eval_poly (\\<lambda>x. 0::'a) (f ?i3)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>from f pos<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\npos_assign (\\<lambda>x. 0::'a)<\\STATESEP>have \"\\<forall> i. g (Suc i) \\<ge> 0 \\<and> g i \\<succ> g (Suc i)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)<\\STATESEP>unfolding poly_gt_def g<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> {(p, q) |p q. (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and> q \\<ge>p zero_poly}\npos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and> eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ> eval_poly (\\<lambda>x. 0::'a) (f (Suc i))<\\STATESEP>using pos_assign_poly<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>i. (f i, f (Suc i)) \\<in> {(p, q) |p q. (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and> q \\<ge>p zero_poly}\npos_assign (\\<lambda>x. 0::'a)\n\\<lbrakk>pos_assign ?\\<alpha>; ?p \\<ge>p zero_poly\\<rbrakk> \\<Longrightarrow> (0::?'b) \\<le> eval_poly ?\\<alpha> ?p\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and> eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ> eval_poly (\\<lambda>x. 0::'a) (f (Suc i))<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>f 0 \\<in> UNIV; \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>with SN<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)<\\STATESEP>show False<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>unfolding SN_defs<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<nexists>f. f 0 \\<in> UNIV \\<and> (\\<forall>i. (f i, f (Suc i)) \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n\\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma eval_monom_list_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\n  shows \"eval_monom_list f m \\<ge> eval_monom_list g m\" \"eval_monom_list g m \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&& (0::'a) \\<le> eval_monom_list g m<\\STATESEP>proof (atomize(full), induct m)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []<\\STATESEP>using one_ge_zero<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(0::?'a) \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []<\\STATESEP>by (auto simp: ge_refl)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom_list g [] \\<le> eval_monom_list f [] \\<and> (0::'a) \\<le> eval_monom_list g []\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>case (Cons xd m)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>hence IH1: \" eval_monom_list f m \\<ge> eval_monom_list g m\" and IH2: \"eval_monom_list g m \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\neval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&& (0::'a) \\<le> eval_monom_list g m<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom_list g m \\<le> eval_monom_list f m\n(0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>obtain x d where xd: \"xd = (x,d)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x d. xd = (x, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nxd = (x, d)\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>from pow_mono[OF fg g, of x d]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ng x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d<\\STATESEP>have fgd: \"f x ^ d \\<ge> g x ^ d\" and gd: \"g x ^ d \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ng x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. g x ^ d \\<le> f x ^ d &&& (0::'a) \\<le> g x ^ d<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ng x ^ d \\<le> f x ^ d\n(0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list g m \\<le> eval_monom_list f m \\<and> (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow> eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and> (0::'a) \\<le> eval_monom_list g (a # m)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and> (0::'a) \\<le> eval_monom_list g (xd # m)<\\STATESEP>unfolding xd eval_monom_list.simps<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m * g x ^ d \\<le> eval_monom_list f m * f x ^ d \\<and> (0::'a) \\<le> eval_monom_list g m * g x ^ d<\\STATESEP>proof (rule conjI, rule ge_trans[OF times_left_mono[OF pow_ge_zero IH1] times_right_mono[OF IH2 fgd]])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> f x\n 2. (0::'a) \\<le> eval_monom_list g m * g x ^ d<\\STATESEP>show \"f x \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> f x<\\STATESEP>by (rule ge_trans[OF fg g])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> f x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d<\\STATESEP>show \"eval_monom_list g m * g x ^ d \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d<\\STATESEP>by (rule mult_ge_zero[OF IH2 gd])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom_list g m * g x ^ d\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and> (0::'a) \\<le> eval_monom_list g (xd # m)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma eval_monom_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\nshows \"eval_monom f m \\<ge> eval_monom g m\" \"eval_monom g m \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m &&& (0::'a) \\<le> eval_monom g m<\\STATESEP>by (atomize(full), transfer fixing: f g, insert eval_monom_list_mono[of g f, OF fg g], auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition poly_weak_mono_all :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\" where \n  \"poly_weak_mono_all p \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. \\<alpha> x \\<ge> \\<beta> x) \n    \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_weak_mono_all_E: assumes p: \"poly_weak_mono_all p\" and \n  ge: \"\\<And> x. f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p<\\STATESEP>unfolding poly_ge_def poly_subst<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p<\\STATESEP>proof (intro allI impI, rule p[unfolded poly_weak_mono_all_def, rule_format])<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\" and x<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) \\<ge> eval_poly \\<alpha> (g x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)<\\STATESEP>using ge[of x]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> zero_poly \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>assume alpha: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>show \"eval_poly \\<alpha> (g x) \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using ge[of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using alpha<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and> (\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition poly_weak_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_weak_mono_E: assumes p: \"poly_weak_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p<\\STATESEP>unfolding poly_ge_def poly_subst<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p<\\STATESEP>proof (intro allI impI, rule p[unfolded poly_weak_mono_def, rule_format])<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>using fgv<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>assume alpha: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>show \"eval_poly \\<alpha> (g x) \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using g[of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using alpha<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\" and x<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>assume v: \"v \\<noteq> x\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>using fgw[OF v]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition poly_weak_anti_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_anti_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<beta> p \\<ge> eval_poly \\<alpha> p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_weak_anti_mono_E: assumes p: \"poly_weak_anti_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst g p \\<ge>p poly_subst f p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst g p \\<ge>p poly_subst f p<\\STATESEP>unfolding poly_ge_def poly_subst<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p<\\STATESEP>proof (intro allI impI, rule p[unfolded poly_weak_anti_mono_def, rule_format])<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>using fgv<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>assume alpha: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>show \"eval_poly \\<alpha> (g x) \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using g[of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using alpha<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>fix \\<alpha> :: \"('c,'b)assign\" and x<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>assume v: \"v \\<noteq> x\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>using fgw[OF v]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes mono: \"\\<And> v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v\"\n  shows \"poly_weak_mono_all p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p<\\STATESEP>unfolding poly_weak_mono_all_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix \\<alpha> \\<beta> :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume all: \"\\<forall> x. \\<alpha> x \\<ge> \\<beta> x\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>x. \\<beta> x \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume pos: \"pos_assign \\<beta>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>let ?ab = \"\\<lambda> vs v. if (v \\<in> set vs) then \\<alpha> v else \\<beta> v\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix vs :: \"'v list\"<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume \"set vs \\<subseteq> poly_vars p\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nset vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>hence \"eval_poly (?ab vs) p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nset vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p<\\STATESEP>proof (induct vs)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>case Nil<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nset [] \\<subseteq> poly_vars p\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>case (Cons v vs)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nset vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\nset (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>hence subset: \"set vs \\<subseteq> poly_vars p\"  and v: \"v \\<in> poly_vars p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nset vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\nset (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> poly_vars p &&& v \\<in> poly_vars p<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nset vs \\<subseteq> poly_vars p\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs. \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p; set (a # vs) \\<subseteq> poly_vars p\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set (a # vs) then \\<alpha> v else \\<beta> v) p<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>va. if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va) p<\\STATESEP>proof (rule ge_trans[OF mono[OF v, unfolded poly_weak_mono_def, rule_format] Cons(1)[OF subset]])<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. pos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n 3. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)<\\STATESEP>show \"pos_assign (?ab vs)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)<\\STATESEP>unfolding pos_assign_def<\\STATESEP>9<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>proof<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>fix x<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> \\<beta> x<\\STATESEP>have beta: \"\\<beta> x \\<ge> 0\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<beta> x<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>from ge_trans[OF all[rule_format] this]<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> \\<alpha> x<\\STATESEP>have alpha: \"\\<alpha> x \\<ge> 0\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x<\\STATESEP>.<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>from alpha beta<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> \\<alpha> x\n(0::'a) \\<le> \\<beta> x<\\STATESEP>show \"?ab vs x \\<ge> 0\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> \\<alpha> x\n(0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n\ngoal (2 subgoals):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)<\\STATESEP>show \"(?ab (v # vs) v) \\<ge> (?ab vs v)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)<\\STATESEP>using all ge_refl<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. \\<beta> x \\<le> \\<alpha> x\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(if v \\<in> set vs then \\<alpha> v else \\<beta> v) \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>fix x<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>assume \"v \\<noteq> x\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>thus \"(?ab (v # vs) x) = (?ab vs x)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) = (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>va. if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va) p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nset ?vs2 \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> set ?vs2 then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from this[of \"poly_vars_list p\", unfolded poly_vars_list]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_vars p \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p<\\STATESEP>have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_vars p \\<subseteq> poly_vars p \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>also<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p<\\STATESEP>by (rule eval_poly_vars, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>finally<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\" \n  assumes p: \"poly_weak_mono_all p\"\n  shows \"poly_weak_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v<\\STATESEP>unfolding poly_weak_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix \\<alpha> \\<beta> :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume all: \"\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume pos: \"pos_assign \\<beta>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume v: \"\\<alpha> v \\<ge> \\<beta> v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<beta> v \\<le> \\<alpha> v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (rule p[unfolded poly_weak_mono_all_def, rule_format, OF _ pos])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x<\\STATESEP>show \"\\<alpha> x \\<ge> \\<beta> x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x<\\STATESEP>using v all ge_refl[of \"\\<beta> x\"]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<beta> v \\<le> \\<alpha> v\n\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n\\<beta> x \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<beta> x \\<le> \\<alpha> x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_weak_mono_all_pos: \n  fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes pos_at_zero: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"\n  and mono: \"poly_weak_mono_all p\"\n  shows \"p \\<ge>p zero_poly\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI, simp)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>fix  \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>assume pos: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>show \"eval_poly \\<alpha> p \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>proof -<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>let ?id = \"\\<lambda> w. poly_of (PVar w)\"<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>let ?z = \"\\<lambda> w. zero_poly\"<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>have \"poly_subst ?id p \\<ge>p poly_subst ?z p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p<\\STATESEP>by (rule poly_weak_mono_all_E[OF mono],  \n        simp, simp add: poly_ge_def zero_poly_def pos_assign_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>hence \"eval_poly \\<alpha> (poly_subst ?id p) \\<ge> eval_poly \\<alpha> (poly_subst ?z p)\" (is \"_ \\<ge> ?res\")<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)<\\STATESEP>using pos<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>also<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>have \"?res = eval_poly (\\<lambda> w. 0) p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p<\\STATESEP>by (simp add: poly_subst zero_poly_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>also<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) = eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>have \"\\<dots> \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p<\\STATESEP>by (rule pos_at_zero)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>finally<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p<\\STATESEP>by  (simp add: poly_subst)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>context poly_order_carrier\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_strict_mono :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_strict_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. (v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x)) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_strict_mono_E: assumes p: \"poly_strict_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v >p g v\"\n  shows \"poly_subst f p >p poly_subst g p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p >p poly_subst g p<\\STATESEP>unfolding poly_gt_def poly_subst<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p \\<succ> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p<\\STATESEP>proof (intro allI impI, rule p[unfolded poly_strict_mono_def, rule_format])<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)<\\STATESEP>fix \\<alpha> :: \"('c,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)<\\STATESEP>using fgv<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf v >p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)<\\STATESEP>unfolding poly_gt_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>fix \\<alpha> :: \"('c,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>assume alpha: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>show \"eval_poly \\<alpha> (g x) \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using g[of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def zero_poly_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>using alpha<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>fix \\<alpha> :: \"('c,'a)assign\" and x<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>assume v: \"v \\<noteq> x\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x. \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>using fgw[OF v]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_add_gt_mono: assumes \"p1 >p p2\" shows \"poly_add p1 q >p poly_add p2 q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\np1 >p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q<\\STATESEP>unfolding poly_gt_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_add p1 q) \\<succ> eval_poly \\<alpha> (poly_add p2 q)<\\STATESEP>by (auto simp: field_simps plus_gt_left_mono)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_mult_gt_mono: \n  fixes q :: \"('v :: linorder,'a)poly\"\n  assumes gt: \"p1 >p p2\" and mono: \"q \\<ge>p one_poly\"\n  shows \"poly_mult p1 q >p poly_mult p2 q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q >p poly_mult p2 q<\\STATESEP>proof (unfold poly_gt_def, intro impI allI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>fix \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>assume p: \"pos_assign \\<alpha>\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>with gt<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\np1 >p p2\npos_assign \\<alpha><\\STATESEP>have gt: \"eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\np1 >p p2\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2<\\STATESEP>unfolding poly_gt_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>from mono p<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nq \\<ge>p one_poly\npos_assign \\<alpha><\\STATESEP>have one: \"eval_poly \\<alpha> q \\<ge> 1\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nq \\<ge>p one_poly\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q<\\STATESEP>unfolding poly_ge_def one_poly_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> [(1, 1::'a)] \\<le> eval_poly \\<alpha> q\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(1::'a) \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>show \"eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>using times_gt_mono[OF gt one]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\neval_poly \\<alpha> p1 * eval_poly \\<alpha> q \\<succ> eval_poly \\<alpha> p2 * eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>subsection \\<open>Degree of polynomials\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>definition monom_list_degree :: \"'v monom_list \\<Rightarrow> nat\" where \n  \"monom_list_degree xps \\<equiv> sum_list (map snd xps)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lift_definition monom_degree :: \"'v :: linorder monom \\<Rightarrow> nat\" is monom_list_degree<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition poly_degree :: \"(_,'a) poly \\<Rightarrow> nat\" where\n  \"poly_degree p \\<equiv> max_list (map (\\<lambda> (m,c). monom_degree m) p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_coeff_sum :: \"('v,'a :: ordered_ab_semigroup) poly \\<Rightarrow> 'a\" where\n  \"poly_coeff_sum p \\<equiv> sum_list (map (\\<lambda> mc. max 0 (snd mc)) p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma monom_list_degree: \"eval_monom_list (\\<lambda> _. x) m = x ^ monom_list_degree m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ monom_list_degree m<\\STATESEP>unfolding monom_list_degree_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)<\\STATESEP>proof (induct m)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))<\\STATESEP>case (Cons mc m)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. \\<And>a m. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m) \\<Longrightarrow> eval_monom_list (\\<lambda>_. x) (a # m) = x ^ sum_list (map snd (a # m))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\neval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) (mc # m) = x ^ sum_list (map snd (mc # m))<\\STATESEP>by (cases mc, auto simp: power_add field_simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom_list (\\<lambda>_. x) (mc # m) = x ^ sum_list (map snd (mc # m))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma monom_list_var_monom[simp]: \"monom_list (var_monom x) = [(x,1)]\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_list (var_monom x) = [(x, 1)]<\\STATESEP>by (transfer, simp)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_list_1[simp]: \"monom_list 1 = []\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. monom_list 1 = []<\\STATESEP>by (transfer, simp)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma monom_degree: \"eval_monom (\\<lambda> _. x) m = x ^ monom_degree m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom (\\<lambda>_. x) m = x ^ monom_degree m<\\STATESEP>by (transfer, rule monom_list_degree)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma poly_coeff_sum: \"poly_coeff_sum p \\<ge> 0\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> poly_coeff_sum p<\\STATESEP>unfolding poly_coeff_sum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>have \"(\\<Sum>mc\\<leftarrow>mc # p. max 0 (snd mc)) = max 0 (snd mc) + (\\<Sum>mc\\<leftarrow>p. max 0 (snd mc))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>also<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) = max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>have \"\\<dots> \\<ge> 0 + 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + (0::'a) \\<le> max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))<\\STATESEP>by (rule ge_trans[OF plus_left_mono plus_right_mono[OF Cons]], auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) + (0::'a) \\<le> max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow> (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))<\\STATESEP>finally<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_degree: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  shows \"poly_coeff_sum p * (x ^ poly_degree p) \\<ge> eval_poly (\\<lambda> _. x) p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p<\\STATESEP>proof (induct p)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\n\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []<\\STATESEP>by (simp add: ge_refl poly_degree_def poly_coeff_sum_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>from ge_trans[OF x one_ge_zero]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> x<\\STATESEP>have x0: \"x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x<\\STATESEP>.<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>have id1: \"eval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m  * c + eval_poly (\\<lambda>_. x) p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p<\\STATESEP>unfolding mc<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) ((m, c) # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p<\\STATESEP>by (simp add: monom_degree)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>have id2: \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = \n    x ^ max (monom_degree m) (poly_degree p) * (max 0 c) + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)<\\STATESEP>unfolding poly_coeff_sum_def poly_degree_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) * x ^ max_list (map (\\<lambda>(m, c). monom_degree m) (mc # p)) = x ^ max (monom_degree m) (max_list (map (\\<lambda>(m, c). monom_degree m) p)) * max (0::'a) c + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) * x ^ max (monom_degree m) (max_list (map (\\<lambda>(m, c). monom_degree m) p))<\\STATESEP>by (simp add: mc field_simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal (1 subgoal):\n 1. \\<And>a p. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow> eval_poly (\\<lambda>_. x) (a # p) \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)<\\STATESEP>show \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) \\<ge> eval_poly (\\<lambda>_. x) (mc # p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p) \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)<\\STATESEP>unfolding id1 id2<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)<\\STATESEP>proof (rule ge_trans[OF plus_left_mono plus_right_mono])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. x ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n 2. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)<\\STATESEP>show \"x ^ max (monom_degree m) (poly_degree p) * max 0 c \\<ge> x ^ monom_degree m * c\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c<\\STATESEP>by (rule ge_trans[OF times_left_mono[OF _ pow_mono_exp] times_right_mono[OF pow_ge_zero]], insert x x0, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nx ^ monom_degree m * c \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)<\\STATESEP>show \"poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p) \\<ge> eval_poly (\\<lambda>_. x) p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)<\\STATESEP>by (rule ge_trans[OF times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x]] Cons], auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly (\\<lambda>_. x) (mc # p) \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_degree_bound: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  and c: \"c \\<ge> poly_coeff_sum p\"\n  and d: \"d \\<ge> poly_degree p\"\n  shows \"c * (x ^ d) \\<ge> eval_poly (\\<lambda> _. x) p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> c * x ^ d<\\STATESEP>by (rule ge_trans[OF ge_trans[OF \n    times_left_mono[OF pow_ge_zero[OF ge_trans[OF x one_ge_zero]] c]   \n    times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x d]]] poly_degree[OF x]])<\\STATESEP>1<\\TRANSEP><\\STATESEP>subsection \\<open>Executable and sufficient criteria to compare polynomials and ensure monotonicity\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>definition poly_split :: \"('v monom) \\<Rightarrow> ('v,'a :: zero)poly \\<Rightarrow> 'a \\<times> ('v,'a)poly\" \n  where \"poly_split m p \\<equiv> case List.extract (\\<lambda> (n,_). m = n) p of None \\<Rightarrow> (0,p) | Some (p1,(_,c),p2) \\<Rightarrow> (c, p1 @ p2)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma poly_split: assumes \"poly_split m p = (c,q)\"\n  shows \"p =p (m,c) # q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q<\\STATESEP>proof (cases \"List.extract (\\<lambda> (n,_). m = n) p\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>case None<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>with assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_split m p = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None<\\STATESEP>have \"(c,q) = (0,p)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_split m p = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)<\\STATESEP>unfolding poly_split_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(case List.extract (\\<lambda>(n, uu_). m = n) p of None \\<Rightarrow> (0::'a, p) | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) = (c, q)\nList.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(c, q) = (0::'a, p)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow> p =p (m, c) # q\n 2. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. p =p (m, c) # q<\\STATESEP>unfolding eq_poly_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\np =p (m, c) # q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>case (Some res)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>obtain p1 mc p2 where \"res = (p1,mc,p2)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mc p2. res = (p1, mc, p2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nres = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>with extract_SomeE[OF Some[simplified this]]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\np = p1 @ mc # p2 \\<and> (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and> \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\nres = (p1, mc, p2)<\\STATESEP>obtain a where p: \"p = p1 @ (m,a) # p2\" and res: \"res = (p1,(m,a),p2)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\np = p1 @ mc # p2 \\<and> (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and> \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\nres = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>p = p1 @ (m, a) # p2; res = (p1, (m, a), p2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\np = p1 @ (m, a) # p2\nres = (p1, (m, a), p2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>from Some res assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\npoly_split m p = (c, q)<\\STATESEP>have c: \"c = a\" and q: \"q = p1 @ p2\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\npoly_split m p = (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2<\\STATESEP>unfolding poly_split_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nList.extract (\\<lambda>(n, uu_). m = n) p = Some res\nres = (p1, (m, a), p2)\n(case List.extract (\\<lambda>(n, uu_). m = n) p of None \\<Rightarrow> (0::'a, p) | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) = (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nc = a\nq = p1 @ p2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow> p =p (m, c) # q<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q<\\STATESEP>unfolding eq_poly_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)<\\STATESEP>by (simp add: p c q field_simps)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\np =p (m, c) # q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma poly_split_eval: assumes \"poly_split m p = (c,q)\" \n  shows \"eval_poly \\<alpha> p = (eval_monom \\<alpha> m * c) + eval_poly \\<alpha> q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q<\\STATESEP>using poly_split[OF assms]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\np =p (m, c) # q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>fun check_poly_eq :: \"('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_eq [] q = (q = [])\"\n| \"check_poly_eq ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n       None \\<Rightarrow> False\n     | Some (q1,(_,d),q2) \\<Rightarrow> c = d \\<and> check_poly_eq p (q1 @ q2))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_eq: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes chk: \"check_poly_eq p q\"\n  shows \"p =p q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p =p q<\\STATESEP>unfolding eq_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q<\\STATESEP>proof<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q<\\STATESEP>fix \\<alpha><\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q<\\STATESEP>from chk<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_eq p q<\\STATESEP>show \"eval_poly \\<alpha> p = eval_poly \\<alpha> q\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_eq p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> q<\\STATESEP>proof (induct p arbitrary: q)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_eq [] q \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncheck_poly_eq [] q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_eq [] q \\<Longrightarrow> eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_eq [] q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<alpha> q<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> [] = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>case (Cons mc p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncheck_poly_eq p ?q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> ?q\ncheck_poly_eq (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_eq p q \\<Longrightarrow> eval_poly \\<alpha> p = eval_poly \\<alpha> q; check_poly_eq (a # p) q\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>case None<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>with Cons(2)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>unfolding mc<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_eq ((m, c) # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((m, c) # p) = eval_poly \\<alpha> q<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>case (Some res)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>obtain q1 md q2 where \"res = (q1,md,q2)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>with extract_SomeE[OF Some[simplified this]]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)<\\STATESEP>obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>from Cons(2) Some mc res<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)<\\STATESEP>have rec: \"check_poly_eq p (q1 @ q2)\" and c: \"c = d\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_eq (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_eq p (q1 @ q2) &&& c = d<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ncheck_poly_eq p (q1 @ q2)\nc = d\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>from Cons(1)[OF rec]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)<\\STATESEP>have p: \"eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q<\\STATESEP>unfolding mc eval_poly.simps c p q<\\STATESEP>7<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (m, d) + eval_poly \\<alpha> (q1 @ q2) = eval_poly \\<alpha> (q1 @ (m, d) # q2)<\\STATESEP>by (simp add: ac_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> p = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>declare check_poly_eq.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun check_poly_ge :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_ge [] q = list_all (\\<lambda> (_,d). 0 \\<ge> d) q\"\n| \"check_poly_ge ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n     None \\<Rightarrow> c \\<ge> 0 \\<and> check_poly_ge p q\n   | Some (q1,(_,d),q2) \\<Rightarrow> c \\<ge> d \\<and> check_poly_ge p (q1 @ q2))\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_ge: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_ge p q \\<Longrightarrow> p \\<ge>p q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q<\\STATESEP>proof (induct p arbitrary: q)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>case Nil<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncheck_poly_ge [] q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>hence \"\\<forall> (n,d) \\<in> set q. 0 \\<ge> d\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_ge [] q\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)<\\STATESEP>using list_all_iff[of _ q]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_ge [] q\nlist_all ?P q = Ball (set q) ?P\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>hence \"[] \\<ge>p q\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q<\\STATESEP>proof (induct q)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p []\n 2. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p []\n 2. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p []<\\STATESEP>by (simp)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p []\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>case (Cons nd q)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>hence rec: \"[] \\<ge>p q\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a q. \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q; \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk> \\<Longrightarrow> [] \\<ge>p a # q<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q<\\STATESEP>proof (cases nd)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q<\\STATESEP>case (Pair n d)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nnd = (n, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q<\\STATESEP>with Cons<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\nnd = (n, d)<\\STATESEP>have ge: \"0 \\<ge> d\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>set q. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow> [] \\<ge>p q\n\\<forall>a\\<in>set (nd # q). case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\nnd = (n, d)\n\ngoal (1 subgoal):\n 1. d \\<le> (0::'a)<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nd \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q<\\STATESEP>proof (simp only: Pair, unfold poly_ge_def, intro allI impI)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>fix \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>assume pos: \"pos_assign \\<alpha>\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>have ge: \"0 \\<ge> eval_monom \\<alpha> n * d\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)<\\STATESEP>using times_right_mono[OF pos_assign_monom[OF pos, of n] ge]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> n * d \\<le> eval_monom \\<alpha> n * (0::'a)\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> n * d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>from rec[unfolded poly_ge_def] pos<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\npos_assign \\<alpha><\\STATESEP>have ge2: \"0 \\<ge> eval_poly \\<alpha> q\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> (0::'a)<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> q \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>show \"eval_poly \\<alpha> [] \\<ge> eval_poly \\<alpha> ((n,d) # q)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> n * d + eval_poly \\<alpha> q \\<le> (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p nd # q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p nd # q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n[] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>case (Cons mc p)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncheck_poly_ge p ?q \\<Longrightarrow> p \\<ge>p ?q\ncheck_poly_ge (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q. \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q; check_poly_ge (a # p) q\\<rbrakk> \\<Longrightarrow> a # p \\<ge>p q<\\STATESEP>show ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q<\\STATESEP>proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>case None<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>with Cons(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None<\\STATESEP>have rec: \"check_poly_ge p q\" and c: \"c \\<ge> 0\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c<\\STATESEP>using mc<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = None\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ncheck_poly_ge p q\n(0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>from Cons(1)[OF rec]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\np \\<ge>p q<\\STATESEP>have rec: \"p \\<ge>p q\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p q\n\ngoal (1 subgoal):\n 1. p \\<ge>p q<\\STATESEP>.<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\np \\<ge>p q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow> mc # p \\<ge>p q\n 2. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q<\\STATESEP>proof (simp only: mc, unfold poly_ge_def, intro allI impI)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>fix \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>assume pos: \"pos_assign \\<alpha>\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>have ge: \"eval_monom \\<alpha> m * c \\<ge> 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c<\\STATESEP>using times_right_mono[OF pos_assign_monom[OF pos, of m] c]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> m * (0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>from rec<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\np \\<ge>p q<\\STATESEP>have pq: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p<\\STATESEP>unfolding poly_ge_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p<\\STATESEP>using pos<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF pq]]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) + eval_poly \\<alpha> q \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>case (Some res)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>obtain q1 md q2 where \"res = (q1,md,q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2. res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases res, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>with extract_SomeE[OF Some[simplified this]]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)<\\STATESEP>obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nq = q1 @ md # q2 \\<and> fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\nres = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases md, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nq = q1 @ (m, d) # q2\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>from Cons(2) Some mc res<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)<\\STATESEP>have rec: \"check_poly_ge p (q1 @ q2)\" and c: \"c \\<ge> d\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_ge (mc # p) q\nList.extract (\\<lambda>mc. fst mc = m) q = Some res\nmc = (m, c)\nres = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_ge p (q1 @ q2) &&& d \\<le> c<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ncheck_poly_ge p (q1 @ q2)\nd \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>from Cons(1)[OF rec]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\np \\<ge>p q1 @ q2<\\STATESEP>have p: \"p \\<ge>p q1 @ q2\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. p \\<ge>p q1 @ q2<\\STATESEP>.<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. \\<And>a. List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow> mc # p \\<ge>p q<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q<\\STATESEP>proof (simp only: mc, unfold poly_ge_def, intro allI impI)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>fix \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>assume pos: \"pos_assign \\<alpha>\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>have ge: \"eval_monom \\<alpha> m * c \\<ge> eval_monom \\<alpha> m * d\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c<\\STATESEP>using times_right_mono[OF pos_assign_monom[OF pos, of m] c]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>from p<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\np \\<ge>p q1 @ q2<\\STATESEP>have ge2: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> (q1 @ q2)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p<\\STATESEP>unfolding poly_ge_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p<\\STATESEP>using pos<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\neval_monom \\<alpha> m * d + eval_poly \\<alpha> (q1 @ q2) \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)<\\STATESEP>by (simp add: q field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmc # p \\<ge>p q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>declare check_poly_ge.simps[simp del]<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_weak_mono_all :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> bool\"\nwhere \"check_poly_weak_mono_all p \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0) p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono_all p\" shows  \"poly_weak_mono_all p\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p<\\STATESEP>unfolding poly_weak_mono_all_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume fg: \"\\<forall> x. f x \\<ge> g x\"\n  and pos: \"pos_assign g\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>x. g x \\<le> f x\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>hence fg: \"\\<And> x. f x \\<ge> g x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. g x \\<le> f x\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ng ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x<\\STATESEP>have g: \"\\<And> x. g x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono_all p<\\STATESEP>have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c<\\STATESEP>unfolding check_poly_weak_mono_all_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'a) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c<\\STATESEP>by (auto simp: list_all_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x; pos_assign \\<beta>\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>thus \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>proof (induct p)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g [] \\<le> eval_poly f []<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly g [] \\<le> eval_poly f []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>hence IH: \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>proof (cases mc)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>case (Pair m c)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>with Cons<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\nmc = (m, c)<\\STATESEP>have c: \"c \\<ge> 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b. mc = (a, b) \\<Longrightarrow> eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>unfolding Pair eval_poly.simps fst_conv snd_conv<\\STATESEP>7<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p \\<le> eval_monom f m * c + eval_poly f p<\\STATESEP>proof (rule ge_trans[OF plus_left_mono[OF times_left_mono[OF c]] plus_right_mono[OF IH]])<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m<\\STATESEP>show \"eval_monom f m \\<ge> eval_monom g m\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m<\\STATESEP>by (rule eval_monom_mono(1)[OF fg g])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom g m \\<le> eval_monom f m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_weak_mono_all_pos: \n  assumes \"check_poly_weak_mono_all p\" shows  \"p \\<ge>p zero_poly\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly<\\STATESEP>unfolding zero_poly_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p []<\\STATESEP>proof (rule check_poly_ge)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. check_poly_ge p []<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono_all p<\\STATESEP>have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c<\\STATESEP>unfolding check_poly_weak_mono_all_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'b) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c<\\STATESEP>by (auto simp: list_all_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []<\\STATESEP>thus \"check_poly_ge p []\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []<\\STATESEP>by (induct p, simp add: check_poly_ge.simps,  clarify, auto simp: check_poly_ge.simps extract_Nil_code)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncheck_poly_ge p []\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition check_poly_weak_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_discrete p v \\<equiv> check_poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_weak_mono_and_pos :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_and_pos discrete p \\<equiv> \n            if discrete then list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p) \\<and> eval_poly (\\<lambda> w. 0) p \\<ge>  0\n                        else check_poly_weak_mono_all p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_weak_anti_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_discrete p v \\<equiv> check_poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>context poly_order_carrier\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_weak_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_mono_discrete p v\"\n  shows \"poly_weak_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v<\\STATESEP>unfolding poly_weak_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from fgw<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w<\\STATESEP>have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from assms check_poly_ge<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ndiscrete\ncheck_poly_weak_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q<\\STATESEP>have ge: \"poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_ge ?p1 p\")<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_weak_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p<\\STATESEP>unfolding check_poly_weak_mono_discrete_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_ge (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) p\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from discrete[OF \\<open>discrete\\<close> v]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)<\\STATESEP>obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>show \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>proof (cases k')<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>case 0<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>fix x<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have \"f x = g x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f x = g x<\\STATESEP>using id 0 w<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x<\\STATESEP>by (cases \"x = v\", auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>hence \"f = g\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf = g\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>using ge_refl<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf = g\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>case (Suc k)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>with id<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k<\\STATESEP>have \"f v = (((+) 1)^^(Suc k))  (g v)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>with w gass<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)<\\STATESEP>show \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>proof (induct k arbitrary: f g rule: less_induct)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>case (less k)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>proof (cases k)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>case 0<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>with less<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0<\\STATESEP>have id0: \"f v = 1 + g v\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have id1: \"eval_poly f p = eval_poly g ?p1\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>proof (rule eval_poly_subst)<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"<\\STATESEP>10<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>proof (cases \"w = v\")<\\STATESEP>11<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case True<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: True id0 zero_poly_def)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>next<\\STATESEP>12<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case False<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>with less<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v<\\STATESEP>have \"f w = g w\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w<\\STATESEP>by simp<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>thus ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: False)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have \"eval_poly g ?p1 \\<ge> eval_poly g p\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>using ge less<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p \\<ge>p p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>unfolding poly_ge_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>with id1<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g p \\<le> eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>case (Suc kk)<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have \"(1 :: 'a) + g v \\<ge> 1 + 0\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v<\\STATESEP>by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>also<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have \"1 + (0 :: 'a) = 1\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>also<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have \"\\<dots> \\<ge> 0\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)<\\STATESEP>by (rule one_ge_zero)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>finally<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v<\\STATESEP>have g'pos: \"pos_assign g'\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>using less(3)<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>unfolding pos_assign_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x<\\STATESEP>by (simp add: g')<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>{<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>hence \"f w = g' w\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w<\\STATESEP>unfolding g'<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)<\\STATESEP>by (simp add: less)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>}<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>note w = this<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>from Suc<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have kk: \"kk < k\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>from less(1)[OF kk w g'pos] eq<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>have rec1: \"eval_poly f p \\<ge> eval_poly g' p\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly f p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>{<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>hence \"g' w = g w\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w<\\STATESEP>unfolding g'<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>}<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>note w = this<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>from Suc<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have z: \"0 < k\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>from less(1)[OF z w less(3)] g'<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)<\\STATESEP>have rec2: \"eval_poly g' p \\<ge> eval_poly g p\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g' p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>by (rule ge_trans[OF rec1 rec2])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_weak_anti_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_anti_mono_discrete p v\"\n  shows \"poly_weak_anti_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v<\\STATESEP>unfolding poly_weak_anti_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>from fgw<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w<\\STATESEP>have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>from assms check_poly_ge<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ndiscrete\ncheck_poly_weak_anti_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q<\\STATESEP>have ge: \"poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\" (is \"poly_ge p ?p1\")<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_weak_anti_mono_discrete p v\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p<\\STATESEP>unfolding check_poly_weak_anti_mono_discrete_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_ge p (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\ncheck_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\np \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>from discrete[OF \\<open>discrete\\<close> v]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)<\\STATESEP>obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>show \"eval_poly g p \\<ge> eval_poly f p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>proof (cases k')<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>case 0<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>fix x<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have \"f x = g x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f x = g x<\\STATESEP>using id 0 w<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x<\\STATESEP>by (cases \"x = v\", auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>hence \"f = g\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g<\\STATESEP>..<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf = g\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>using ge_refl<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf = g\n?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>case (Suc k)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>with id<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k<\\STATESEP>have \"f v = (((+) 1)^^(Suc k))  (g v)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>with w gass<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)<\\STATESEP>show \"eval_poly g p \\<ge> eval_poly f p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>proof (induct k arbitrary: f g rule: less_induct)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>case (less k)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>show ?case<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>proof (cases k)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>case 0<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>with less<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0<\\STATESEP>have id0: \"f v = 1 + g v\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have id1: \"eval_poly f p = eval_poly g ?p1\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>proof (rule eval_poly_subst)<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"<\\STATESEP>10<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>proof (cases \"w = v\")<\\STATESEP>11<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case True<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: True id0 zero_poly_def)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>next<\\STATESEP>12<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case False<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>with less<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v<\\STATESEP>have \"f w = g w\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w<\\STATESEP>by simp<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>thus ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: False)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have \"eval_poly g p \\<ge> eval_poly g ?p1\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p<\\STATESEP>using ge less<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p<\\STATESEP>unfolding poly_ge_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly \\<alpha> p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>with id1<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>case (Suc kk)<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have \"(1 :: 'a) + g v \\<ge> 1 + 0\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v<\\STATESEP>by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>also<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have \"(1 :: 'a) + 0 = 1\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>also<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have \"\\<dots> \\<ge> 0\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)<\\STATESEP>by (rule one_ge_zero)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>finally<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v<\\STATESEP>have g'pos: \"pos_assign g'\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>using less(3)<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>unfolding pos_assign_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x<\\STATESEP>by (simp add: g')<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>{<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>hence \"f w = g' w\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w<\\STATESEP>unfolding g'<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)<\\STATESEP>by (simp add: less)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>}<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>note w = this<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>from Suc<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have kk: \"kk < k\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>from less(1)[OF kk w g'pos] eq<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>have rec1: \"eval_poly g' p \\<ge> eval_poly f p\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g' p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>{<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>fix w<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>hence \"g' w = g w\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w<\\STATESEP>unfolding g'<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>}<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>note w = this<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>from Suc<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have z: \"0 < k\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>from less(1)[OF z w less(3)] g'<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)<\\STATESEP>have rec2: \"eval_poly g p \\<ge> eval_poly g' p\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly g p<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly g' p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>by (rule ge_trans[OF rec2 rec1])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_weak_mono_and_pos: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_weak_mono_all p \\<and> (p \\<ge>p zero_poly)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>proof (cases discrete)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> discrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>with assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono_and_pos discrete p\n\\<not> discrete<\\STATESEP>have c: \"check_poly_weak_mono_all p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono_and_pos discrete p\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p<\\STATESEP>unfolding check_poly_weak_mono_and_pos_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nif discrete then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and> (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p else check_poly_weak_mono_all p\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncheck_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>from check_poly_weak_mono_all[OF c] check_poly_weak_mono_all_pos[OF c]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_weak_mono_all p\np \\<ge>p zero_poly<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_weak_mono_all p\np \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ndiscrete\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>with assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono_and_pos discrete p\ndiscrete<\\STATESEP>have c: \"list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p)\" and g: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono_and_pos discrete p\ndiscrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&& (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p<\\STATESEP>unfolding check_poly_weak_mono_and_pos_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nif discrete then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and> (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p else check_poly_weak_mono_all p\ndiscrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&& (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlist_all (check_poly_weak_mono_discrete p) (poly_vars_list p)\n(0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>have m: \"poly_weak_mono_all p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p<\\STATESEP>proof (rule poly_weak_mono)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>fix v :: 'v<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>assume v: \"v \\<in> poly_vars p\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>show \"poly_weak_mono p v\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v<\\STATESEP>by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono p v\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>have m': \"poly_weak_mono_all  p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p<\\STATESEP>proof (rule poly_weak_mono)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>fix v :: 'v<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>assume v: \"v \\<in> poly_vars p\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nv \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>show \"poly_weak_mono p v\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v<\\STATESEP>by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono p v\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow> poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>from poly_weak_mono_all_pos[OF g m'] m<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\np \\<ge>p zero_poly\npoly_weak_mono_all p<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\np \\<ge>p zero_poly\npoly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_weak_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono p v \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0 \\<or> v \\<notin> monom_vars m) p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono p v\" shows  \"poly_weak_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v<\\STATESEP>unfolding poly_weak_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x<\\STATESEP>have g: \"\\<And> x. g x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono p v<\\STATESEP>have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0 \\<or> v \\<notin> monom_vars m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m<\\STATESEP>unfolding check_poly_weak_mono_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m<\\STATESEP>by (auto simp: list_all_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p<\\STATESEP>thus \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>proof (induct p)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>hence IH: \"eval_poly f p \\<ge> eval_poly g p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>with Cons<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)<\\STATESEP>have c: \"c \\<ge> 0 \\<or> v \\<notin> monom_vars m\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)<\\STATESEP>unfolding mc eval_poly.simps fst_conv snd_conv<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p \\<le> eval_monom f m * c + eval_poly f p<\\STATESEP>proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>from c<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m<\\STATESEP>show \"eval_monom f m * c \\<ge> eval_monom g m * c\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>proof<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>assume c: \"c \\<ge> 0\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>proof (rule times_left_mono[OF c], rule eval_monom_mono(1)[OF _ g])<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x<\\STATESEP>fix x<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x<\\STATESEP>show \"f x \\<ge> g x\"<\\STATESEP>10<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x<\\STATESEP>using ge fg[of x]<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\ng v \\<le> f v\nv \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x<\\STATESEP>by (cases \"x = v\", auto simp: ge_refl)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\ng x \\<le> f x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>assume v: \"v \\<notin> monom_vars m\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>have \"eval_monom f m = eval_monom g m\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m<\\STATESEP>by (rule monom_vars_eval_monom, insert fg v, fast)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>thus ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly g [] \\<le> eval_poly f []<\\STATESEP>qed (simp add: ge_refl)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition check_poly_weak_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_smart discrete \\<equiv> if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma (in poly_order_carrier) check_poly_weak_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>unfolding check_poly_weak_mono_smart_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono) p v \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>using check_poly_weak_mono check_poly_weak_mono_discrete<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono ?p ?v \\<Longrightarrow> poly_weak_mono ?p ?v\n\\<lbrakk>discrete; check_poly_weak_mono_discrete ?p ?v\\<rbrakk> \\<Longrightarrow> poly_weak_mono ?p ?v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono) p v \\<Longrightarrow> poly_weak_mono p v<\\STATESEP>by (cases discrete, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition check_poly_weak_anti_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono p v \\<equiv> list_all (\\<lambda> (m,c). 0 \\<ge> c \\<or> v \\<notin> monom_vars m) p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_poly_weak_anti_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_anti_mono p v\" shows  \"poly_weak_anti_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v<\\STATESEP>unfolding poly_weak_anti_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<beta> v \\<le> \\<alpha> v \\<longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\npos_assign g\ng v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x<\\STATESEP>have g: \"\\<And> x. g x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_anti_mono p v<\\STATESEP>have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> 0 \\<ge> c \\<or> v \\<notin> monom_vars m\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m<\\STATESEP>unfolding check_poly_weak_anti_mono_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlist_all (\\<lambda>(m, c). c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m<\\STATESEP>by (auto simp: list_all_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set p \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p<\\STATESEP>thus \"eval_poly g p \\<ge> eval_poly f p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set p \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>proof (induct p)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c. (m, c) \\<in> set [] \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(?m, ?c) \\<in> set [] \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<le> eval_poly g []<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly f [] \\<le> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>hence IH: \"eval_poly g p \\<ge> eval_poly f p\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>with Cons<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)<\\STATESEP>have c: \"0 \\<ge> c \\<or> v \\<notin> monom_vars m\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n(?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>(\\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p; \\<And>m c. (m, c) \\<in> set (a # p) \\<Longrightarrow> c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<le> eval_poly g (mc # p)<\\STATESEP>unfolding mc eval_poly.simps fst_conv snd_conv<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c + eval_poly f p \\<le> eval_monom g m * c + eval_poly g p<\\STATESEP>proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>from c<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m<\\STATESEP>show \"eval_monom g m * c \\<ge> eval_monom f m * c\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nc \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>proof<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>assume c: \"0 \\<ge> c\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nc \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>proof (rule times_left_anti_mono[OF eval_monom_mono(1)[OF _ g] c])<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x<\\STATESEP>fix x<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x<\\STATESEP>show \"f x \\<ge> g x\"<\\STATESEP>10<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x<\\STATESEP>using ge fg[of x]<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\ng v \\<le> f v\nv \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x<\\STATESEP>by (cases \"x = v\", auto simp: ge_refl)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\ng x \\<le> f x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>assume v: \"v \\<notin> monom_vars m\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>have \"eval_monom f m = eval_monom g m\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m<\\STATESEP>by (rule monom_vars_eval_monom, insert fg v, fast)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow> eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>thus ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\neval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c<\\STATESEP>by (simp add: ge_refl)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly f (mc # p) \\<le> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition check_poly_weak_anti_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_smart discrete \\<equiv> if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma (in poly_order_carrier) check_poly_weak_anti_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v<\\STATESEP>unfolding check_poly_weak_anti_mono_smart_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono) p v \\<Longrightarrow> poly_weak_anti_mono p v<\\STATESEP>using check_poly_weak_anti_mono[of p v] check_poly_weak_anti_mono_discrete[of p v]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_anti_mono p v \\<Longrightarrow> poly_weak_anti_mono p v\n\\<lbrakk>discrete; check_poly_weak_anti_mono_discrete p v\\<rbrakk> \\<Longrightarrow> poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono) p v \\<Longrightarrow> poly_weak_anti_mono p v<\\STATESEP>by (cases discrete, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition check_poly_gt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\"\nwhere \"check_poly_gt gt p q \\<equiv> let (a1,p1) = poly_split 1 p; (b1,q1) = poly_split 1 q in gt a1 b1 \\<and> check_poly_ge p1 q1\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>fun univariate_power_list :: \"'v \\<Rightarrow> 'v monom_list \\<Rightarrow> nat option\" where\n  \"univariate_power_list x [(y,n)] = (if x = y then Some n else None)\" \n| \"univariate_power_list _ _ = None\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma univariate_power_list: assumes \"monom_inv m\" \"univariate_power_list x m = Some n\" \n  shows \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \n   \"n \\<ge> 1\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n<\\STATESEP>have m: \"m = [(x,n)]\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. m = [(x, n)]<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv m\nunivariate_power_list x m = Some n\n\ngoal (1 subgoal):\n 1. m = [(x, n)]<\\STATESEP>by (induct x m rule: univariate_power_list.induct, auto split: if_splits)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nm = [(x, n)]\n\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n<\\STATESEP>show \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\"\n    \"n \\<ge> 1\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n<\\STATESEP>using assms(1)<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nmonom_inv m\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n<\\STATESEP>unfolding m monom_inv_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>(x, n)\\<in>set [(x, n)]. 1 \\<le> n) \\<and> distinct (map fst [(x, n)]) \\<and> sorted (map fst [(x, n)])\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> [(x, n)] = \\<alpha> x ^ n &&& sum_var_list [(x, n)] = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n<\\STATESEP>by (auto simp: sum_var_list_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\neval_monom_list \\<alpha> m = \\<alpha> x ^ n\nsum_var_list m = (\\<lambda>y. if x = y then n else 0)\n1 \\<le> n\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lift_definition univariate_power :: \"'v :: linorder \\<Rightarrow> 'v monom \\<Rightarrow> nat option\" \n  is univariate_power_list<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>.<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma univariate_power: assumes \"univariate_power x m = Some n\" \n  shows \"sum_var m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom \\<alpha> m = ((\\<alpha> x)^n)\"\n   \"n \\<ge> 1\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. sum_var m = (\\<lambda>y. if x = y then n else 0) &&& eval_monom \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n<\\STATESEP>by (atomize(full), insert assms, transfer, auto dest: univariate_power_list)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma univariate_power_var_monom: \"univariate_power y (var_monom x) = (if x = y then Some 1 else None)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. univariate_power y (var_monom x) = (if x = y then Some 1 else None)<\\STATESEP>by (transfer, auto)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition check_monom_strict_mono :: \"bool \\<Rightarrow> 'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> bool\" where\n  \"check_monom_strict_mono pm m v \\<equiv> case univariate_power v m of\n     Some p \\<Rightarrow> pm \\<or> p = 1\n   | None \\<Rightarrow> False\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_strict_mono :: \"bool \\<Rightarrow> ('v :: linorder, 'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono pm p v \\<equiv> list_ex (\\<lambda> (m,c). (c \\<ge> 1) \\<and> check_monom_strict_mono pm m v) p\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_strict_mono_discrete :: \"('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_discrete gt p v \\<equiv> check_poly_gt gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p \"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition check_poly_strict_mono_smart :: \"bool \\<Rightarrow> bool \\<Rightarrow> ('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_smart discrete pm gt p v \\<equiv> \n            if discrete then check_poly_strict_mono_discrete gt p v else check_poly_strict_mono pm p v\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>context poly_order_carrier\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma check_monom_strict_mono: fixes \\<alpha> \\<beta> :: \"('v :: linorder,'a)assign\" and v :: 'v and m :: \"'v monom\"\n  assumes check: \"check_monom_strict_mono power_mono m v\"\n  and gt: \"\\<alpha> v \\<succ> \\<beta> v\"\n  and ge: \"\\<beta> v \\<ge> 0\"\nshows \"eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>from check[unfolded check_monom_strict_mono_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncase univariate_power v m of None \\<Rightarrow> False | Some p \\<Rightarrow> power_mono \\<or> p = 1<\\STATESEP>obtain n where\n    uni: \"univariate_power v m = Some n\" and 1: \"\\<not> power_mono \\<Longrightarrow> n = 1\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncase univariate_power v m of None \\<Rightarrow> False | Some p \\<Rightarrow> power_mono \\<or> p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>n. \\<lbrakk>univariate_power v m = Some n; \\<not> power_mono \\<Longrightarrow> n = 1\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (auto split: option.splits)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nunivariate_power v m = Some n\n\\<not> power_mono \\<Longrightarrow> n = 1\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>from univariate_power[OF uni]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsum_var m = (\\<lambda>y. if v = y then n else 0)\neval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n1 \\<le> n<\\STATESEP>have n1: \"n \\<ge> 1\" and eval: \"eval_monom a m = a v ^ n\" for a :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsum_var m = (\\<lambda>y. if v = y then n else 0)\neval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n1 \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n &&& eval_monom a m = a v ^ n<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n1 \\<le> n\neval_monom ?a3 m = ?a3 v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>proof (cases power_mono)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<not> power_mono\n\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>with gt 1[OF this]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>unfolding eval<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<alpha> v \\<succ> \\<beta> v\nn = 1\n\\<not> power_mono\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npower_mono\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow> eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>from power_mono[OF True gt ge n1]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m<\\STATESEP>unfolding eval<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n<\\STATESEP>.<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_strict_mono: \n  assumes check1: \"check_poly_strict_mono power_mono p v\"\n  and check2: \"check_poly_weak_mono_all p\"\n  shows \"poly_strict_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v<\\STATESEP>unfolding poly_strict_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>fix f g :: \"('b,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and pos: \"pos_assign g\"\n  and fgv: \"f v \\<succ> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\nf v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from pos[unfolded pos_assign_def]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x. (0::'a) \\<le> g x<\\STATESEP>have g: \"\\<And> x. g x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>fix w<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>have \"f w \\<ge> g w\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g w \\<le> f w<\\STATESEP>proof (cases \"v = w\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w<\\STATESEP>with fgw ge_refl<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n?x \\<le> ?x\nv \\<noteq> w<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n?x \\<le> ?x\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ng w \\<le> f w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nv = w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w<\\STATESEP>from fgv[unfolded True]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nf w \\<succ> g w<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nf w \\<succ> g w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w<\\STATESEP>by (rule gt_imp_ge)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ng w \\<le> f w\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ng w \\<le> f w\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ng ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>note fgw2 = this<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ng ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>let ?e = \"eval_poly\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>show \"?e f p \\<succ> ?e g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>using check1[unfolded check_poly_strict_mono_def, simplified list_ex_iff]\n      check2[unfolded check_poly_weak_mono_all_def, simplified list_all_iff, THEN bspec]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x \\<in> set p \\<Longrightarrow> case ?x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>proof (induct p)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set []. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set [] \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>case Nil<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>set []. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set [] \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set []. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set [] \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>thus ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>a\\<in>set []. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set [] \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<succ> eval_poly g []<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly f [] \\<succ> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>case (Cons mc p)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>\\<exists>a\\<in>set p. case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>obtain m c where mc: \"mc = (m,c)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases mc, auto)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p. \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<exists>(m, c)\\<in>set (a # p). (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v; \\<And>x. x \\<in> set (a # p) \\<Longrightarrow> case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk> \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>proof (cases \"c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>hence c: \"c \\<ge> 1\" and m: \"check_monom_strict_mono power_mono m v\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> c &&& check_monom_strict_mono power_mono m v<\\STATESEP>by blast+<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(1::'a) \\<le> c\ncheck_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from times_gt_mono[OF check_monom_strict_mono[OF m, of f g, OF fgv g] c]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_monom f m * c \\<succ> eval_monom g m * c<\\STATESEP>have gt: \"eval_monom f m * c \\<succ> eval_monom g m * c\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<succ> eval_monom g m * c<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from Cons(3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a<\\STATESEP>have \"check_poly_weak_mono_all p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p<\\STATESEP>unfolding check_poly_weak_mono_all_def list_all_iff<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>(m, y)\\<in>set p. (0::'a) \\<le> y<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ncheck_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from check_poly_weak_mono_all[OF this, unfolded poly_weak_mono_all_def, rule_format, OF fgw2 pos]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_poly g p \\<le> eval_poly f p<\\STATESEP>have ge: \"?e f p \\<ge> ?e g p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from compat2[OF plus_gt_left_mono[OF gt] plus_right_mono[OF ge]]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>unfolding mc<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\neval_monom f m * c + eval_poly f p \\<succ> eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f ((m, c) # p) \\<succ> eval_poly g ((m, c) # p)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>with Cons(2) mc<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\nmc = (m, c)\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)<\\STATESEP>have \"\\<exists> mc \\<in> set p. (\\<lambda> (m,c). c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v) mc\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>a\\<in>set (mc # p). case a of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\nmc = (m, c)\n\\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<exists>mc\\<in>set p. case mc of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<exists>mc\\<in>set p. case mc of (m, c) \\<Rightarrow> (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from Cons(1)[OF this] Cons(3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(\\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a<\\STATESEP>have rec: \"?e f p \\<succ> ?e g p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(\\<And>x. x \\<in> set p \\<Longrightarrow> case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from Cons(3) mc<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\nmc = (m, c)<\\STATESEP>have c: \"c \\<ge> 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n?x4 \\<in> set (mc # p) \\<Longrightarrow> case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\nmc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from times_left_mono[OF c eval_monom_mono(1)[OF fgw2 g]]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c<\\STATESEP>have ge: \"eval_monom f m * c \\<ge> eval_monom g m * c\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c<\\STATESEP>.<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v) \\<Longrightarrow> eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>from compat2[OF plus_gt_left_mono[OF rec] plus_right_mono[OF ge]]<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_poly f p + eval_monom f m * c \\<succ> eval_poly g p + eval_monom g m * c<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_poly f p + eval_monom f m * c \\<succ> eval_poly g p + eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)<\\STATESEP>by (simp add: mc field_simps)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_gt: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_gt gt p q\" shows \"p >p q\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>obtain a1 p1 where p: \"poly_split 1 p = (a1,p1)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 p1. poly_split 1 p = (a1, p1) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_split 1 p = (a1, p1)\n\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>obtain b1 q1 where q: \"poly_split 1 q = (b1,q1)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b1 q1. poly_split 1 q = (b1, q1) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_split 1 q = (b1, q1)\n\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>from p q assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\ncheck_poly_gt (\\<succ>) p q<\\STATESEP>have gt: \"a1 \\<succ> b1\" and ge: \"p1 \\<ge>p q1\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\ncheck_poly_gt (\\<succ>) p q\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1<\\STATESEP>unfolding check_poly_gt_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\nlet (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1<\\STATESEP>using check_poly_ge[of p1 q1]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\npoly_split 1 p = (a1, p1)\npoly_split 1 q = (b1, q1)\nlet (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\ncheck_poly_ge p1 q1 \\<Longrightarrow> p1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\na1 \\<succ> b1\np1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. p >p q<\\STATESEP>proof (unfold poly_gt_def, intro impI allI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>fix \\<alpha> :: \"('v,'a)assign\"<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>assume \"pos_assign \\<alpha>\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>with ge<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\np1 \\<ge>p q1\npos_assign \\<alpha><\\STATESEP>have ge: \"eval_poly \\<alpha> p1 \\<ge> eval_poly \\<alpha> q1\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\np1 \\<ge>p q1\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1<\\STATESEP>unfolding poly_ge_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\npos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>from plus_gt_left_mono[OF gt] compat[OF plus_left_mono[OF ge]]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\na1 + ?z \\<succ> b1 + ?z\neval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow> eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z<\\STATESEP>have gt: \"a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na1 + ?z \\<succ> b1 + ?z\neval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow> eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z\n\ngoal (1 subgoal):\n 1. a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1<\\STATESEP>by (force simp: field_simps)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>show \"eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q<\\STATESEP>by (simp add: poly_split[OF p, unfolded eq_poly_def] poly_split[OF q, unfolded eq_poly_def] gt)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\neval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\np >p q\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_strict_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_strict_mono_discrete gt p v\"\n  shows \"poly_strict_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v<\\STATESEP>unfolding poly_strict_mono_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>. (\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>proof (intro allI impI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>fix f g :: \"('v,'a)assign\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<succ> g v\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\npos_assign g\nf v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from gass<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\npos_assign g<\\STATESEP>have g: \"\\<And> x. g x \\<ge> 0\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\npos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>unfolding pos_assign_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x<\\STATESEP>..<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from fgw<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w<\\STATESEP>have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from assms check_poly_gt<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ndiscrete\ncheck_poly_strict_mono_discrete (\\<succ>) p v\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q<\\STATESEP>have gt: \"poly_gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_gt ?p1 p\")<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_strict_mono_discrete (\\<succ>) p v\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p<\\STATESEP>unfolding check_poly_strict_mono_discrete_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ndiscrete\ncheck_poly_gt (\\<succ>) (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) p\ncheck_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from discrete[OF \\<open>discrete\\<close> gt_imp_ge[OF v]]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)<\\STATESEP>obtain k' where id: \"f v = (((+) 1)^^k') (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>assume \"k' = 0\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>from v[unfolded id this]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n((+) (1::'a) ^^ 0) (g v) \\<succ> g v<\\STATESEP>have \"g v \\<succ> g v\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n((+) (1::'a) ^^ 0) (g v) \\<succ> g v\n\ngoal (1 subgoal):\n 1. g v \\<succ> g v<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>hence False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ng v \\<succ> g v\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>using SN g[of v]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng v \\<succ> g v\nSN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n(0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>unfolding SN_defs<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng v \\<succ> g v\n\\<nexists>f. f 0 \\<in> UNIV \\<and> (\\<forall>i. (f i, f (Suc i)) \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n(0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nk' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>with id<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0 \\<Longrightarrow> False<\\STATESEP>obtain k where id: \"f v = (((+) 1)^^(Suc k)) (g v)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ k') (g v)\nk' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>k. f v = ((+) (1::'a) ^^ Suc k) (g v) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (cases k', auto)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>. \\<lbrakk>\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x; pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk> \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p<\\STATESEP>with w gass<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)<\\STATESEP>show \"eval_poly f p \\<succ> eval_poly g p\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>proof (induct k arbitrary: f g rule: less_induct)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>case (less k)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g. \\<lbrakk>\\<And>y f g. \\<lbrakk>y < x; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p; \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g; f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>show ?case<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>proof (cases k)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>case 0<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nk = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>with less(4)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0<\\STATESEP>have id0: \"f v = 1 + g v\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nk = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have id1: \"eval_poly f p = eval_poly g ?p1\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)<\\STATESEP>proof (rule eval_poly_subst)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>fix w<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>proof (cases \"w = v\")<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case True<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nw = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>show ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: True id0 zero_poly_def)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>next<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>case False<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>with less<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v<\\STATESEP>have \"f w = g w\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\nw \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w<\\STATESEP>by simp<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nf w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>thus ?thesis<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nf w = g w\n\ngoal (1 subgoal):\n 1. f w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))<\\STATESEP>by (simp add: False)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nf w = eval_poly g (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have \"eval_poly g ?p1 \\<succ> eval_poly g p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p<\\STATESEP>using gt less<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\npoly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p >p p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p<\\STATESEP>unfolding poly_gt_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>\\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly \\<alpha> p\n\\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w; pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk> \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\nv \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\npos_assign g\nf v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>with id1<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\neval_poly f p = eval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p)\neval_poly g (poly_subst (\\<lambda>w. poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w)) p) \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>case (Suc kk)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'. g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have \"(1 :: 'a) + g v \\<ge> 1 + 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v<\\STATESEP>by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have \"(1 :: 'a) + 0 = 1\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>also<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have \"\\<dots> \\<ge> 0\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)<\\STATESEP>by (rule one_ge_zero)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>finally<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(0::'a) \\<le> (1::'a) + g v<\\STATESEP>have g'pos: \"pos_assign g'\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>using less(3)<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\npos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'<\\STATESEP>unfolding pos_assign_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(0::'a) \\<le> (1::'a) + g v\n\\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x<\\STATESEP>by (simp add: g')<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\npos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>fix w<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>hence \"f w = g' w\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w<\\STATESEP>unfolding g'<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)<\\STATESEP>by (simp add: less)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>note w = this<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>from Suc<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have kk: \"kk < k\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nkk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>from less(1)[OF kk w g'pos] eq<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)<\\STATESEP>have rec1: \"eval_poly f p \\<succ> eval_poly g' p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk> \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\nf v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g' p<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>fix w<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>assume \"v \\<noteq> w\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>hence \"g' w = g w\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w<\\STATESEP>unfolding g'<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nv \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ng' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>note w = this<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nv \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>from Suc<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nk = Suc kk<\\STATESEP>have z: \"0 < k\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nk = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>from less(1)[OF z w less(3)] g'<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)<\\STATESEP>have rec2: \"eval_poly g' p \\<succ> eval_poly g p\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w; g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk> \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\ng' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<succ> eval_poly g p<\\STATESEP>by simp<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly g' p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p<\\STATESEP>by (rule gt_trans[OF rec1 rec2])<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\neval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma check_poly_strict_mono_smart: \n  assumes check1: \"check_poly_strict_mono_smart discrete power_mono gt p v\"\n  and check2: \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_strict_mono p v\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v<\\STATESEP>proof (cases discrete)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ndiscrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v<\\STATESEP>with check1[unfolded check_poly_strict_mono_smart_def]\n    check_poly_strict_mono_discrete[OF True]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nif discrete then check_poly_strict_mono_discrete (\\<succ>) p v else check_poly_strict_mono power_mono p v\ncheck_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow> poly_strict_mono ?p ?v\ndiscrete<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nif discrete then check_poly_strict_mono_discrete (\\<succ>) p v else check_poly_strict_mono power_mono p v\ncheck_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow> poly_strict_mono ?p ?v\ndiscrete\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_strict_mono p v\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> discrete\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v<\\STATESEP>from check_poly_strict_mono[OF check1[unfolded check_poly_strict_mono_smart_def, simplified False, simplified]]\n    check2[unfolded check_poly_weak_mono_and_pos_def, simplified False, simplified]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncheck_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\ncheck_poly_weak_mono_all p<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncheck_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\ncheck_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\npoly_strict_mono p v\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP>",
    "theory_file_path": "/home/ubuntu/afp-2022-12-06/thys/Polynomials/Polynomials.thy",
    "working_directory": "/home/ubuntu/afp-2022-12-06/thys/Polynomials"
}