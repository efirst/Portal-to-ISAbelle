{
    "def_names": [
        "definition osum :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a + 'b) rel\"  (infixr \"+o\" 70)\nwhere\n  \"r +o r' = map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union>\n     {(Inl a, Inr a') | a a' . a \\<in> Field r \\<and> a' \\<in> Field r'}\"",
        "definition oprod :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a \\<times> 'b) rel\"  (infixr \"*o\" 80)\nwhere \"r *o r' = {((x1, y1), (x2, y2)).\n  (((y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r) \\<or>\n   ((y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r))}\"",
        "definition \"support z A f = {x \\<in> A. f x \\<noteq> z}\"",
        "definition fin_support where\n  \"fin_support z A = {f. finite (support z A f)}\"",
        "definition isMaxim :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"isMaxim A b \\<equiv> b \\<in> A \\<and> (\\<forall>a \\<in> A. (a,b) \\<in> r)\"",
        "definition maxim :: \"'a set \\<Rightarrow> 'a\"\nwhere \"maxim A \\<equiv> THE b. isMaxim A b\"",
        "definition \"max_fun_diff f g \\<equiv> maxim ({a \\<in> Field r. f a \\<noteq> g a})\"",
        "definition \"FinFunc r s = Func (Field s) (Field r) \\<inter> fin_support (zero r) (Field s)\"",
        "definition oexp where\n  \"oexp = {(f, g) . f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and>\n    ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\"",
        "definition \"const = (\\<lambda>x. if x \\<in> Field s then r.zero else undefined)\"",
        "definition \"ozero = {}\"",
        "definition \"oone = {((),())}\"",
        "definition \"rev_curr f b = (if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined)\""
    ],
    "problem_names": [
        "lemma Field_osum: \"Field(r +o r') = Inl ` Field r \\<union> Inr ` Field r'\"",
        "lemma osum_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r')\"",
        "lemma osum_trans:\nassumes TRANS: \"trans r\" and TRANS': \"trans r'\"\nshows \"trans (r +o r')\"",
        "lemma osum_Preorder: \"\\<lbrakk>Preorder r; Preorder r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r')\"",
        "lemma osum_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r +o r')\"",
        "lemma osum_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r')\"",
        "lemma osum_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r +o r')\"",
        "lemma osum_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r +o r')\"",
        "lemma osum_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r +o r')\"",
        "lemma osum_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r +o r') - Id \\<le> (r - Id) +o (r' - Id)\"",
        "lemma osum_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (Inl ` Field r \\<times> Inr ` Field r') \\<union> (map_prod Inr Inr ` (r' - Id))\"",
        "lemma osum_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (map_prod Inl Inl ` (r - Id)) \\<union> (Inl ` Field r \\<times> Inr ` Field r')\"",
        "lemma osum_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r +o r') - Id)\"",
        "lemma osum_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r +o r')\"",
        "lemma osum_embedL:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\n  shows \"embed r (r +o r') Inl\"",
        "lemma dir_image_alt: \"dir_image r f = map_prod f f ` r\"",
        "lemma map_prod_ordIso: \"\\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> map_prod f f ` r =o r\"",
        "lemma Field_oprod: \"Field (r *o r') = Field r \\<times> Field r'\"",
        "lemma oprod_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r')\"",
        "lemma oprod_trans:\n  assumes \"trans r\" \"trans r'\" \"antisym r\" \"antisym r'\"\n  shows \"trans (r *o r')\"",
        "lemma oprod_Preorder: \"\\<lbrakk>Preorder r; Preorder r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r')\"",
        "lemma oprod_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r *o r')\"",
        "lemma oprod_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r')\"",
        "lemma oprod_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r *o r')\"",
        "lemma oprod_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r *o r')\"",
        "lemma oprod_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r *o r')\"",
        "lemma oprod_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r *o r') - Id \\<le> (r - Id) *o (r' - Id)\"",
        "lemma oprod_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x,y1), (x,y2)). x \\<in> Field r \\<and> (y1, y2) \\<in> (r' - Id)}\"",
        "lemma wf_extend_oprod1:\n  assumes \"wf r\"\n  shows \"wf {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"",
        "lemma oprod_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x1,y), (x2,y)). (x1, x2) \\<in> (r - Id) \\<and> y \\<in> Field r'}\"",
        "lemma wf_extend_oprod2:\n  assumes \"wf r\"\n  shows \"wf {((x1,y), (x2,y)) . (x1, x2) \\<in> r \\<and> y \\<in> A}\"",
        "lemma oprod_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r *o r') - Id)\"",
        "lemma oprod_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r *o r')\"",
        "lemma oprod_embed:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\" and \"r' \\<noteq> {}\"\n  shows \"embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\" (is \"embed _ _ ?f\")",
        "lemma support_Un[simp]: \"support z (A \\<union> B) f = support z A f \\<union> support z B f\"",
        "lemma support_upd[simp]: \"support z A (f(x := z)) = support z A f - {x}\"",
        "lemma support_upd_subset[simp]: \"support z A (f(x := y)) \\<subseteq> support z A f \\<union> {x}\"",
        "lemma fun_unequal_in_support:\n  assumes \"f \\<noteq> g\" \"f \\<in> Func A B\" \"g \\<in> Func A C\"\n  shows \"(support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\" (is \"?L \\<inter> ?R \\<noteq> {}\")",
        "lemma finite_support: \"f \\<in> fin_support z A \\<Longrightarrow> finite (support z A f)\"",
        "lemma fin_support_Field_osum:\n  \"f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<longleftrightarrow>\n  (f o Inl) \\<in> fin_support z A \\<and> (f o Inr) \\<in> fin_support z B\" (is \"?L \\<longleftrightarrow> ?R1 \\<and> ?R2\")",
        "lemma Func_upd: \"\\<lbrakk>f \\<in> Func A B; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> Func A B\"",
        "lemma isMaxim_unique[intro]: \"\\<lbrakk>isMaxim A x; isMaxim A y\\<rbrakk> \\<Longrightarrow> x = y\"",
        "lemma maxim_isMaxim: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (maxim A)\"",
        "lemma maxim_in: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A\"",
        "lemma maxim_greatest: \"\\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r\"",
        "lemma isMaxim_zero: \"isMaxim A zero \\<Longrightarrow> A = {zero}\"",
        "lemma maxim_insert:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"x \\<in> Field r\"\n  shows \"maxim (insert x A) = max2 x (maxim A)\"",
        "lemma maxim_Un:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"finite B\" \"B \\<noteq> {}\" \"B \\<subseteq> Field r\"\n  shows   \"maxim (A \\<union> B) = max2 (maxim A) (maxim B)\"",
        "lemma maxim_insert_zero:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\"\n  shows \"maxim (insert zero A) = maxim A\"",
        "lemma maxim_equality: \"isMaxim A x \\<Longrightarrow> maxim A = x\"",
        "lemma maxim_singleton:\n  \"x \\<in> Field r \\<Longrightarrow> maxim {x} = x\"",
        "lemma maxim_Int: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r; maxim A \\<in> B\\<rbrakk> \\<Longrightarrow> maxim (A \\<inter> B) = maxim A\"",
        "lemma maxim_mono: \"\\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r\"",
        "lemma max_fun_diff_commute: \"max_fun_diff f g = max_fun_diff g f\"",
        "lemma zero_under: \"x \\<in> Field r \\<Longrightarrow> zero \\<in> under x\"",
        "lemma FinFuncD: \"\\<lbrakk>f \\<in> FinFunc r s; x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r\"",
        "lemma fun_diff_alt: \"{a \\<in> Field s. f a \\<noteq> g a} = (SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}\"",
        "lemma max_fun_diff_alt:\n  \"s.max_fun_diff f g = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})\"",
        "lemma isMaxim_max_fun_diff: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\"",
        "lemma max_fun_diff_in: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\"",
        "lemma max_fun_diff_max: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow>\n  (x, s.max_fun_diff f g) \\<in> s\"",
        "lemma max_fun_diff:\n  \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  (\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and>\n     f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b)\"",
        "lemma max_fun_diff_le_eq:\n  \"\\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow>\n  f x = g x\"",
        "lemma max_fun_diff_max2:\n  assumes ineq: \"s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow>\n    f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\" and\n    fg: \"f \\<noteq> g\" and gh: \"g \\<noteq> h\" and fh: \"f \\<noteq> h\" and\n    f: \"f \\<in> FINFUNC\" and g: \"g \\<in> FINFUNC\" and h: \"h \\<in> FINFUNC\"\n  shows \"s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\"\n    (is \"?fh = s.max2 ?fg ?gh\")",
        "lemma Field_oexp: \"Field oexp = FINFUNC\"",
        "lemma oexp_Refl: \"Refl oexp\"",
        "lemma oexp_trans: \"trans oexp\"",
        "lemma oexp_Preorder: \"Preorder oexp\"",
        "lemma oexp_antisym: \"antisym oexp\"",
        "lemma oexp_Partial_order: \"Partial_order oexp\"",
        "lemma oexp_Total: \"Total oexp\"",
        "lemma oexp_Linear_order: \"Linear_order oexp\"",
        "lemma const_in[simp]: \"x \\<in> Field s \\<Longrightarrow> const x = r.zero\"",
        "lemma const_notin[simp]: \"x \\<notin> Field s \\<Longrightarrow> const x = undefined\"",
        "lemma const_Int_Field[simp]: \"Field s \\<inter> - {x. const x = r.zero} = {}\"",
        "lemma const_FINFUNC[simp]: \"Field r \\<noteq> {} \\<Longrightarrow> const \\<in> FINFUNC\"",
        "lemma const_least:\n  assumes \"Field r \\<noteq> {}\" \"f \\<in> FINFUNC\"\n  shows \"(const, f) \\<in> oexp\"",
        "lemma support_not_const:\n  assumes \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\"",
        "lemma maxim_isMaxim_support:\n  assumes f: \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\"",
        "lemma oexp_empty2: \"Field s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"",
        "lemma oexp_empty: \"\\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}\"",
        "lemma fun_upd_FINFUNC: \"\\<lbrakk>f \\<in> FINFUNC; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> FINFUNC\"",
        "lemma fun_upd_same_oexp:\n  assumes \"(f, g) \\<in> oexp\" \"f x = g x\" \"x \\<in> Field s\" \"y \\<in> Field r\"\n  shows   \"(f(x := y), g(x := y)) \\<in> oexp\"",
        "lemma fun_upd_smaller_oexp:\n  assumes \"f \\<in> FINFUNC\" \"x \\<in> Field s\" \"y \\<in> Field r\"  \"(y, f x) \\<in> r\"\n  shows   \"(f(x := y), f) \\<in> oexp\"",
        "lemma oexp_wf_Id: \"wf (oexp - Id)\"",
        "lemma oexp_Well_order: \"Well_order oexp\"",
        "lemma zero_oexp: \"Field r \\<noteq> {} \\<Longrightarrow> o.zero = const\"",
        "lemma ozero_Well_order[simp]: \"Well_order ozero\"",
        "lemma ozero_ordIso[simp]: \"ozero =o ozero\"",
        "lemma Field_ozero[simp]: \"Field ozero = {}\"",
        "lemma iso_ozero_empty[simp]: \"r =o ozero = (r = {})\"",
        "lemma ozero_ordLeq:\nassumes \"Well_order r\"  shows \"ozero \\<le>o r\"",
        "lemma oone_Well_order[simp]: \"Well_order oone\"",
        "lemma Field_oone[simp]: \"Field oone = {()}\"",
        "lemma oone_ordIso: \"oone =o {(x,x)}\"",
        "lemma osum_ordLeqR: \"Well_order r \\<Longrightarrow> Well_order s \\<Longrightarrow> s \\<le>o r +o s\"",
        "lemma osum_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r +o t =o s +o t\" (is \"?L =o ?R\")",
        "lemma osum_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t +o r =o t +o s\" (is \"?L =o ?R\")",
        "lemma osum_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t +o r =o u +o s\"",
        "lemma Well_order_empty[simp]: \"Well_order {}\"",
        "lemma well_order_on_singleton[simp]: \"well_order_on {x} {(x, x)}\"",
        "lemma oexp_empty[simp]:\n  assumes \"Well_order r\"\n  shows \"r ^o {} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"",
        "lemma oexp_empty2[simp]:\n  assumes \"Well_order r\" \"r \\<noteq> {}\"\n  shows \"{} ^o r = {}\"",
        "lemma oprod_zero[simp]: \"{} *o r = {}\" \"r *o {} = {}\"",
        "lemma oprod_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r *o t =o s *o t\" (is \"?L =o ?R\")",
        "lemma oprod_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t *o r =o t *o s\" (is \"?L =o ?R\")",
        "lemma oprod_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t *o r =o u *o s\"",
        "lemma Field_singleton[simp]: \"Field {(z,z)} = {z}\"",
        "lemma zero_singleton[simp]: \"zero {(z,z)} = z\"",
        "lemma FinFunc_singleton: \"FinFunc {(z,z)} s = {\\<lambda>x. if x \\<in> Field s then z else undefined}\"",
        "lemma oone_ordIso_oexp:\n  assumes \"r =o oone\" and s: \"Well_order s\"\n  shows \"r ^o s =o oone\" (is \"?L =o ?R\")",
        "lemma osum_ozeroL: \"ozero +o r =o r\"",
        "lemma osum_ozeroR: \"r +o ozero =o r\"",
        "lemma osum_assoc: \"(r +o s) +o t =o r +o s +o t\" (is \"?L =o ?R\")",
        "lemma osum_monoR:\n  assumes \"s <o t\"\n  shows \"r +o s <o r +o t\" (is \"?L <o ?R\")",
        "lemma osum_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r +o t \\<le>o s +o t\"",
        "lemma oprod_ozeroL: \"ozero *o r =o ozero\"",
        "lemma oprod_ozeroR: \"r *o ozero =o ozero\"",
        "lemma oprod_ooneR: \"r *o oone =o r\" (is \"?L =o ?R\")",
        "lemma oprod_ooneL: \"oone *o r =o r\" (is \"?L =o ?R\")",
        "lemma oprod_monoR:\n  assumes \"ozero <o r\" \"s <o t\"\n  shows \"r *o s <o r *o t\" (is \"?L <o ?R\")",
        "lemma oprod_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r *o t \\<le>o s *o t\"",
        "lemma oprod_assoc: \"(r *o s) *o t =o r *o s *o t\" (is \"?L =o ?R\")",
        "lemma oprod_osum: \"r *o (s +o t) =o r *o s +o r *o t\" (is \"?L =o ?R\")",
        "lemma ozero_oexp: \"\\<not> (s =o ozero) \\<Longrightarrow> ozero ^o s =o ozero\"",
        "lemma oone_oexp: \"oone ^o s =o oone\" (is \"?L =o ?R\")",
        "lemma oexp_monoR:\n  assumes \"oone <o r\" \"s <o t\"\n  shows   \"r ^o s <o r ^o t\" (is \"?L <o ?R\")",
        "lemma oexp_monoL:\n  assumes \"r \\<le>o s\"\n  shows   \"r ^o t \\<le>o s ^o t\"",
        "lemma ordLeq_oexp2:\n  assumes \"oone <o r\"\n  shows   \"s \\<le>o r ^o s\"",
        "lemma FinFunc_osum:\n  \"fg \\<in> FinFunc r (s +o t) = (fg o Inl \\<in> FinFunc r s \\<and> fg o Inr \\<in> FinFunc r t)\"\n  (is \"?L = (?R1 \\<and> ?R2)\")",
        "lemma max_fun_diff_eq_Inl:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inl x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff s f1 f2 = x\" (is ?P) \"g1 = g2\" (is ?Q)",
        "lemma max_fun_diff_eq_Inr:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inr x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff t g1 g2 = x\" (is ?P) \"g1 \\<noteq> g2\" (is ?Q)",
        "lemma oexp_osum: \"r ^o (s +o t) =o (r ^o s) *o (r ^o t)\" (is \"?R =o ?L\")",
        "lemma rev_curr_FinFunc:\n  assumes Field: \"Field r \\<noteq> {}\"\n  shows \"rev_curr ` (FinFunc r (s *o t)) = FinFunc (r ^o s) t\"",
        "lemma rev_curr_app_FinFunc[elim!]:\n  \"\\<lbrakk>f \\<in> FinFunc r (s *o t); z \\<in> Field t\\<rbrakk> \\<Longrightarrow> rev_curr f z \\<in> FinFunc r s\"",
        "lemma max_fun_diff_oprod:\n  assumes Field: \"Field r \\<noteq> {}\" and \"f \\<noteq> g\" \"f \\<in> FinFunc r (s *o t)\" \"g \\<in> FinFunc r (s *o t)\"\n  defines \"m \\<equiv> wo_rel.max_fun_diff t (rev_curr f) (rev_curr g)\"\n  shows \"wo_rel.max_fun_diff (s *o t) f g =\n    (wo_rel.max_fun_diff s (rev_curr f m) (rev_curr g m), m)\"",
        "lemma oexp_oexp: \"(r ^o s) ^o t =o r ^o (s *o t)\" (is \"?R =o ?L\")"
    ],
    "translations": [
        [
            "",
            "section \\<open>Ordinal Arithmetic\\<close>",
            0,
            "NA"
        ],
        [
            "",
            "theory Ordinal_Arithmetic\nimports Wellorder_Constructions\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "definition osum :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a + 'b) rel\"  (infixr \"+o\" 70)\nwhere\n  \"r +o r' = map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union>\n     {(Inl a, Inr a') | a a' . a \\<in> Field r \\<and> a' \\<in> Field r'}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma Field_osum: \"Field(r +o r') = Inl ` Field r \\<union> Inr ` Field r'\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field (r +o r') = Inl ` Field r \\<union> Inr ` Field r'",
            "unfolding osum_def Field_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Domain (map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}) \\<union> Range (map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}) = Inl ` (Domain r \\<union> Range r) \\<union> Inr ` (Domain r' \\<union> Range r')",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r')",
            "unfolding refl_on_def Field_osum",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> r +o r' \\<subseteq> (Inl ` Field r \\<union> Inr ` Field r') \\<times> (Inl ` Field r \\<union> Inr ` Field r') \\<and> (\\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. (x, x) \\<in> r +o r')",
            "unfolding osum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<subseteq> (Inl ` Field r \\<union> Inr ` Field r') \\<times> (Inl ` Field r \\<union> Inr ` Field r') \\<and> (\\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. (x, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'})",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_trans:\nassumes TRANS: \"trans r\" and TRANS': \"trans r'\"\nshows \"trans (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. trans (r +o r')",
            "proof(unfold trans_def, safe)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "fix x y z",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "assume *: \"(x, y) \\<in> r +o r'\" \"(y, z) \\<in> r +o r'\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\n\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "thus \"(x, z) \\<in> r +o r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'",
            "proof (cases x y z rule: sum.exhaust[case_product sum.exhaust sum.exhaust])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "case (Inl_Inl_Inl a b c)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inl c",
            "have \"(a,b) \\<in> r\" \"(b,c) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r &&& (b, c) \\<in> r",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r &&& (b, c) \\<in> r",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with TRANS",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ntrans r\n(a, b) \\<in> r\n(b, c) \\<in> r",
            "have \"(a,c) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntrans r\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r",
            "unfolding trans_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x y z. (x, y) \\<in> r \\<longrightarrow> (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, c) \\<in> r\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with Inl_Inl_Inl",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "case (Inl_Inl_Inr a b c)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inr c",
            "have \"a \\<in> Field r\" \"c \\<in> Field r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Field r &&& c \\<in> Field r'",
            "unfolding osum_def Field_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Domain r \\<union> Range r &&& c \\<in> Domain r' \\<union> Range r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with Inl_Inl_Inr",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "case (Inl_Inr_Inr a b c)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inr b\nz = Inr c",
            "have \"a \\<in> Field r\" \"c \\<in> Field r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Field r &&& c \\<in> Field r'",
            "unfolding osum_def Field_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Domain r \\<union> Range r &&& c \\<in> Domain r' \\<union> Range r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with Inl_Inr_Inr",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "case (Inr_Inr_Inr a b c)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inr a\ny = Inr b\nz = Inr c",
            "have \"(a,b) \\<in> r'\" \"(b,c) \\<in> r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r' &&& (b, c) \\<in> r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r' &&& (b, c) \\<in> r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with TRANS'",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ntrans r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'",
            "have \"(a,c) \\<in> r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ntrans r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r'",
            "unfolding trans_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x y z. (x, y) \\<in> r' \\<longrightarrow> (y, z) \\<in> r' \\<longrightarrow> (x, z) \\<in> r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r'",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, c) \\<in> r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "with Inr_Inr_Inr",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (4 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'",
            "qed (auto simp: osum_def)",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_Preorder: \"\\<lbrakk>Preorder r; Preorder r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r; Preorder r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r')",
            "unfolding preorder_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r') \\<and> trans (r +o r')",
            "using osum_Refl osum_trans",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Refl ?r; Refl ?r'\\<rbrakk> \\<Longrightarrow> Refl (?r +o ?r')\n\\<lbrakk>trans ?r; trans ?r'\\<rbrakk> \\<Longrightarrow> trans (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r') \\<and> trans (r +o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r +o r')",
            "unfolding antisym_def osum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y; \\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y\\<rbrakk> \\<Longrightarrow> \\<forall>x y. (x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<longrightarrow> (y, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<longrightarrow> x = y",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r')",
            "unfolding partial_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r') \\<and> antisym (r +o r')",
            "using osum_Preorder osum_antisym",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Preorder ?r; Preorder ?r'\\<rbrakk> \\<Longrightarrow> Preorder (?r +o ?r')\n\\<lbrakk>antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> antisym (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r') \\<and> antisym (r +o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r +o r')",
            "unfolding total_on_def Field_osum",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r +o r' \\<or> (y, x) \\<in> r +o r'",
            "unfolding osum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<or> (y, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r +o r')",
            "unfolding linear_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r') \\<and> Total (r +o r')",
            "using osum_Partial_order osum_Total",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Partial_order ?r; Partial_order ?r'\\<rbrakk> \\<Longrightarrow> Partial_order (?r +o ?r')\n\\<lbrakk>Total ?r; Total ?r'\\<rbrakk> \\<Longrightarrow> Total (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r') \\<and> Total (r +o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (r +o r')",
            "unfolding wf_eq_minimal2",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field (r +o r') \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r')",
            "unfolding Field_osum",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r')",
            "proof(intro allI impI, elim conjE)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "fix A",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "assume *: \"A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\" and **: \"A \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "obtain B where B_def: \"B = A Int Inl ` Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. B = A \\<inter> Inl ` Field r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "proof(cases \"B = {}\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB \\<noteq> {}\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "hence \"B \\<noteq> {}\" \"B \\<le> Inl ` Field r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} &&& B \\<subseteq> Inl ` Field r",
            "using B_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} &&& B \\<subseteq> Inl ` Field r",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "hence \"Inl -` B \\<noteq> {}\" \"Inl -` B \\<le> Field r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (1 subgoal):\n 1. Inl -` B \\<noteq> {} &&& Inl -` B \\<subseteq> Field r",
            "unfolding vimage_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (1 subgoal):\n 1. {x. Inl x \\<in> B} \\<noteq> {} &&& {x. Inl x \\<in> B} \\<subseteq> Field r",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "then",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r",
            "obtain a where 1: \"a \\<in> Inl -` B\" and \"\\<forall>a1 \\<in> Inl -` B. (a1, a) \\<notin> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using WF",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\nwf r\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding wf_eq_minimal2",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\\<forall>A. A \\<subseteq> Field r \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by metis",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "hence \"\\<forall>a1 \\<in> A. (a1, Inl a) \\<notin> r +o r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "using B_def **",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\nB = A \\<inter> Inl ` Field r\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by (auto simp: vimage_def Field_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "using 1",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\na \\<in> Inl -` B\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "unfolding B_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\na \\<in> Inl -` (A \\<inter> Inl ` Field r)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB = {}\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "hence 1: \"A \\<le> Inr ` Field r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB = {}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Inr ` Field r'",
            "using * B_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB = {}\nA \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Inr ` Field r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "with **",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'",
            "have \"Inr -`A \\<noteq> {}\" \"Inr -` A \\<le> Field r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. Inr -` A \\<noteq> {} &&& Inr -` A \\<subseteq> Field r'",
            "unfolding vimage_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. {x. Inr x \\<in> A} \\<noteq> {} &&& {x. Inr x \\<in> A} \\<subseteq> Field r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "with **",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'",
            "obtain a' where 2: \"a' \\<in> Inr -` A\" and \"\\<forall>a1' \\<in> Inr -` A. (a1',a') \\<notin> r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using WF'",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\nwf r'\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding wf_eq_minimal2",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\\<forall>A. A \\<subseteq> Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r')\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by metis",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "hence \"\\<forall>a1' \\<in> A. (a1', Inr a') \\<notin> r +o r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "using ** 1",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by (auto simp: vimage_def Field_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "using 2",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\na' \\<in> Inr -` A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r +o r') - Id \\<le> (r - Id) +o (r' - Id)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)",
            "unfolding osum_def Total_Id_Field[OF r] Total_Id_Field[OF r']",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field (r - Id) \\<and> a' \\<in> Field (r' - Id)} - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> map_prod Inr Inr ` (r' - Id) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field (r - Id) \\<and> a' \\<in> Field (r' - Id)}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (Inl ` Field r \\<times> Inr ` Field r') \\<union> (map_prod Inr Inr ` (r' - Id))\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> r +o r' - Id \\<subseteq> Inl ` Field r \\<times> Inr ` Field r' \\<union> map_prod Inr Inr ` (r' - Id)",
            "unfolding osum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} - Id \\<subseteq> Inl ` Field r \\<times> Inr ` Field r' \\<union> map_prod Inr Inr ` (r' - Id)",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (map_prod Inl Inl ` (r - Id)) \\<union> (Inl ` Field r \\<times> Inr ` Field r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> r +o r' - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> Inl ` Field r \\<times> Inr ` Field r'",
            "unfolding osum_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> Inl ` Field r \\<times> Inr ` Field r'",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r +o r') - Id)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "proof(cases \"r \\<le> Id \\<or> r' \\<le> Id\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r +o r' - Id)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r +o r' - Id)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "using osum_minus_Id[of r r'] assms osum_wf[of \"r - Id\" \"r' - Id\"]\n    wf_subset[of \"(r - Id) +o (r' - Id)\" \"(r +o r') - Id\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\\<lbrakk>Total r; \\<not> r \\<subseteq> Id; Total r'; \\<not> r' \\<subseteq> Id\\<rbrakk> \\<Longrightarrow> r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)\nTotal r\nTotal r'\nwf (r - Id)\nwf (r' - Id)\n\\<lbrakk>wf (r - Id); wf (r' - Id)\\<rbrakk> \\<Longrightarrow> wf ((r - Id) +o (r' - Id))\n\\<lbrakk>wf ((r - Id) +o (r' - Id)); r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)\\<rbrakk> \\<Longrightarrow> wf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "have 1: \"wf (Inl ` Field r \\<times> Inr ` Field r')\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (Inl ` Field r \\<times> Inr ` Field r')",
            "by (rule wf_Int_Times) auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (Inl ` Field r \\<times> Inr ` Field r')\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "proof (elim disjE)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "assume \"r \\<subseteq> Id\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<subseteq> Id\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "thus \"wf ((r +o r') - Id)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "by (rule wf_subset[rotated, OF osum_minus_Id1 wf_Un[OF 1 wf_map_prod_image[OF WF']]]) auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "assume \"r' \\<subseteq> Id\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)",
            "thus \"wf ((r +o r') - Id)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)",
            "by (rule wf_subset[rotated, OF osum_minus_Id2 wf_Un[OF wf_map_prod_image[OF WF] 1]]) auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r +o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "proof-",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "have \"Total r \\<and> Total r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'",
            "using WELL WELL'",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'",
            "by (auto simp add: order_on_defs)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "unfolding well_order_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r +o r') \\<and> wf (r +o r' - Id)",
            "using osum_Linear_order osum_wf_Id",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\\<lbrakk>Linear_order ?r; Linear_order ?r'\\<rbrakk> \\<Longrightarrow> Linear_order (?r +o ?r')\n\\<lbrakk>Total ?r; Total ?r'; wf (?r - Id); wf (?r' - Id)\\<rbrakk> \\<Longrightarrow> wf (?r +o ?r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r +o r') \\<and> wf (r +o r' - Id)",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r +o r')\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_embedL:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\n  shows \"embed r (r +o r') Inl\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "have 1: \"Well_order (r +o r')\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')",
            "by (auto simp add: osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r +o r')\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r +o r')\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "have \"compat r (r +o r') Inl\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat r (r +o r') Inl",
            "unfolding compat_def osum_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (Inl a, Inl b) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat r (r +o r') Inl\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat r (r +o r') Inl\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "have \"ofilter (r +o r') (Inl ` Field r)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ofilter (r +o r') (Inl ` Field r)",
            "unfolding wo_rel.ofilter_def[unfolded wo_rel_def, OF 1] Field_osum under_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Inl ` Field r \\<subseteq> Inl ` Field r \\<union> Inr ` Field r' \\<and> (\\<forall>a\\<in>Inl ` Field r. {b. (b, a) \\<in> r +o r'} \\<subseteq> Inl ` Field r)",
            "unfolding osum_def Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Inl ` (Domain r \\<union> Range r) \\<subseteq> Inl ` (Domain r \\<union> Range r) \\<union> Inr ` (Domain r' \\<union> Range r') \\<and> (\\<forall>a\\<in>Inl ` (Domain r \\<union> Range r). {b. (b, a) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}} \\<subseteq> Inl ` (Domain r \\<union> Range r))",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nofilter (r +o r') (Inl ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl",
            "by (auto simp add: embed_iff_compat_inj_on_ofilter)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed r (r +o r') Inl\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "corollary osum_ordLeqL:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\n  shows \"r \\<le>o r +o r'\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r \\<le>o r +o r'",
            "using assms osum_embedL osum_Well_order",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> embed ?r (?r +o ?r') Inl\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r +o ?r')\n\ngoal (1 subgoal):\n 1. r \\<le>o r +o r'",
            "unfolding ordLeq_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> embed ?r (?r +o ?r') Inl\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r +o ?r')\n\ngoal (1 subgoal):\n 1. (r, r +o r') \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma dir_image_alt: \"dir_image r f = map_prod f f ` r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. dir_image r f = map_prod f f ` r",
            "unfolding dir_image_def map_prod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {(f a, f b) |a b. (a, b) \\<in> r} = (\\<lambda>(x, y). (f x, f y)) ` r",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma map_prod_ordIso: \"\\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> map_prod f f ` r =o r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> map_prod f f ` r =o r",
            "unfolding dir_image_alt[symmetric]",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> dir_image r f =o r",
            "by (rule ordIso_symmetric[OF dir_image_ordIso])",
            1,
            "NA"
        ],
        [
            "",
            "definition oprod :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a \\<times> 'b) rel\"  (infixr \"*o\" 80)\nwhere \"r *o r' = {((x1, y1), (x2, y2)).\n  (((y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r) \\<or>\n   ((y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r))}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma Field_oprod: \"Field (r *o r') = Field r \\<times> Field r'\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field (r *o r') = Field r \\<times> Field r'",
            "unfolding oprod_def Field_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Domain {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Domain r \\<union> Range r \\<and> x2 \\<in> Domain r \\<union> Range r \\<or> (y1, y2) \\<in> Restr Id (Domain r' \\<union> Range r') \\<and> (x1, x2) \\<in> r} \\<union> Range {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Domain r \\<union> Range r \\<and> x2 \\<in> Domain r \\<union> Range r \\<or> (y1, y2) \\<in> Restr Id (Domain r' \\<union> Range r') \\<and> (x1, x2) \\<in> r} = (Domain r \\<union> Range r) \\<times> (Domain r' \\<union> Range r')",
            "by auto blast+",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r')",
            "unfolding refl_on_def Field_oprod",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> r *o r' \\<subseteq> (Field r \\<times> Field r') \\<times> Field r \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r \\<times> Field r'. (x, x) \\<in> r *o r')",
            "unfolding oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<subseteq> (Field r \\<times> Field r') \\<times> Field r \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r \\<times> Field r'. (x, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r})",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_trans:\n  assumes \"trans r\" \"trans r'\" \"antisym r\" \"antisym r'\"\n  shows \"trans (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. trans (r *o r')",
            "proof(unfold trans_def, safe)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'",
            "fix x y z",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'",
            "assume *: \"(x, y) \\<in> r *o r'\" \"(y, z) \\<in> r *o r'\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, y) \\<in> r *o r'\n(y, z) \\<in> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'",
            "thus \"(x, z) \\<in> r *o r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> r *o r'\n(y, z) \\<in> r *o r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r *o r'",
            "unfolding oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}\n(y, z) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}",
            "apply safe",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (17 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> ya \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\nA total of 17 subgoals...",
            "apply (metis assms(2) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (16 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> ya \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 16 subgoals...",
            "apply (metis assms(2) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (15 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 15 subgoals...",
            "apply (metis assms(2) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (14 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 14 subgoals...",
            "apply (metis assms(4) antisymD)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (13 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\nA total of 13 subgoals...",
            "apply (metis assms(4) antisymD)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (12 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\nA total of 12 subgoals...",
            "apply (metis assms(2) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (11 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 11 subgoals...",
            "apply (metis assms(4) antisymD)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (10 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Range_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Range_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Range_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (7 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Domain_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Domain_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis Field_def Domain_iff Un_iff)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis assms(1) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis assms(1) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis assms(1) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r",
            "apply (metis assms(1) transE)",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal:\nNo subgoals!",
            "done",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, z) \\<in> r *o r'\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_Preorder: \"\\<lbrakk>Preorder r; Preorder r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r; Preorder r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r')",
            "unfolding preorder_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r') \\<and> trans (r *o r')",
            "using oprod_Refl oprod_trans",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Refl ?r; Refl ?r'\\<rbrakk> \\<Longrightarrow> Refl (?r *o ?r')\n\\<lbrakk>trans ?r; trans ?r'; antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> trans (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r') \\<and> trans (r *o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r *o r')",
            "unfolding antisym_def oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y; \\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y\\<rbrakk> \\<Longrightarrow> \\<forall>x y. (x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (y, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<longrightarrow> x = y",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r')",
            "unfolding partial_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r') \\<and> antisym (r *o r')",
            "using oprod_Preorder oprod_antisym",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Preorder ?r; Preorder ?r'; antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> Preorder (?r *o ?r')\n\\<lbrakk>antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> antisym (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r') \\<and> antisym (r *o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r *o r')",
            "unfolding total_on_def Field_oprod",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Field r \\<times> Field r'. \\<forall>y\\<in>Field r \\<times> Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r *o r' \\<or> (y, x) \\<in> r *o r'",
            "unfolding oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Field r \\<times> Field r'. \\<forall>y\\<in>Field r \\<times> Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<or> (y, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r *o r')",
            "unfolding linear_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r') \\<and> Total (r *o r')",
            "using oprod_Partial_order oprod_Total",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Partial_order ?r; Partial_order ?r'\\<rbrakk> \\<Longrightarrow> Partial_order (?r *o ?r')\n\\<lbrakk>Total ?r; Total ?r'\\<rbrakk> \\<Longrightarrow> Total (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r') \\<and> Total (r *o r')",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (r *o r')",
            "unfolding wf_eq_minimal2",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field (r *o r') \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r')",
            "unfolding Field_oprod",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field r \\<times> Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r')",
            "proof(intro allI impI, elim conjE)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "fix A",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "assume *: \"A \\<subseteq> Field r \\<times> Field r'\" and **: \"A \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}",
            "obtain y where y: \"y \\<in> snd ` A\" \"\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. \\<lbrakk>y \\<in> snd ` A; \\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using spec[OF WF'[unfolded wf_eq_minimal2], of \"snd ` A\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\nsnd ` A \\<subseteq> Field r' \\<and> snd ` A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>snd ` A. \\<forall>a'\\<in>snd ` A. (a', a) \\<notin> r')\n\ngoal (1 subgoal):\n 1. (\\<And>y. \\<lbrakk>y \\<in> snd ` A; \\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "let ?A = \"fst ` A \\<inter> {x. (x, y) \\<in> A}\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "from * y",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<subseteq> Field r \\<times> Field r'\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'",
            "have \"?A \\<noteq> {}\" \"?A \\<subseteq> Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\n\ngoal (1 subgoal):\n 1. fst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {} &&& fst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r",
            "obtain x where x: \"x \\<in> ?A\" and \"\\<forall>x'\\<in> ?A. (x', x) \\<notin> r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}; \\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using spec[OF WF[unfolded wf_eq_minimal2], of \"?A\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r \\<and> fst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. \\<forall>a'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}; \\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "with y",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r",
            "have \"\\<forall>a'\\<in>A. (a', (x, y)) \\<notin> r *o r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'",
            "unfolding oprod_def mem_Collect_eq split_beta fst_conv snd_conv Id_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>A. \\<not> ((snd a', y) \\<in> r' - {p. \\<exists>x. p = (x, x)} \\<and> fst a' \\<in> Field r \\<and> x \\<in> Field r \\<or> (snd a', y) \\<in> Restr {p. \\<exists>x. p = (x, x)} (Field r') \\<and> (fst a', x) \\<in> r)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "from x",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}",
            "have \"(x, y) \\<in> A\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> A",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n(x, y) \\<in> A",
            "show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n(x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r *o r') - Id \\<le> (r - Id) *o (r' - Id)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)",
            "unfolding oprod_def Total_Id_Field[OF r] Total_Id_Field[OF r']",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field (r - Id) \\<and> x2 \\<in> Field (r - Id) \\<or> (y1, y2) \\<in> Restr Id (Field (r' - Id)) \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id - Id \\<and> x1 \\<in> Field (r - Id) \\<and> x2 \\<in> Field (r - Id) \\<or> (y1, y2) \\<in> Restr Id (Field (r' - Id)) \\<and> (x1, x2) \\<in> r - Id}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x,y1), (x,y2)). x \\<in> Field r \\<and> (y1, y2) \\<in> (r' - Id)}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> r *o r' - Id \\<subseteq> {((x, y1), x, y2). x \\<in> Field r \\<and> (y1, y2) \\<in> r' - Id}",
            "unfolding oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x, y1), x, y2). x \\<in> Field r \\<and> (y1, y2) \\<in> r' - Id}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma wf_extend_oprod1:\n  assumes \"wf r\"\n  shows \"wf {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "proof (unfold wf_eq_minimal2, intro allI impI, elim conjE)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "fix B",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "assume *: \"B \\<subseteq> Field {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\" and \"B \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "from image_mono[OF *, of snd]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nsnd ` B \\<subseteq> snd ` Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "have \"snd ` B \\<subseteq> Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsnd ` B \\<subseteq> snd ` Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. snd ` B \\<subseteq> Field r",
            "unfolding Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nsnd ` B \\<subseteq> snd ` (Domain {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r} \\<union> Range {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r})\n\ngoal (1 subgoal):\n 1. snd ` B \\<subseteq> Domain r \\<union> Range r",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nsnd ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "with \\<open>B \\<noteq> {}\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r",
            "obtain x where x: \"x \\<in> snd ` B\" \"\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> snd ` B; \\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using spec[OF assms[unfolded wf_eq_minimal2], of \"snd ` B\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r\nsnd ` B \\<subseteq> Field r \\<and> snd ` B \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>snd ` B. \\<forall>a'\\<in>snd ` B. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> snd ` B; \\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r",
            "obtain a where \"(a, x) \\<in> B\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (\\<And>a. (a, x) \\<in> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, x) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, x) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "from * x",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r",
            "have \"\\<forall>a'\\<in>B. (a', (a, x)) \\<notin> {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(a, x) \\<in> B\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "show \"\\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, x) \\<in> B\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x1,y), (x2,y)). (x1, x2) \\<in> (r - Id) \\<and> y \\<in> Field r'}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> r *o r' - Id \\<subseteq> {((x1, y), x2, y). (x1, x2) \\<in> r - Id \\<and> y \\<in> Field r'}",
            "unfolding oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x1, y), x2, y). (x1, x2) \\<in> r - Id \\<and> y \\<in> Field r'}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma wf_extend_oprod2:\n  assumes \"wf r\"\n  shows \"wf {((x1,y), (x2,y)) . (x1, x2) \\<in> r \\<and> y \\<in> A}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "proof (unfold wf_eq_minimal2, intro allI impI, elim conjE)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "fix B",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "assume *: \"B \\<subseteq> Field {((x1, y), (x2, y)). (x1, x2) \\<in> r \\<and> y \\<in> A}\" and \"B \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "from image_mono[OF *, of fst]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfst ` B \\<subseteq> fst ` Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "have \"fst ` B \\<subseteq> Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfst ` B \\<subseteq> fst ` Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. fst ` B \\<subseteq> Field r",
            "unfolding Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfst ` B \\<subseteq> fst ` (Domain {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A} \\<union> Range {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A})\n\ngoal (1 subgoal):\n 1. fst ` B \\<subseteq> Domain r \\<union> Range r",
            "by force",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfst ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "with \\<open>B \\<noteq> {}\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r",
            "obtain x where x: \"x \\<in> fst ` B\" \"\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` B; \\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using spec[OF assms[unfolded wf_eq_minimal2], of \"fst ` B\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r\nfst ` B \\<subseteq> Field r \\<and> fst ` B \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>fst ` B. \\<forall>a'\\<in>fst ` B. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` B; \\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r",
            "obtain a where \"(x, a) \\<in> B\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (\\<And>a. (x, a) \\<in> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, a) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, a) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "from * x",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r",
            "have \"\\<forall>a'\\<in>B. (a', (x, a)) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(x, a) \\<in> B\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "show \"\\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, a) \\<in> B\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r *o r') - Id)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)",
            "proof(cases \"r \\<le> Id \\<or> r' \\<le> Id\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r *o r' - Id)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r *o r' - Id)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)",
            "using oprod_minus_Id[of r r'] assms oprod_wf[of \"r - Id\" \"r' - Id\"]\n    wf_subset[of \"(r - Id) *o (r' - Id)\" \"(r *o r') - Id\"]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\\<lbrakk>Total r; \\<not> r \\<subseteq> Id; Total r'; \\<not> r' \\<subseteq> Id\\<rbrakk> \\<Longrightarrow> r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)\nTotal r\nTotal r'\nwf (r - Id)\nwf (r' - Id)\n\\<lbrakk>wf (r - Id); wf (r' - Id)\\<rbrakk> \\<Longrightarrow> wf ((r - Id) *o (r' - Id))\n\\<lbrakk>wf ((r - Id) *o (r' - Id)); r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)\\<rbrakk> \\<Longrightarrow> wf (r *o r' - Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r *o r' - Id)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)",
            "using wf_subset[OF wf_extend_oprod1[OF WF'] oprod_minus_Id1]\n                     wf_subset[OF wf_extend_oprod2[OF WF] oprod_minus_Id2]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n?r3 \\<subseteq> Id \\<Longrightarrow> wf (?r3 *o r' - Id)\n?r'3 \\<subseteq> Id \\<Longrightarrow> wf (r *o ?r'3 - Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (r *o r' - Id)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r *o r')\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "proof-",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "have \"Total r \\<and> Total r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'",
            "using WELL WELL'",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'",
            "by (auto simp add: order_on_defs)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "unfolding well_order_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r *o r') \\<and> wf (r *o r' - Id)",
            "using oprod_Linear_order oprod_wf_Id",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\\<lbrakk>Linear_order ?r; Linear_order ?r'\\<rbrakk> \\<Longrightarrow> Linear_order (?r *o ?r')\n\\<lbrakk>Total ?r; Total ?r'; wf (?r - Id); wf (?r' - Id)\\<rbrakk> \\<Longrightarrow> wf (?r *o ?r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r *o r') \\<and> wf (r *o r' - Id)",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r *o r')\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_embed:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\" and \"r' \\<noteq> {}\"\n  shows \"embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\" (is \"embed _ _ ?f\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "from assms(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr' \\<noteq> {}",
            "have r': \"Field r' \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r' \\<noteq> {}",
            "unfolding Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r' \\<union> Range r' \\<noteq> {}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "have minim[simp]: \"minim r' (Field r') \\<in> Field r'\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. minim r' (Field r') \\<in> Field r'",
            "using wo_rel.minim_inField[unfolded wo_rel_def, OF WELL' _ r']",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r' \\<subseteq> Field r' \\<Longrightarrow> minim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. minim r' (Field r') \\<in> Field r'",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nminim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nminim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "fix b",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "assume b: \"(b, minim r' (Field r')) \\<in> r'\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(b, minim r' (Field r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "hence \"b \\<in> Field r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(b, minim r' (Field r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. b \\<in> Field r'",
            "unfolding Field_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(b, minim r' (Domain r' \\<union> Range r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. b \\<in> Domain r' \\<union> Range r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "hence \"(minim r' (Field r'), b) \\<in> r'\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (minim r' (Field r'), b) \\<in> r'",
            "using wo_rel.minim_least[unfolded wo_rel_def, OF WELL' subset_refl] r'",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nb \\<in> Field r'\n?b \\<in> Field r' \\<Longrightarrow> (minim r' (Field r'), ?b) \\<in> r'\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (minim r' (Field r'), b) \\<in> r'",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(minim r' (Field r'), b) \\<in> r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "with b",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(b, minim r' (Field r')) \\<in> r'\n(minim r' (Field r'), b) \\<in> r'",
            "have \"b = minim r' (Field r')\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(b, minim r' (Field r')) \\<in> r'\n(minim r' (Field r'), b) \\<in> r'\n\ngoal (1 subgoal):\n 1. b = minim r' (Field r')",
            "by (metis WELL' antisym_def linear_order_on_def partial_order_on_def well_order_on_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nb = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "note * = this",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "have 1: \"Well_order (r *o r')\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\nWell_order r'\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')",
            "by (auto simp add: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r *o r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order (r *o r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "from r'",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nField r' \\<noteq> {}",
            "have \"compat r (r *o r') ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. compat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "unfolding compat_def oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> ((a, minim r' (Field r')), b, minim r' (Field r')) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "from *",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')",
            "have \"ofilter (r *o r') (?f ` Field r)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. ofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)",
            "unfolding wo_rel.ofilter_def[unfolded wo_rel_def, OF 1] Field_oprod under_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (x, minim r' (Field r'))) ` Field r \\<subseteq> Field r \\<times> Field r' \\<and> (\\<forall>a\\<in>(\\<lambda>x. (x, minim r' (Field r'))) ` Field r. {b. (b, a) \\<in> r *o r'} \\<subseteq> (\\<lambda>x. (x, minim r' (Field r'))) ` Field r)",
            "unfolding oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (x, minim r' (Field r'))) ` Field r \\<subseteq> Field r \\<times> Field r' \\<and> (\\<forall>a\\<in>(\\<lambda>x. (x, minim r' (Field r'))) ` Field r. {b. (b, a) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}} \\<subseteq> (\\<lambda>x. (x, minim r' (Field r'))) ` Field r)",
            "by auto (auto simp: image_iff Field_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "have \"inj_on ?f (Field r)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)",
            "unfolding inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. (x, minim r' (Field r')) = (y, minim r' (Field r')) \\<longrightarrow> x = y",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "using assms",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\nWell_order r\nWell_order r'\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))",
            "by (auto simp add: embed_iff_compat_inj_on_ofilter)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "corollary oprod_ordLeq: \"\\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'",
            "using oprod_embed oprod_Well_order",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Well_order ?r; Well_order ?r'; ?r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> embed ?r (?r *o ?r') (\\<lambda>x. (x, minim ?r' (Field ?r')))\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'",
            "unfolding ordLeq_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Well_order ?r; Well_order ?r'; ?r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> embed ?r (?r *o ?r') (\\<lambda>x. (x, minim ?r' (Field ?r')))\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> (r, r *o r') \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "definition \"support z A f = {x \\<in> A. f x \\<noteq> z}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma support_Un[simp]: \"support z (A \\<union> B) f = support z A f \\<union> support z B f\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. support z (A \\<union> B) f = support z A f \\<union> support z B f",
            "unfolding support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> A \\<union> B. f x \\<noteq> z} = {x \\<in> A. f x \\<noteq> z} \\<union> {x \\<in> B. f x \\<noteq> z}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma support_upd[simp]: \"support z A (f(x := z)) = support z A f - {x}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. support z A (f(x := z)) = support z A f - {x}",
            "unfolding support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A. (f(x := z)) xa \\<noteq> z} = {x \\<in> A. f x \\<noteq> z} - {x}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma support_upd_subset[simp]: \"support z A (f(x := y)) \\<subseteq> support z A f \\<union> {x}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. support z A (f(x := y)) \\<subseteq> support z A f \\<union> {x}",
            "unfolding support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A. (f(x := y)) xa \\<noteq> z} \\<subseteq> {x \\<in> A. f x \\<noteq> z} \\<union> {x}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma fun_unequal_in_support:\n  assumes \"f \\<noteq> g\" \"f \\<in> Func A B\" \"g \\<in> Func A C\"\n  shows \"(support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\" (is \"?L \\<inter> ?R \\<noteq> {}\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<noteq> g",
            "obtain x where x: \"f x \\<noteq> g x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<noteq> g\n\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<noteq> g x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "hence \"x \\<in> ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> {a. f a \\<noteq> g a}",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> {a. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> {a. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "from assms(2-3) x",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> Func A B\ng \\<in> Func A C\nf x \\<noteq> g x",
            "have \"x \\<in> A\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> Func A B\ng \\<in> Func A C\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> A",
            "unfolding Func_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}\ng \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> C) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> A",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> A\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "with x",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf x \\<noteq> g x\nx \\<in> A",
            "have \"x \\<in> ?L\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x \\<noteq> g x\nx \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> support z A f \\<union> support z A g",
            "unfolding support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x \\<noteq> g x\nx \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> A. f x \\<noteq> z} \\<union> {x \\<in> A. g x \\<noteq> z}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> support z A f \\<union> support z A g\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> {a. f a \\<noteq> g a}\nx \\<in> support z A f \\<union> support z A g",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> {a. f a \\<noteq> g a}\nx \\<in> support z A f \\<union> support z A g\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition fin_support where\n  \"fin_support z A = {f. finite (support z A f)}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma finite_support: \"f \\<in> fin_support z A \\<Longrightarrow> finite (support z A f)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> fin_support z A \\<Longrightarrow> finite (support z A f)",
            "unfolding support_def fin_support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. finite {x \\<in> A. f x \\<noteq> z}} \\<Longrightarrow> finite {x \\<in> A. f x \\<noteq> z}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma fin_support_Field_osum:\n  \"f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<longleftrightarrow>\n  (f o Inl) \\<in> fin_support z A \\<and> (f o Inr) \\<in> fin_support z B\" (is \"?L \\<longleftrightarrow> ?R1 \\<and> ?R2\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)) = (f \\<circ> Inl \\<in> fin_support z A \\<and> f \\<circ> Inr \\<in> fin_support z B)",
            "proof safe",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inl \\<in> fin_support z A\n 2. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 3. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "assume ?L",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (3 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inl \\<in> fin_support z A\n 2. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 3. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "from \\<open>?L\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "show ?R1",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (1 subgoal):\n 1. f \\<circ> Inl \\<in> fin_support z A",
            "unfolding fin_support_def support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> {f. finite {x \\<in> Inl ` A \\<union> Inr ` B. f x \\<noteq> z}}\n\ngoal (1 subgoal):\n 1. f \\<circ> Inl \\<in> {f. finite {x \\<in> A. f x \\<noteq> z}}",
            "by (fastforce simp: image_iff elim: finite_surj[of _ _ \"case_sum id undefined\"])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<circ> Inl \\<in> fin_support z A\n\ngoal (2 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 2. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "from \\<open>?L\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "show ?R2",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (1 subgoal):\n 1. f \\<circ> Inr \\<in> fin_support z B",
            "unfolding fin_support_def support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> {f. finite {x \\<in> Inl ` A \\<union> Inr ` B. f x \\<noteq> z}}\n\ngoal (1 subgoal):\n 1. f \\<circ> Inr \\<in> {f. finite {x \\<in> B. f x \\<noteq> z}}",
            "by (fastforce simp: image_iff elim: finite_surj[of _ _ \"case_sum undefined id\"])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "assume ?R1 ?R2",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<circ> Inl \\<in> fin_support z A\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "thus ?L",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<circ> Inl \\<in> fin_support z A\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)",
            "unfolding fin_support_def support_Un",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<circ> Inl \\<in> {f. finite (support z A f)}\nf \\<circ> Inr \\<in> {f. finite (support z B f)}\n\ngoal (1 subgoal):\n 1. f \\<in> {f. finite (support z (Inl ` A) f \\<union> support z (Inr ` B) f)}",
            "by (auto simp: support_def elim: finite_surj[of _ _ Inl] finite_surj[of _ _ Inr])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma Func_upd: \"\\<lbrakk>f \\<in> Func A B; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> Func A B\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> Func A B; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> Func A B",
            "unfolding Func_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "context wo_rel\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "definition isMaxim :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"isMaxim A b \\<equiv> b \\<in> A \\<and> (\\<forall>a \\<in> A. (a,b) \\<in> r)\"",
            0,
            "NA"
        ],
        [
            "",
            "definition maxim :: \"'a set \\<Rightarrow> 'a\"\nwhere \"maxim A \\<equiv> THE b. isMaxim A b\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma isMaxim_unique[intro]: \"\\<lbrakk>isMaxim A x; isMaxim A y\\<rbrakk> \\<Longrightarrow> x = y\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxim A x; isMaxim A y\\<rbrakk> \\<Longrightarrow> x = y",
            "unfolding isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<and> (\\<forall>a\\<in>A. (a, x) \\<in> r); y \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\\<rbrakk> \\<Longrightarrow> x = y",
            "using antisymD[OF ANTISYM, of x y]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<and> (\\<forall>a\\<in>A. (a, x) \\<in> r); y \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\\<rbrakk> \\<Longrightarrow> x = y",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_isMaxim: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (maxim A)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (maxim A)",
            "unfolding maxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (THE b. isMaxim A b)",
            "proof (rule theI', rule ex_ex1I[OF _ isMaxim_unique, rotated], assumption+,\n  induct A rule: finite_induct)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; \\<lbrakk>F \\<noteq> {}; F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim F); insert x F \\<noteq> {}; insert x F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim (insert x F))",
            "case (insert x A)",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite A\nx \\<notin> A\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<noteq> {}\ninsert x A \\<subseteq> Field r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; \\<lbrakk>F \\<noteq> {}; F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim F); insert x F \\<noteq> {}; insert x F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim (insert x F))",
            "thus ?case",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nx \\<notin> A\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<noteq> {}\ninsert x A \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a",
            "proof (cases \"A = {}\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "have \"isMaxim {x} x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. isMaxim {x} x",
            "unfolding isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x} \\<and> (\\<forall>a\\<in>{x}. (a, x) \\<in> r)",
            "using refl_onD[OF REFL] insert(5)",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\ninsert x A \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. x \\<in> {x} \\<and> (\\<forall>a\\<in>{x}. (a, x) \\<in> r)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim {x} x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA = {}\nisMaxim {x} x",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA = {}\nisMaxim {x} x\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "with insert(3,5)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<subseteq> Field r\nA \\<noteq> {}",
            "obtain y where \"isMaxim A y\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<subseteq> Field r\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. isMaxim A y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim A y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "with insert(2,5)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<notin> A\ninsert x A \\<subseteq> Field r\nisMaxim A y",
            "have \"if (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<notin> A\ninsert x A \\<subseteq> Field r\nisMaxim A y\n\ngoal (1 subgoal):\n 1. if (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y",
            "unfolding isMaxim_def subset_eq",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<notin> A\n\\<forall>x\\<in>insert x A. x \\<in> Field r\ny \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. if (y, x) \\<in> r then x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r) else y \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, y) \\<in> r)",
            "by (metis insert_iff max2_def max2_equals1 max2_iff)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nif (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nif (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a",
            "by metis",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})",
            "qed simp",
            2,
            "NA"
        ],
        [
            "",
            "lemma maxim_in: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A",
            "using maxim_isMaxim",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A",
            "unfolding isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim ?A \\<in> ?A \\<and> (\\<forall>a\\<in>?A. (a, maxim ?A) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_greatest: \"\\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r",
            "using maxim_isMaxim",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r",
            "unfolding isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim ?A \\<in> ?A \\<and> (\\<forall>a\\<in>?A. (a, maxim ?A) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma isMaxim_zero: \"isMaxim A zero \\<Longrightarrow> A = {zero}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A local.zero \\<Longrightarrow> A = {local.zero}",
            "unfolding isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. local.zero \\<in> A \\<and> (\\<forall>a\\<in>A. (a, local.zero) \\<in> r) \\<Longrightarrow> A = {local.zero}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_insert:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"x \\<in> Field r\"\n  shows \"maxim (insert x A) = max2 x (maxim A)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r",
            "have *: \"isMaxim (insert x A) (maxim (insert x A))\" \"isMaxim A (maxim A)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim (insert x A)) &&& isMaxim A (maxim A)",
            "using maxim_isMaxim",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim (insert x A)) &&& isMaxim A (maxim A)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (insert x A) (maxim (insert x A))\nisMaxim A (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "proof (cases \"(x, maxim A) \\<in> r\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, maxim A) \\<in> r\n\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "with *(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim A (maxim A)\n(x, maxim A) \\<in> r",
            "have \"isMaxim (insert x A) (maxim A)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim A (maxim A)\n(x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim A)",
            "unfolding isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\n(x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, maxim A) \\<in> r)",
            "using transD[OF TRANS, of _ x \"maxim A\"]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\n(x, maxim A) \\<in> r\n\\<lbrakk>(?x, x) \\<in> r; (x, maxim A) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, maxim A) \\<in> r)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (insert x A) (maxim A)\n\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "with *(1) True",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "unfolding max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = (if (x, maxim A) \\<in> r then maxim A else x)",
            "by (metis isMaxim_unique)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, maxim A) \\<notin> r\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "hence \"(maxim A, x) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(x, maxim A) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim A, x) \\<in> r",
            "by (metis *(2) assms(3,4) in_mono in_notinI isMaxim_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "with *(2) assms(4)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim A (maxim A)\nx \\<in> Field r\n(maxim A, x) \\<in> r",
            "have \"isMaxim (insert x A) x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim A (maxim A)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) x",
            "unfolding isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r)",
            "using transD[OF TRANS, of _ \"maxim A\" x] refl_onD[OF REFL, of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\\<lbrakk>(?x, maxim A) \\<in> r; (maxim A, x) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, x) \\<in> r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)",
            "with *(1) False",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)",
            "unfolding max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = (if (x, maxim A) \\<in> r then maxim A else x)",
            "by (metis isMaxim_unique)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma maxim_Un:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"finite B\" \"B \\<noteq> {}\" \"B \\<subseteq> Field r\"\n  shows   \"maxim (A \\<union> B) = max2 (maxim A) (maxim B)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r",
            "have *: \"isMaxim (A \\<union> B) (maxim (A \\<union> B))\" \"isMaxim A (maxim A)\" \"isMaxim B (maxim B)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim (A \\<union> B)) &&& isMaxim A (maxim A) &&& isMaxim B (maxim B)",
            "using maxim_isMaxim",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim (A \\<union> B)) &&& isMaxim A (maxim A) &&& isMaxim B (maxim B)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "proof (cases \"(maxim A, maxim B) \\<in> r\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(maxim A, maxim B) \\<in> r\n\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "with *(2,3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim A, maxim B) \\<in> r",
            "have \"isMaxim (A \\<union> B) (maxim B)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim A, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim B)",
            "unfolding isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim A, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim B \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim B) \\<in> r)",
            "using transD[OF TRANS, of _ \"maxim A\" \"maxim B\"]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim A, maxim B) \\<in> r\n\\<lbrakk>(?x, maxim A) \\<in> r; (maxim A, maxim B) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim B \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim B) \\<in> r)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "with *(1) True",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "unfolding max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = (if (maxim A, maxim B) \\<in> r then maxim B else maxim A)",
            "by (metis isMaxim_unique)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(maxim A, maxim B) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "hence \"(maxim B, maxim A) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(maxim A, maxim B) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim B, maxim A) \\<in> r",
            "by (metis *(2,3) assms(3,6) in_mono in_notinI isMaxim_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "with *(2,3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim B, maxim A) \\<in> r",
            "have \"isMaxim (A \\<union> B) (maxim A)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim A)",
            "unfolding isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim A) \\<in> r)",
            "using transD[OF TRANS, of _ \"maxim B\" \"maxim A\"]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim B, maxim A) \\<in> r\n\\<lbrakk>(?x, maxim B) \\<in> r; (maxim B, maxim A) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim A) \\<in> r)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "with *(1) False",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)",
            "unfolding max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = (if (maxim A, maxim B) \\<in> r then maxim B else maxim A)",
            "by (metis isMaxim_unique)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma maxim_insert_zero:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\"\n  shows \"maxim (insert zero A) = maxim A\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert local.zero A) = maxim A",
            "using assms zero_in_Field maxim_in[OF assms]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nField r \\<noteq> {} \\<Longrightarrow> local.zero \\<in> Field r\nmaxim A \\<in> A\n\ngoal (1 subgoal):\n 1. maxim (insert local.zero A) = maxim A",
            "by (subst maxim_insert[unfolded max2_def]) auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_equality: \"isMaxim A x \\<Longrightarrow> maxim A = x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A x \\<Longrightarrow> maxim A = x",
            "unfolding maxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A x \\<Longrightarrow> (THE b. isMaxim A b) = x",
            "by (rule the_equality) auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_singleton:\n  \"x \\<in> Field r \\<Longrightarrow> maxim {x} = x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> maxim {x} = x",
            "using refl_onD[OF REFL]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> maxim {x} = x",
            "by (intro maxim_equality) (simp add: isMaxim_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_Int: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r; maxim A \\<in> B\\<rbrakk> \\<Longrightarrow> maxim (A \\<inter> B) = maxim A\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r; maxim A \\<in> B\\<rbrakk> \\<Longrightarrow> maxim (A \\<inter> B) = maxim A",
            "by (rule maxim_equality) (auto simp: isMaxim_def intro: maxim_in maxim_greatest)",
            1,
            "NA"
        ],
        [
            "",
            "lemma maxim_mono: \"\\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r",
            "using maxim_in[OF finite_subset, of X Y]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; X \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim X \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r",
            "by (auto intro: maxim_greatest)",
            1,
            "NA"
        ],
        [
            "",
            "definition \"max_fun_diff f g \\<equiv> maxim ({a \\<in> Field r. f a \\<noteq> g a})\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_commute: \"max_fun_diff f g = max_fun_diff g f\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. max_fun_diff f g = max_fun_diff g f",
            "unfolding max_fun_diff_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. maxim {a \\<in> Field r. f a \\<noteq> g a} = maxim {a \\<in> Field r. g a \\<noteq> f a}",
            "by metis",
            1,
            "NA"
        ],
        [
            "",
            "lemma zero_under: \"x \\<in> Field r \\<Longrightarrow> zero \\<in> under x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> local.zero \\<in> local.under x",
            "unfolding under_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> local.zero \\<in> {b. (b, x) \\<in> r}",
            "by (auto intro: zero_smallest)",
            1,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "definition \"FinFunc r s = Func (Field s) (Field r) \\<inter> fin_support (zero r) (Field s)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma FinFuncD: \"\\<lbrakk>f \\<in> FinFunc r s; x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FinFunc r s; x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r",
            "unfolding FinFunc_def Func_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s); x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r",
            "by (fastforce split: option.splits)",
            1,
            "NA"
        ],
        [
            "",
            "locale wo_rel2 =\n  fixes r s\n  assumes rWELL: \"Well_order r\"\n  and     sWELL: \"Well_order s\"\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "interpretation r: wo_rel r",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r",
            "by unfold_locales (rule rWELL)",
            1,
            "NA"
        ],
        [
            "",
            "interpretation s: wo_rel s",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule sWELL)",
            1,
            "NA"
        ],
        [
            "",
            "abbreviation \"SUPP \\<equiv> support r.zero (Field s)\"",
            0,
            "NA"
        ],
        [
            "",
            "abbreviation \"FINFUNC \\<equiv> FinFunc r s\"",
            0,
            "NA"
        ],
        [
            "",
            "lemmas FINFUNCD = FinFuncD[of _ r s]",
            0,
            "NA"
        ],
        [
            "",
            "lemma fun_diff_alt: \"{a \\<in> Field s. f a \\<noteq> g a} = (SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {a \\<in> Field s. f a \\<noteq> g a} = (SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}",
            "by (auto simp: support_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_alt:\n  \"s.max_fun_diff f g = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f g = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})",
            "unfolding s.max_fun_diff_def fun_diff_alt",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}) = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})",
            "..",
            1,
            "NA"
        ],
        [
            "",
            "lemma isMaxim_max_fun_diff: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)",
            "using fun_unequal_in_support[of f g]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> Func ?A ?B; g \\<in> Func ?A ?C\\<rbrakk> \\<Longrightarrow> (support ?z ?A f \\<union> support ?z ?A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)",
            "unfolding max_fun_diff_alt fun_diff_alt fun_eq_iff",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>\\<not> (\\<forall>x. f x = g x); f \\<in> Func ?A ?B; g \\<in> Func ?A ?C\\<rbrakk> \\<Longrightarrow> (support ?z ?A f \\<union> support ?z ?A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>x. f x = g x); f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}) (s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}))",
            "by (intro s.maxim_isMaxim) (auto simp: FinFunc_def fin_support_def support_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_in: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}",
            "using isMaxim_max_fun_diff",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. ?f a \\<noteq> ?g a} (s.max_fun_diff ?f ?g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}",
            "unfolding s.isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. ?f a \\<noteq> ?g a}. (a, s.max_fun_diff ?f ?g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_max: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow>\n  (x, s.max_fun_diff f g) \\<in> s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "using isMaxim_max_fun_diff",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. ?f a \\<noteq> ?g a} (s.max_fun_diff ?f ?g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "unfolding s.isMaxim_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. ?f a \\<noteq> ?g a}. (a, s.max_fun_diff ?f ?g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff:\n  \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  (\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and>\n     f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b",
            "using isMaxim_max_fun_diff[of f g]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b",
            "unfolding s.isMaxim_def FinFunc_def Func_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s); g \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s); g \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_le_eq:\n  \"\\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow>\n  f x = g x\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> f x = g x",
            "using max_fun_diff_max[of f g x] antisymD[OF s.ANTISYM, of \"s.max_fun_diff f g\" x]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; (x, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> f x = g x",
            "by (auto simp: Field_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_max2:\n  assumes ineq: \"s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow>\n    f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\" and\n    fg: \"f \\<noteq> g\" and gh: \"g \\<noteq> h\" and fh: \"f \\<noteq> h\" and\n    f: \"f \\<in> FINFUNC\" and g: \"g \\<in> FINFUNC\" and h: \"h \\<in> FINFUNC\"\n  shows \"s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\"\n    (is \"?fh = s.max2 ?fg ?gh\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "proof (cases \"?fg = ?gh\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f g = s.max_fun_diff g h\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "with ineq",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\ns.max_fun_diff f g = s.max_fun_diff g h",
            "have \"f ?fg \\<noteq> h ?fg\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\ns.max_fun_diff f g = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "assume x: \"x \\<in> {a \\<in> Field s. f a \\<noteq> h a}\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"(x, ?fg) \\<in> s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<in> s",
            "proof (cases \"x = ?fg\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n 2. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<noteq> s.max_fun_diff f g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n 2. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<in> s",
            "proof (rule ccontr)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "assume \"(x, ?fg) \\<notin> s\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<notin> s\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "with max_fun_diff_in[OF fg f g] x False",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\nx \\<noteq> s.max_fun_diff f g\n(x, s.max_fun_diff f g) \\<notin> s",
            "have *: \"(?fg, x) \\<in> s\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\nx \\<noteq> s.max_fun_diff f g\n(x, s.max_fun_diff f g) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, x) \\<in> s",
            "by (blast intro: s.in_notinI)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "hence \"f x = g x\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. f x = g x",
            "by (rule max_fun_diff_le_eq[OF _ fg f g False])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = g x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf x = g x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "have \"g x = h x\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g x = h x",
            "using max_fun_diff_le_eq[OF _ gh g h] False True *",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>(s.max_fun_diff g h, ?x) \\<in> s; ?x \\<noteq> s.max_fun_diff g h\\<rbrakk> \\<Longrightarrow> g ?x = h ?x\nx \\<noteq> s.max_fun_diff f g\ns.max_fun_diff f g = s.max_fun_diff g h\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. g x = h x",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng x = h x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf x = g x\ng x = h x",
            "show False",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\ng x = h x\n\ngoal (1 subgoal):\n 1. False",
            "using x",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\ng x = h x\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. False",
            "by simp",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s",
            "qed (simp add: refl_onD[OF s.REFL])",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<in> s\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s",
            "have \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?fg\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)",
            "unfolding s.isMaxim_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)",
            "using max_fun_diff_in[OF fg f g]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"?fh = ?fg\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g",
            "using isMaxim_max_fun_diff[OF fh f h]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "unfolding True s.max2_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff g h, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff g h)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f g \\<noteq> s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "note * = this",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f g \\<noteq> s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "proof (cases \"(?fg, ?gh) \\<in> s\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence *: \"f ?gh = g ?gh\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. f (s.max_fun_diff g h) = g (s.max_fun_diff g h)",
            "by (rule max_fun_diff_le_eq[OF _ fg f g *[symmetric]])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?gh\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)",
            "using isMaxim_max_fun_diff[OF gh g h]\n      isMaxim_max_fun_diff[OF fg f g] transD[OF s.TRANS _ True]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. g a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n(?x, s.max_fun_diff f g) \\<in> s \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)",
            "unfolding s.isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. g a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n(?x, s.max_fun_diff f g) \\<in> s \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff g h \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"?fh = ?gh\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff g h",
            "using isMaxim_max_fun_diff[OF fh f h]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff g h",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "using True",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "unfolding s.max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "with max_fun_diff_in[OF fg f g] max_fun_diff_in[OF gh g h]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s",
            "have True: \"(?gh, ?fg) \\<in> s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s",
            "by (blast intro: s.in_notinI)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence *: \"g ?fg = h ?fg\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. g (s.max_fun_diff f g) = h (s.max_fun_diff f g)",
            "by (rule max_fun_diff_le_eq[OF _ gh g h *])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?fg\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)",
            "using isMaxim_max_fun_diff[OF gh g h]\n      isMaxim_max_fun_diff[OF fg f g] True transD[OF s.TRANS, of _ _ ?fg]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. g a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)",
            "unfolding s.isMaxim_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. g a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "hence \"?fh = ?fg\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g",
            "using isMaxim_max_fun_diff[OF fh f h]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "using False",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)",
            "unfolding s.max2_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition oexp where\n  \"oexp = {(f, g) . f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and>\n    ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma Field_oexp: \"Field oexp = FINFUNC\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field oexp = FINFUNC",
            "unfolding oexp_def FinFunc_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> g \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} = Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)",
            "by (auto simp: Let_def Field_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_Refl: \"Refl oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Refl oexp",
            "unfolding refl_on_def Field_oexp",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. oexp \\<subseteq> FINFUNC \\<times> FINFUNC \\<and> (\\<forall>x\\<in>FINFUNC. (x, x) \\<in> oexp)",
            "unfolding oexp_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<subseteq> FINFUNC \\<times> FINFUNC \\<and> (\\<forall>x\\<in>FINFUNC. (x, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)})",
            "by (auto simp: Let_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_trans: \"trans oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. trans oexp",
            "proof (unfold trans_def, safe)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp",
            "fix f g h :: \"'b \\<Rightarrow> 'a\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp",
            "let ?fg = \"s.max_fun_diff f g\"\n  and ?gh = \"s.max_fun_diff g h\"\n  and ?fh = \"s.max_fun_diff f h\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp",
            "assume oexp: \"(f, g) \\<in> oexp\" \"(g, h) \\<in> oexp\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp",
            "thus \"(f, h) \\<in> oexp\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "proof (cases \"f = g \\<or> g = h\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (f = g \\<or> g = h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp",
            "with oexp",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\\<not> (f = g \\<or> g = h)",
            "have \"f \\<in> FINFUNC\" \"g \\<in> FINFUNC\" \"h \\<in> FINFUNC\"\n      \"(f ?fg, g ?fg) \\<in> r\" \"(g ?gh, h ?gh) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\\<not> (f = g \\<or> g = h)\n\ngoal (1 subgoal):\n 1. (f \\<in> FINFUNC &&& g \\<in> FINFUNC) &&& h \\<in> FINFUNC &&& (f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r &&& (g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r",
            "unfolding oexp_def Let_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n(g, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n\\<not> (f = g \\<or> g = h)\n\ngoal (1 subgoal):\n 1. (f \\<in> FINFUNC &&& g \\<in> FINFUNC) &&& h \\<in> FINFUNC &&& (f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r &&& (g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp",
            "note * = this False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "proof (cases \"f \\<noteq> h\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<noteq> h\n\ngoal (2 subgoals):\n 1. f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "proof (cases \"?fg = ?gh \\<longrightarrow> f ?fg \\<noteq> h ?gh\")",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h) \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp",
            "case True",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h) \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "using max_fun_diff_max2[of f g h, OF True] * \\<open>f \\<noteq> h\\<close> max_fun_diff_in\n          r.max2_iff[OF FINFUNCD FINFUNCD] r.max2_equals1[OF FINFUNCD FINFUNCD] max_fun_diff_le_eq\n          s.in_notinI[OF disjI1]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; g \\<noteq> h; f \\<noteq> h; f \\<in> FINFUNC; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\nf \\<noteq> h\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> ((r.max2 (?f2 ?x2) (?f1 ?x1), ?c) \\<in> r) = ((?f2 ?x2, ?c) \\<in> r \\<and> (?f1 ?x1, ?c) \\<in> r)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (r.max2 (?f2 ?x2) (?f1 ?x1) = ?f2 ?x2) = ((?f1 ?x1, ?f2 ?x2) \\<in> r)\n\\<lbrakk>(s.max_fun_diff ?f ?g, ?x) \\<in> s; ?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC; ?x \\<noteq> s.max_fun_diff ?f ?g\\<rbrakk> \\<Longrightarrow> ?f ?x = ?g ?x\n\\<lbrakk>(?j, ?i) \\<notin> s; ?i \\<in> Field s; ?j \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?i, ?j) \\<in> s\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "unfolding oexp_def Let_def s.max2_def mem_Collect_eq",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; g \\<noteq> h; f \\<noteq> h; f \\<in> FINFUNC; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\nf \\<noteq> h\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> Field s \\<and> ?f (s.max_fun_diff ?f ?g) \\<noteq> ?g (s.max_fun_diff ?f ?g)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> ((r.max2 (?f2 ?x2) (?f1 ?x1), ?c) \\<in> r) = ((?f2 ?x2, ?c) \\<in> r \\<and> (?f1 ?x1, ?c) \\<in> r)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (r.max2 (?f2 ?x2) (?f1 ?x1) = ?f2 ?x2) = ((?f1 ?x1, ?f2 ?x2) \\<in> r)\n\\<lbrakk>(s.max_fun_diff ?f ?g, ?x) \\<in> s; ?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC; ?x \\<noteq> s.max_fun_diff ?f ?g\\<rbrakk> \\<Longrightarrow> ?f ?x = ?g ?x\n\\<lbrakk>(?j, ?i) \\<notin> s; ?i \\<in> Field s; ?j \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?i, ?j) \\<in> s\n\ngoal (1 subgoal):\n 1. case (f, h) of (f, g) \\<Rightarrow> f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)",
            "by safe metis",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp",
            "case False",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp",
            "with *",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp",
            "unfolding oexp_def Let_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "using antisymD[OF r.ANTISYM, of \"g ?gh\" \"h ?gh\"] max_fun_diff_in[of g h]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\\<lbrakk>(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r; (h (s.max_fun_diff g h), g (s.max_fun_diff g h)) \\<in> r\\<rbrakk> \\<Longrightarrow> g (s.max_fun_diff g h) = h (s.max_fun_diff g h)\n\\<lbrakk>g \\<noteq> h; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp",
            "qed (auto simp: oexp_def *(3))",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp",
            "qed auto",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_Preorder: \"Preorder oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Preorder oexp",
            "unfolding preorder_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Refl oexp \\<and> trans oexp",
            "using oexp_Refl oexp_trans",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nRefl oexp\ntrans oexp\n\ngoal (1 subgoal):\n 1. Refl oexp \\<and> trans oexp",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_antisym: \"antisym oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. antisym oexp",
            "proof (unfold antisym_def, safe, rule ccontr)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False",
            "fix f g",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False",
            "assume \"(f, g) \\<in> oexp\" \"(g, f) \\<in> oexp\" \"g \\<noteq> f\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False",
            "thus False",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\ngoal (1 subgoal):\n 1. False",
            "using refl_onD[OF r.REFL FINFUNCD] max_fun_diff_in",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\\<lbrakk>?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?f1 ?x1, ?f1 ?x1) \\<in> r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. False",
            "unfolding oexp_def Let_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n(g, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\ng \\<noteq> f\n\\<lbrakk>?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?f1 ?x1, ?f1 ?x1) \\<in> r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. False",
            "by (auto dest!: antisymD[OF r.ANTISYM] simp: s.max_fun_diff_commute)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_Partial_order: \"Partial_order oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Partial_order oexp",
            "unfolding partial_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Preorder oexp \\<and> antisym oexp",
            "using oexp_Preorder oexp_antisym",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nPreorder oexp\nantisym oexp\n\ngoal (1 subgoal):\n 1. Preorder oexp \\<and> antisym oexp",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_Total: \"Total oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Total oexp",
            "unfolding total_on_def Field_oexp",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> oexp \\<or> (y, x) \\<in> oexp",
            "unfolding oexp_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<or> (y, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}",
            "using FINFUNCD max_fun_diff_in",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>?f \\<in> FINFUNC; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> ?f ?x \\<in> Field r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<or> (y, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}",
            "by (auto simp: Let_def s.max_fun_diff_commute intro!: r.in_notinI)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_Linear_order: \"Linear_order oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Linear_order oexp",
            "unfolding linear_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Partial_order oexp \\<and> Total oexp",
            "using oexp_Partial_order oexp_Total",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nPartial_order oexp\nTotal oexp\n\ngoal (1 subgoal):\n 1. Partial_order oexp \\<and> Total oexp",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "definition \"const = (\\<lambda>x. if x \\<in> Field s then r.zero else undefined)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma const_in[simp]: \"x \\<in> Field s \\<Longrightarrow> const x = r.zero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field s \\<Longrightarrow> const x = r.zero",
            "unfolding const_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field s \\<Longrightarrow> (if x \\<in> Field s then r.zero else undefined) = r.zero",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma const_notin[simp]: \"x \\<notin> Field s \\<Longrightarrow> const x = undefined\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Field s \\<Longrightarrow> const x = undefined",
            "unfolding const_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Field s \\<Longrightarrow> (if x \\<in> Field s then r.zero else undefined) = undefined",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma const_Int_Field[simp]: \"Field s \\<inter> - {x. const x = r.zero} = {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field s \\<inter> - {x. const x = r.zero} = {}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma const_FINFUNC[simp]: \"Field r \\<noteq> {} \\<Longrightarrow> const \\<in> FINFUNC\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> const \\<in> FINFUNC",
            "unfolding FinFunc_def Func_def fin_support_def support_def const_def Int_iff mem_Collect_eq",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> ((\\<forall>a\\<in>Field s. (if a \\<in> Field s then r.zero else undefined) \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> (if a \\<in> Field s then r.zero else undefined) = undefined)) \\<and> finite {x \\<in> Field s. (if x \\<in> Field s then r.zero else undefined) \\<noteq> r.zero}",
            "using r.zero_in_Field",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {} \\<Longrightarrow> r.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> ((\\<forall>a\\<in>Field s. (if a \\<in> Field s then r.zero else undefined) \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> (if a \\<in> Field s then r.zero else undefined) = undefined)) \\<and> finite {x \\<in> Field s. (if x \\<in> Field s then r.zero else undefined) \\<noteq> r.zero}",
            "by (metis (lifting) Collect_empty_eq finite.emptyI)",
            1,
            "NA"
        ],
        [
            "",
            "lemma const_least:\n  assumes \"Field r \\<noteq> {}\" \"f \\<in> FINFUNC\"\n  shows \"(const, f) \\<in> oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "proof (cases \"f = const\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f = const \\<Longrightarrow> (const, f) \\<in> oexp\n 2. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf = const\n\ngoal (2 subgoals):\n 1. f = const \\<Longrightarrow> (const, f) \\<in> oexp\n 2. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = const\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "using refl_onD[OF oexp_Refl] assms(2)",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = const\n?a \\<in> Field oexp \\<Longrightarrow> (?a, ?a) \\<in> oexp\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "unfolding Field_oexp",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf = const\n?a \\<in> FINFUNC \\<Longrightarrow> (?a, ?a) \\<in> oexp\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(const, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp",
            "with assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "using max_fun_diff_in[of f const]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\\<lbrakk>f \\<noteq> const; f \\<in> FINFUNC; const \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f const \\<in> {a \\<in> Field s. f a \\<noteq> const a}\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp",
            "unfolding oexp_def Let_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\\<lbrakk>f \\<noteq> const; f \\<in> FINFUNC; const \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f const \\<in> {a \\<in> Field s. f a \\<noteq> const a}\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "by (auto intro: r.zero_smallest FinFuncD simp: s.max_fun_diff_commute)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(const, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma support_not_const:\n  assumes \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s",
            "proof (intro ballI conjI)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s",
            "fix f",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s",
            "assume \"f \\<in> F\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> F\n\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s",
            "thus \"finite (SUPP f)\" \"SUPP f \\<subseteq> Field s\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\n\ngoal (1 subgoal):\n 1. finite (SUPP f) &&& SUPP f \\<subseteq> Field s",
            "using assms(1)",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. finite (SUPP f) &&& SUPP f \\<subseteq> Field s",
            "unfolding FinFunc_def fin_support_def support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. finite {x \\<in> Field s. f x \\<noteq> r.zero} &&& {x \\<in> Field s. f x \\<noteq> r.zero} \\<subseteq> Field s",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (SUPP f)\nSUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}",
            "show \"SUPP f \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. SUPP f \\<noteq> {}",
            "proof (rule ccontr, unfold not_not)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False",
            "assume \"SUPP f = {}\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nSUPP f = {}\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nSUPP f = {}\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False",
            "from \\<open>f \\<in> F\\<close> assms(1)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> F\nF \\<subseteq> FINFUNC",
            "have \"f \\<in> FINFUNC\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. f \\<in> FINFUNC",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nSUPP f = {}\nf \\<in> FINFUNC",
            "have \"f = const\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nSUPP f = {}\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f = const",
            "by (auto simp: fun_eq_iff support_def FinFunc_def Func_def const_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf = const\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False",
            "with assms(2) \\<open>f \\<in> F\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nconst \\<notin> F\nf \\<in> F\nf = const",
            "show False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nconst \\<notin> F\nf \\<in> F\nf = const\n\ngoal (1 subgoal):\n 1. False",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nSUPP f \\<noteq> {}\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma maxim_isMaxim_support:\n  assumes f: \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))",
            "using support_not_const[OF assms]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))",
            "by (auto intro!: s.maxim_isMaxim)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_empty2: \"Field s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}",
            "unfolding oexp_def FinFunc_def fin_support_def support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field s = {} \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> g \\<in> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_empty: \"\\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}",
            "unfolding oexp_def FinFunc_def Let_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> g \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)} = {}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma fun_upd_FINFUNC: \"\\<lbrakk>f \\<in> FINFUNC; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> FINFUNC\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FINFUNC; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> FINFUNC",
            "unfolding FinFunc_def Func_def fin_support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (SUPP f)}; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (SUPP f)}",
            "by (auto intro: finite_subset[OF support_upd_subset])",
            1,
            "NA"
        ],
        [
            "",
            "lemma fun_upd_same_oexp:\n  assumes \"(f, g) \\<in> oexp\" \"f x = g x\" \"x \\<in> Field s\" \"y \\<in> Field r\"\n  shows   \"(f(x := y), g(x := y)) \\<in> oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "from assms(1) fun_upd_FINFUNC[OF _ assms(3,4)]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(f, g) \\<in> oexp\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC",
            "have fg: \"f(x := y) \\<in> FINFUNC\" \"g(x := y) \\<in> FINFUNC\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> oexp\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f(x := y) \\<in> FINFUNC &&& g(x := y) \\<in> FINFUNC",
            "unfolding oexp_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f(x := y) \\<in> FINFUNC &&& g(x := y) \\<in> FINFUNC",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "from assms(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf x = g x",
            "have \"s.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g",
            "unfolding s.max_fun_diff_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. s.maxim {a \\<in> Field s. (f(x := y)) a \\<noteq> (g(x := y)) a} = s.maxim {a \\<in> Field s. f a \\<noteq> g a}",
            "by auto metis",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "using assms refl_onD[OF r.REFL]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n(f, g) \\<in> oexp\nf x = g x\nx \\<in> Field s\ny \\<in> Field r\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp",
            "unfolding oexp_def Let_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\nf x = g x\nx \\<in> Field s\ny \\<in> Field r\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f(x := y), g(x := y)) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma fun_upd_smaller_oexp:\n  assumes \"f \\<in> FINFUNC\" \"x \\<in> Field s\" \"y \\<in> Field r\"  \"(y, f x) \\<in> r\"\n  shows   \"(f(x := y), f) \\<in> oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> oexp",
            "using assms fun_upd_FINFUNC[OF assms(1-3)] s.maxim_singleton[of \"x\"]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> FINFUNC\nx \\<in> Field s\ny \\<in> Field r\n(y, f x) \\<in> r\nf(x := y) \\<in> FINFUNC\nx \\<in> Field s \\<Longrightarrow> s.maxim {x} = x\n\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> oexp",
            "unfolding oexp_def FinFunc_def Let_def fin_support_def s.max_fun_diff_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)}\nx \\<in> Field s\ny \\<in> Field r\n(y, f x) \\<in> r\nf(x := y) \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)}\nx \\<in> Field s \\<Longrightarrow> s.maxim {x} = x\n\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)} \\<and> g \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)} \\<and> ((f (s.maxim {a \\<in> Field s. f a \\<noteq> g a}), g (s.maxim {a \\<in> Field s. f a \\<noteq> g a})) \\<in> r \\<or> f = g)}",
            "by (auto simp: fun_eq_iff)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_wf_Id: \"wf (oexp - Id)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (oexp - Id)",
            "proof (cases \"Field r = {} \\<or> Field s = {}\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. Field r = {} \\<or> Field s = {} \\<Longrightarrow> wf (oexp - Id)\n 2. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r = {} \\<or> Field s = {}\n\ngoal (2 subgoals):\n 1. Field r = {} \\<or> Field s = {} \\<Longrightarrow> wf (oexp - Id)\n 2. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r = {} \\<or> Field s = {}\n\ngoal (1 subgoal):\n 1. wf (oexp - Id)",
            "using oexp_empty oexp_empty2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r = {} \\<or> Field s = {}\n\\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}\nField s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\n\ngoal (1 subgoal):\n 1. wf (oexp - Id)",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (oexp - Id)\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (Field r = {} \\<or> Field s = {})\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "hence Fields: \"Field s \\<noteq> {}\" \"Field r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (Field r = {} \\<or> Field s = {})\n\ngoal (1 subgoal):\n 1. Field s \\<noteq> {} &&& Field r \\<noteq> {}",
            "by simp_all",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField s \\<noteq> {}\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "hence [simp]: \"r.zero \\<in> Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField s \\<noteq> {}\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r.zero \\<in> Field r",
            "by (intro r.zero_in_Field)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "have const[simp]: \"\\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "using const_least[OF Fields(2)]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?f \\<in> FINFUNC \\<Longrightarrow> (const, ?f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<lbrakk>const \\<in> ?F1; ?F1 \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>?F1. \\<forall>f\\<in>?F1. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wf (oexp - Id)",
            "unfolding Linear_order_wf_diff_Id[OF oexp_Linear_order] Field_oexp",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<subseteq>FINFUNC. A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp)",
            "proof (intro allI impI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "fix A",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "assume A: \"A \\<subseteq> FINFUNC\" \"A \\<noteq> {}\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<subseteq> FINFUNC\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nA \\<subseteq> FINFUNC\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "fix y F",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "have \"F \\<subseteq> FINFUNC \\<and> (\\<exists>f \\<in> F. y = s.maxim (SUPP f)) \\<longrightarrow>\n        (\\<exists>f0 \\<in> F. \\<forall>f \\<in> F. (f0, f) \\<in> oexp)\" (is \"?P F y\")",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)",
            "proof (induct y arbitrary: F rule: s.well_order_induct)",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<forall>y. y \\<noteq> x \\<and> (y, x) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp)) \\<Longrightarrow> F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. x = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)",
            "case (1 y)",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>y. y \\<noteq> y \\<and> (y, y) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<forall>y. y \\<noteq> x \\<and> (y, x) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp)) \\<Longrightarrow> F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. x = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)",
            "show ?case",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)",
            "proof (intro impI, elim conjE bexE)",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "fix f",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "assume F: \"F \\<subseteq> FINFUNC\" \"f \\<in> F\" \"y = s.maxim (SUPP f)\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "thus \"\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "proof (cases \"const \\<in> F\")",
            11,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "case False",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nconst \\<notin> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "with F",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F",
            "have maxF: \"\\<forall>f \\<in> F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\"\n              and SUPPF: \"\\<forall>f \\<in> F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f)) &&& \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s",
            "using maxim_isMaxim_support support_not_const",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f)) &&& \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "define z where \"z = s.minim {s.maxim (SUPP f) | f. f \\<in> F}\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz = s.minim {s.maxim (SUPP f) |f. f \\<in> F}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from F SUPPF maxF",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))",
            "have zmin: \"s.isMinim {s.maxim (SUPP f) | f. f \\<in> F} z\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z",
            "unfolding z_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> F} (s.minim {s.maxim (SUPP f) |f. f \\<in> F})",
            "by (intro s.minim_isMinim) (auto simp: s.isMaxim_def)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "with F",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z",
            "have zy: \"(z, y) \\<in> s\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> s",
            "unfolding s.isMinim_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> s",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(z, y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "hence zField: \"z \\<in> Field s\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, y) \\<in> s\n\ngoal (1 subgoal):\n 1. z \\<in> Field s",
            "unfolding Field_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, y) \\<in> s\n\ngoal (1 subgoal):\n 1. z \\<in> Domain s \\<union> Range s",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "define x0 where \"x0 = r.minim {f z | f. f \\<in> F \\<and> z = s.maxim (SUPP f)}\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx0 = r.minim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from F(1,2) maxF(1) SUPPF zmin",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z",
            "have x0min: \"r.isMinim {f z | f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (1 subgoal):\n 1. r.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0",
            "unfolding x0_def s.isMaxim_def s.isMinim_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\n\ngoal (1 subgoal):\n 1. r.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} (r.minim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)})",
            "by (blast intro!: r.minim_isMinim FinFuncD[of _ r s])",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "with maxF(1) SUPPF F(1)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0",
            "have x0Field: \"x0 \\<in> Field r\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (1 subgoal):\n 1. x0 \\<in> Field r",
            "unfolding r.isMinim_def s.isMaxim_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\n\ngoal (1 subgoal):\n 1. x0 \\<in> Field r",
            "by (auto intro!: FINFUNCD)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx0 \\<in> Field r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from x0min maxF(1) SUPPF F(1)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC",
            "have x0notzero: \"x0 \\<noteq> r.zero\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> r.zero",
            "unfolding r.isMinim_def s.isMaxim_def FinFunc_def Func_def support_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}}. (x0, a) \\<in> r)\n\\<forall>f\\<in>F. s.maxim {x \\<in> Field s. f x \\<noteq> r.zero} \\<in> {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> (\\<forall>a\\<in>{x \\<in> Field s. f x \\<noteq> r.zero}. (a, s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}) \\<in> s)\n\\<forall>f\\<in>F. finite {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> {x \\<in> Field s. f x \\<noteq> r.zero} \\<noteq> {} \\<and> {x \\<in> Field s. f x \\<noteq> r.zero} \\<subseteq> Field s\nF \\<subseteq> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> r.zero",
            "by fastforce",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx0 \\<noteq> r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "define G where \"G = {f(z := r.zero) | f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG = {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from zmin x0min",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0",
            "have \"G \\<noteq> {}\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (1 subgoal):\n 1. G \\<noteq> {}",
            "unfolding G_def z_def s.isMinim_def r.isMinim_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.minim {s.maxim (SUPP f) |f. f \\<in> F} \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (s.minim {s.maxim (SUPP f) |f. f \\<in> F}, a) \\<in> s)\nx0 \\<in> {f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f)}. (x0, a) \\<in> r)\n\ngoal (1 subgoal):\n 1. {f(s.minim {s.maxim (SUPP f) |f. f \\<in> F} := r.zero) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f) \\<and> f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) = x0} \\<noteq> {}",
            "by blast",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "have GF: \"G \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F",
            "unfolding G_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0} \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "have \"G \\<subseteq> fin_support r.zero (Field s)\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> fin_support r.zero (Field s)",
            "unfolding FinFunc_def fin_support_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> {f. finite (SUPP f)}",
            "proof safe",
            13,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)",
            "fix g",
            14,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)",
            "assume \"g \\<in> G\"",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)",
            "with GF",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\ng \\<in> G",
            "obtain f where f: \"f \\<in> F\" \"g = f(z := r.zero)\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\ng \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> F\ng = f(z := r.zero)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)",
            "with SUPPF",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)",
            "have \"finite (SUPP f)\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\n\ngoal (1 subgoal):\n 1. finite (SUPP f)",
            "by blast",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)",
            "with f",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> F\ng = f(z := r.zero)\nfinite (SUPP f)",
            "show \"finite (SUPP g)\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\ng = f(z := r.zero)\nfinite (SUPP f)\n\ngoal (1 subgoal):\n 1. finite (SUPP g)",
            "by (elim finite_subset[rotated]) (auto simp: support_def)",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (SUPP g)\n\ngoal:\nNo subgoals!",
            "qed",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<subseteq> fin_support r.zero (Field s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "moreover",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<subseteq> fin_support r.zero (Field s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from F GF zField",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s",
            "have \"G \\<subseteq> Func (Field s) (Field r)\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)",
            "using Func_upd[of _ \"Field s\" \"Field r\" z r.zero]",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\\<lbrakk>?f \\<in> Func (Field s) (Field r); z \\<in> Field s; r.zero \\<in> Field r\\<rbrakk> \\<Longrightarrow> ?f(z := r.zero) \\<in> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)",
            "unfolding FinFunc_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF \\<subseteq> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\\<lbrakk>?f \\<in> Func (Field s) (Field r); z \\<in> Field s; r.zero \\<in> Field r\\<rbrakk> \\<Longrightarrow> ?f(z := r.zero) \\<in> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "ultimately",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)",
            "have G: \"G \\<subseteq> FINFUNC\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> FINFUNC",
            "unfolding FinFunc_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)",
            "by blast",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nG \\<subseteq> FINFUNC\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "hence \"\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "proof (cases \"const \\<in> G\")",
            13,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "case False",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\nconst \\<notin> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "with G",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G",
            "have maxG: \"\\<forall>g \\<in> G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\"\n                and SUPPG: \"\\<forall>g \\<in> G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g)) &&& \\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s",
            "using maxim_isMaxim_support support_not_const",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g)) &&& \\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "define y' where \"y' = s.minim {s.maxim (SUPP f) | f. f \\<in> G}\"",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny' = s.minim {s.maxim (SUPP f) |f. f \\<in> G}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "from G SUPPG maxG \\<open>G \\<noteq> {}\\<close>",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}",
            "have y'min: \"s.isMinim {s.maxim (SUPP f) | f. f \\<in> G} y'\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'",
            "unfolding y'_def",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> G} (s.minim {s.maxim (SUPP f) |f. f \\<in> G})",
            "by (intro s.minim_isMinim) (auto simp: s.isMaxim_def)",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "moreover",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "have \"\\<forall>g \\<in> G. z \\<notin> SUPP g\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. z \\<notin> SUPP g",
            "unfolding support_def G_def",
            15,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>{f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> f z = x0}. z \\<notin> {x \\<in> Field s. g x \\<noteq> r.zero}",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "moreover",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "{",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "fix g",
            16,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "assume g: \"g \\<in> G\"",
            16,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "then",
            16,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng \\<in> G",
            "obtain f where \"f \\<in> F\" \"g = f(z := r.zero)\" and z: \"z = s.maxim (SUPP f)\"",
            16,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero); z = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding G_def",
            17,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero); z = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            17,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "with SUPPF bspec[OF SUPPG g]",
            16,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)",
            "have \"(s.maxim (SUPP g), z) \\<in> s\"",
            16,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP g), z) \\<in> s",
            "unfolding z",
            17,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(s.maxim (SUPP f) := r.zero)\ns.maxim (SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP g), s.maxim (SUPP f)) \\<in> s",
            "by (intro s.maxim_mono) auto",
            17,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.maxim (SUPP g), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "}",
            16,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "moreover",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "from y'min",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'",
            "have \"\\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s",
            "unfolding s.isMinim_def",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny' \\<in> {s.maxim (SUPP f) |f. f \\<in> G} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> G}. (y', a) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "ultimately",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s",
            "have \"y' \\<noteq> z\" \"(y', z) \\<in> s\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s",
            "using maxG",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s",
            "unfolding s.isMinim_def s.isMaxim_def",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny' \\<in> {s.maxim (SUPP f) |f. f \\<in> G} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> G}. (y', a) \\<in> s)\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\\<forall>g\\<in>G. s.maxim (SUPP g) \\<in> SUPP g \\<and> (\\<forall>a\\<in>SUPP g. (a, s.maxim (SUPP g)) \\<in> s)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny' \\<noteq> z\n(y', z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "with zy",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s",
            "have \"y' \\<noteq> y\" \"(y', y) \\<in> s\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y &&& (y', y) \\<in> s",
            "using antisymD[OF s.ANTISYM] transD[OF s.TRANS]",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, ?z) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, ?z) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y &&& (y', y) \\<in> s",
            "by blast+",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny' \\<noteq> y\n(y', y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "moreover",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny' \\<noteq> y\n(y', y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "from \\<open>G \\<noteq> {}\\<close>",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nG \\<noteq> {}",
            "have \"\\<exists>g \\<in> G. y' = wo_rel.maxim s (SUPP g)\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>G. y' = s.maxim (SUPP g)",
            "using y'min",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nG \\<noteq> {}\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>G. y' = s.maxim (SUPP g)",
            "by (auto simp: G_def s.isMinim_def)",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "ultimately",
            14,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)",
            "show ?thesis",
            14,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "using mp[OF spec[OF mp[OF spec[OF 1]]], of y' G] G",
            15,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\\<lbrakk>y' \\<noteq> y \\<and> (y', y) \\<in> s; G \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>G. y' = s.maxim (SUPP f))\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>G. \\<forall>f\\<in>G. (f0, f) \\<in> oexp\nG \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "by auto",
            15,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "qed simp",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "then",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp",
            "obtain g0 where g0: \"g0 \\<in> G\" \"\\<forall>g \\<in> G. (g0, g) \\<in> oexp\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (\\<And>g0. \\<lbrakk>g0 \\<in> G; \\<forall>g\\<in>G. (g0, g) \\<in> oexp\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng0 \\<in> G\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "hence g0z: \"g0 z = r.zero\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 \\<in> G\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. g0 z = r.zero",
            "unfolding G_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\\<forall>g\\<in>{f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. g0 z = r.zero",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng0 z = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "define f0 where \"f0 = g0(z := x0)\"",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 = g0(z := x0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "with x0notzero zField",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)",
            "have SUPP: \"SUPP f0 = SUPP g0 \\<union> {z}\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)\n\ngoal (1 subgoal):\n 1. SUPP f0 = SUPP g0 \\<union> {z}",
            "unfolding support_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)\n\ngoal (1 subgoal):\n 1. {x \\<in> Field s. f0 x \\<noteq> r.zero} = {x \\<in> Field s. g0 x \\<noteq> r.zero} \\<union> {z}",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nSUPP f0 = SUPP g0 \\<union> {z}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from g0z",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng0 z = r.zero",
            "have f0z: \"f0(z := r.zero) = g0\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 z = r.zero\n\ngoal (1 subgoal):\n 1. f0(z := r.zero) = g0",
            "unfolding f0_def fun_upd_upd",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 z = r.zero\n\ngoal (1 subgoal):\n 1. g0(z := r.zero) = g0",
            "by auto",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0(z := r.zero) = g0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "have f0: \"f0 \\<in> F\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<in> F",
            "using x0min g0(1)\n              Func_elim[OF subsetD[OF subset_trans[OF F(1)[unfolded FinFunc_def] Int_lower1]] zField]",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ng0 \\<in> G\n?g \\<in> F \\<Longrightarrow> \\<exists>b. b \\<in> Field r \\<and> ?g z = b\n\ngoal (1 subgoal):\n 1. f0 \\<in> F",
            "unfolding f0_def r.isMinim_def G_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n?g \\<in> F \\<Longrightarrow> \\<exists>b. b \\<in> Field r \\<and> ?g z = b\n\ngoal (1 subgoal):\n 1. g0(z := x0) \\<in> F",
            "by (force simp: fun_upd_idem)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 \\<in> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "from g0(1) maxF(1)",
            12,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng0 \\<in> G\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))",
            "have maxf0: \"s.maxim (SUPP f0) = z\"",
            12,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 \\<in> G\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0) = z",
            "unfolding SUPP G_def",
            13,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP g0 \\<union> {z}) = z",
            "by (intro s.maxim_equality) (auto simp: s.isMaxim_def)",
            13,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f0) = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "show ?thesis",
            12,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "proof (intro bexI[OF _ f0] ballI)",
            13,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp",
            "fix f",
            14,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp",
            "assume f: \"f \\<in> F\"",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp",
            "show \"(f0, f) \\<in> oexp\"",
            14,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "proof (cases \"f0 = f\")",
            15,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f0 = f \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case True",
            16,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 = f\n\ngoal (2 subgoals):\n 1. f0 = f \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp",
            "thus ?thesis",
            16,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 = f\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "by (metis F(1) Field_oexp f0 in_mono oexp_Refl refl_onD)",
            17,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp",
            "next",
            16,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case False",
            16,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 \\<noteq> f\n\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp",
            "thus ?thesis",
            16,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 \\<noteq> f\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "proof (cases \"s.maxim (SUPP f) = z \\<and> f z = x0\")",
            17,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case True",
            18,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with f",
            18,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0",
            "have \"f(z := r.zero) \\<in> G\"",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (1 subgoal):\n 1. f(z := r.zero) \\<in> G",
            "unfolding G_def",
            19,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (1 subgoal):\n 1. f(z := r.zero) \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}",
            "by blast",
            19,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf(z := r.zero) \\<in> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with g0(2) f0z",
            18,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\nf0(z := r.zero) = g0\nf(z := r.zero) \\<in> G",
            "have \"(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\"",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\nf0(z := r.zero) = g0\nf(z := r.zero) \\<in> G\n\ngoal (1 subgoal):\n 1. (f0(z := r.zero), f(z := r.zero)) \\<in> oexp",
            "by auto",
            19,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "hence oexp: \"(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\"",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp",
            "by (elim fun_upd_same_oexp[OF _ _ zField x0Field]) simp",
            19,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with f F(1) x0min True",
            18,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp",
            "have \"(f(z := x0), f) \\<in> oexp\"",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f(z := x0), f) \\<in> oexp",
            "unfolding G_def r.isMinim_def",
            19,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f(z := x0), f) \\<in> oexp",
            "by (intro fun_upd_smaller_oexp[OF _ zField x0Field]) auto",
            19,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f(z := x0), f) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with oexp",
            18,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp",
            "show ?thesis",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "using transD[OF oexp_trans, of f0 \"f(z := x0)\" f]",
            19,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\\<lbrakk>(f0, f(z := x0)) \\<in> oexp; (f(z := x0), f) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "unfolding f0_def",
            19,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(g0(z := x0, z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\\<lbrakk>(g0(z := x0), f(z := x0)) \\<in> oexp; (f(z := x0), f) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (g0(z := x0), f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (g0(z := x0), f) \\<in> oexp",
            "by auto",
            19,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "next",
            18,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case False",
            18,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "note notG = this",
            18,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "thus ?thesis",
            18,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "proof (cases \"s.maxim (SUPP f) = z\")",
            19,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case True",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f) = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with notG",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z",
            "have \"f0 z \\<noteq> f z\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z\n\ngoal (1 subgoal):\n 1. f0 z \\<noteq> f z",
            "unfolding f0_def",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z\n\ngoal (1 subgoal):\n 1. (g0(z := x0)) z \\<noteq> f z",
            "by auto",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 z \\<noteq> f z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "hence \"f0 z \\<noteq> f z\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 z \\<noteq> f z\n\ngoal (1 subgoal):\n 1. f0 z \\<noteq> f z",
            "by metis",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 z \\<noteq> f z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with True maxf0 f0 f SUPPF",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z",
            "have \"s.max_fun_diff f0 f = z\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = z",
            "using s.maxim_Un[of \"SUPP f0\" \"SUPP f\", unfolded s.max2_def]",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = (if (s.maxim (SUPP f0), s.maxim (SUPP f)) \\<in> s then s.maxim (SUPP f) else s.maxim (SUPP f0))\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = z",
            "unfolding max_fun_diff_alt",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = (if (s.maxim (SUPP f0), s.maxim (SUPP f)) \\<in> s then s.maxim (SUPP f) else s.maxim (SUPP f0))\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = z",
            "by (intro trans[OF s.maxim_Int]) auto",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f0 f = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "moreover",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f0 f = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "from x0min True f",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z\nf \\<in> F",
            "have \"(x0, f z) \\<in> r\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (x0, f z) \\<in> r",
            "unfolding r.isMinim_def",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ns.maxim (SUPP f) = z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (x0, f z) \\<in> r",
            "by auto",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(x0, f z) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "ultimately",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r",
            "show ?thesis",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "using f f0 F(1)",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "unfolding oexp_def f0_def",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff (g0(z := x0)) f = z\n(x0, f z) \\<in> r\nf \\<in> F\ng0(z := x0) \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. (g0(z := x0), f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}",
            "by auto",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "next",
            20,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "case False",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f) \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with notG",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z",
            "have *: \"(z, s.maxim (SUPP f)) \\<in> s\" \"z \\<noteq> s.maxim (SUPP f)\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)",
            "using zmin f",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)",
            "unfolding s.isMinim_def G_def",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)",
            "by auto",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "have f0f: \"f0 (s.maxim (SUPP f)) = r.zero\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) = r.zero",
            "proof (rule ccontr)",
            21,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False",
            "assume \"f0 (s.maxim (SUPP f)) \\<noteq> r.zero\"",
            22,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False",
            "with f SUPPF maxF(1)",
            22,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero",
            "have \"s.maxim (SUPP f) \\<in> SUPP f0\"",
            22,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f) \\<in> SUPP f0",
            "unfolding support_def[of _ _ f0] s.isMaxim_def",
            23,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f) \\<in> {x \\<in> Field s. f0 x \\<noteq> r.zero}",
            "by auto",
            23,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False",
            "with SUPPF f0",
            22,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0",
            "have \"(s.maxim (SUPP f), z) \\<in> s\"",
            22,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP f), z) \\<in> s",
            "unfolding maxf0[symmetric]",
            23,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP f), s.maxim (SUPP f0)) \\<in> s",
            "by (auto intro: s.maxim_greatest)",
            23,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(s.maxim (SUPP f), z) \\<in> s\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False",
            "with * antisymD[OF s.ANTISYM]",
            22,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n(s.maxim (SUPP f), z) \\<in> s",
            "show False",
            22,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n(s.maxim (SUPP f), z) \\<in> s\n\ngoal (1 subgoal):\n 1. False",
            "by simp",
            23,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            22,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 (s.maxim (SUPP f)) = r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "moreover",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf0 (s.maxim (SUPP f)) = r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "have \"f (s.maxim (SUPP f)) \\<noteq> r.zero\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. f (s.maxim (SUPP f)) \\<noteq> r.zero",
            "using bspec[OF maxF(1) f, unfolded s.isMaxim_def]",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\ngoal (1 subgoal):\n 1. f (s.maxim (SUPP f)) \\<noteq> r.zero",
            "by (auto simp: support_def)",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "with f0f * f f0 maxf0 SUPPF",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero",
            "have \"s.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)",
            "unfolding max_fun_diff_alt",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = s.maxim (SUPP f0 \\<union> SUPP f)",
            "using s.maxim_Un[of \"SUPP f0\" \"SUPP f\"]",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = s.max2 (s.maxim (SUPP f0)) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = s.maxim (SUPP f0 \\<union> SUPP f)",
            "by (intro s.maxim_Int) (auto simp: s.max2_def)",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "moreover",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "have \"s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\"",
            20,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)",
            "using s.maxim_Un[of \"SUPP f0\" \"SUPP f\"] * maxf0 SUPPF f0 f",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = s.max2 (s.maxim (SUPP f0)) (s.maxim (SUPP f))\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\nf \\<in> F\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)",
            "by (auto simp: s.max2_def)",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp",
            "ultimately",
            20,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)",
            "show ?thesis",
            20,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "using f f0 F(1) maxF(1) SUPPF",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp",
            "unfolding oexp_def Let_def",
            21,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "by (fastforce simp: s.isMaxim_def intro!: r.zero_smallest FINFUNCD)",
            21,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            20,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            18,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            16,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            14,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp",
            "qed simp",
            12,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?F3 \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>?F3. ?y3 = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>?F3. \\<forall>f\\<in>?F3. (f0, f) \\<in> oexp)\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "note * = mp[OF this]",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?F4 \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>?F4. ?y4 = s.maxim (SUPP f)) \\<Longrightarrow> \\<exists>f0\\<in>?F4. \\<forall>f\\<in>?F4. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "from A(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<noteq> {}",
            "obtain f where f: \"f \\<in> A\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "with A(1)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nA \\<subseteq> FINFUNC\nf \\<in> A",
            "show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nA \\<subseteq> FINFUNC\nf \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "proof (cases \"f = const\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n 2. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f \\<noteq> const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf \\<noteq> const\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n 2. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f \\<noteq> const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "with f A(1)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const",
            "show ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "using maxim_isMaxim_support[of \"{f}\"]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const\n\\<lbrakk>{f} \\<subseteq> FINFUNC; const \\<notin> {f}\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>{f}. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "by (intro *[of _ \"s.maxim (SUPP f)\"]) (auto simp: s.isMaxim_def support_def)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp",
            "qed simp",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nwf (oexp - Id)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_Well_order: \"Well_order oexp\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order oexp",
            "unfolding well_order_on_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Linear_order oexp \\<and> wf (oexp - Id)",
            "using oexp_Linear_order oexp_wf_Id",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nLinear_order oexp\nwf (oexp - Id)\n\ngoal (1 subgoal):\n 1. Linear_order oexp \\<and> wf (oexp - Id)",
            "by blast",
            1,
            "NA"
        ],
        [
            "",
            "interpretation o: wo_rel oexp",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel oexp",
            "by unfold_locales (rule oexp_Well_order)",
            1,
            "NA"
        ],
        [
            "",
            "lemma zero_oexp: \"Field r \\<noteq> {} \\<Longrightarrow> o.zero = const\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> o.zero = const",
            "by (rule sym[OF o.leq_zero_imp[OF const_least]])\n    (auto intro!: o.zero_in_Field[unfolded Field_oexp] dest!: const_FINFUNC)",
            1,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "notation wo_rel2.oexp (infixl \"^o\" 90)",
            0,
            "NA"
        ],
        [
            "",
            "lemmas oexp_def = wo_rel2.oexp_def[unfolded wo_rel2_def, OF conjI]",
            0,
            "NA"
        ],
        [
            "",
            "lemmas oexp_Well_order = wo_rel2.oexp_Well_order[unfolded wo_rel2_def, OF conjI]",
            0,
            "NA"
        ],
        [
            "",
            "lemmas Field_oexp = wo_rel2.Field_oexp[unfolded wo_rel2_def, OF conjI]",
            0,
            "NA"
        ],
        [
            "",
            "definition \"ozero = {}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma ozero_Well_order[simp]: \"Well_order ozero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order ozero",
            "unfolding ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order {}",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma ozero_ordIso[simp]: \"ozero =o ozero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ozero =o ozero",
            "unfolding ozero_def ordIso_def iso_def[abs_def] embed_def bij_betw_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ({}, {}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f (under r a) \\<and> f ` under r a = under r' (f a)) \\<and> inj_on f (Field r) \\<and> f ` Field r = Field r')}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma Field_ozero[simp]: \"Field ozero = {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field ozero = {}",
            "unfolding ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field {} = {}",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma iso_ozero_empty[simp]: \"r =o ozero = (r = {})\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (r =o ozero) = (r = {})",
            "unfolding ozero_def ordIso_def iso_def[abs_def] embed_def bij_betw_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ((r, {}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f (under r a) \\<and> f ` under r a = under r' (f a)) \\<and> inj_on f (Field r) \\<and> f ` Field r = Field r')}) = (r = {})",
            "by (auto dest: well_order_on_domain)",
            1,
            "NA"
        ],
        [
            "",
            "lemma ozero_ordLeq:\nassumes \"Well_order r\"  shows \"ozero \\<le>o r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ozero \\<le>o r",
            "using assms",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ozero \\<le>o r",
            "unfolding ozero_def ordLeq_def embed_def[abs_def] under_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ({}, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. bij_betw f {b. (b, a) \\<in> r} {b. (b, f a) \\<in> r'})}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "definition \"oone = {((),())}\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma oone_Well_order[simp]: \"Well_order oone\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order oone",
            "unfolding oone_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order {((), ())}",
            "unfolding well_order_on_def linear_order_on_def partial_order_on_def\n    preorder_on_def total_on_def refl_on_def trans_def antisym_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (((({((), ())} \\<subseteq> Field {((), ())} \\<times> Field {((), ())} \\<and> (\\<forall>x\\<in>Field {((), ())}. (x, x) \\<in> {((), ())})) \\<and> (\\<forall>x y z. (x, y) \\<in> {((), ())} \\<longrightarrow> (y, z) \\<in> {((), ())} \\<longrightarrow> (x, z) \\<in> {((), ())})) \\<and> (\\<forall>x y. (x, y) \\<in> {((), ())} \\<longrightarrow> (y, x) \\<in> {((), ())} \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field {((), ())}. \\<forall>y\\<in>Field {((), ())}. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {((), ())} \\<or> (y, x) \\<in> {((), ())})) \\<and> wf ({((), ())} - Id)",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma Field_oone[simp]: \"Field oone = {()}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field oone = {()}",
            "unfolding oone_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field {((), ())} = {()}",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma oone_ordIso: \"oone =o {(x,x)}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. oone =o {(x, x)}",
            "unfolding ordIso_def oone_def well_order_on_def linear_order_on_def partial_order_on_def\n    preorder_on_def total_on_def refl_on_def trans_def antisym_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ({((), ())}, {(x, x)}) \\<in> {(r, r'). (((((r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r)) \\<and> (\\<forall>x y z. (x, y) \\<in> r \\<longrightarrow> (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r)) \\<and> (\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r)) \\<and> wf (r - Id)) \\<and> (((((r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')) \\<and> (\\<forall>x y z. (x, y) \\<in> r' \\<longrightarrow> (y, z) \\<in> r' \\<longrightarrow> (x, z) \\<in> r')) \\<and> (\\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r')) \\<and> wf (r' - Id)) \\<and> Ex (iso r r')}",
            "by (auto simp: iso_def embed_def bij_betw_def under_def inj_on_def intro!: exI[of _ \"\\<lambda>_. x\"])",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_ordLeqR: \"Well_order r \\<Longrightarrow> Well_order s \\<Longrightarrow> s \\<le>o r +o s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order s\\<rbrakk> \\<Longrightarrow> s \\<le>o r +o s",
            "unfolding ordLeq_def2 underS_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order s\\<rbrakk> \\<Longrightarrow> Well_order s \\<and> Well_order (r +o s) \\<and> (\\<exists>f. \\<forall>a\\<in>Field s. f a \\<in> Field (r +o s) \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> s} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> r +o s})",
            "by (auto intro!: exI[of _ Inr] osum_Well_order) (auto simp add: osum_def Field_def)",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r +o t =o s +o t\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr =o s",
            "obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "let ?f = \"map_sum f id\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_sum f id) (Field (r +o t))",
            "unfolding Field_osum iso_def bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field t. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field t. map_sum f id x = map_sum f id y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_sum f id) (Field (r +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "with f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f\ninj_on (map_sum f id) (Field (r +o t))",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\ninj_on (map_sum f id) (Field (r +o t))\n\ngoal (1 subgoal):\n 1. bij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))",
            "unfolding Field_osum iso_def bij_betw_def image_image image_Un",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_sum f id) (Inl ` Field r \\<union> Inr ` Field t)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum f id) (Inl ` Field r \\<union> Inr ` Field t) \\<and> (\\<lambda>x. map_sum f id (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum f id (Inr x)) ` Field t = Inl ` Field s \\<union> Inr ` Field t",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (r +o t) (s +o t) (map_sum f id)",
            "unfolding osum_def iso_iff3[OF r s] compat_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field t} \\<longrightarrow> (map_sum f id a, map_sum f id b) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t}",
            "by (auto simp: map_prod_imageI)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\ncompat (r +o t) (s +o t) (map_sum f id)",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\ncompat (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. iso (r +o t) (s +o t) (map_sum f id)",
            "by (subst iso_iff3) (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. (r +o t, s +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr +o t =o s +o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t +o r =o t +o s\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr =o s",
            "obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "let ?f = \"map_sum id f\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Field (t +o r))",
            "unfolding Field_osum iso_def bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field t \\<union> Inr ` Field r. \\<forall>y\\<in>Inl ` Field t \\<union> Inr ` Field r. map_sum id f x = map_sum id f y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_sum id f) (Field (t +o r))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "with f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f\ninj_on (map_sum id f) (Field (t +o r))",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\ninj_on (map_sum id f) (Field (t +o r))\n\ngoal (1 subgoal):\n 1. bij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))",
            "unfolding Field_osum iso_def bij_betw_def image_image image_Un",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_sum id f) (Inl ` Field t \\<union> Inr ` Field r)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Inl ` Field t \\<union> Inr ` Field r) \\<and> (\\<lambda>x. map_sum id f (Inl x)) ` Field t \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field r = Inl ` Field t \\<union> Inr ` Field s",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (t +o r) (t +o s) (map_sum id f)",
            "unfolding osum_def iso_iff3[OF r s] compat_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> map_prod Inl Inl ` t \\<union> map_prod Inr Inr ` r \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field t \\<and> a' \\<in> Field r} \\<longrightarrow> (map_sum id f a, map_sum id f b) \\<in> map_prod Inl Inl ` t \\<union> map_prod Inr Inr ` s \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field t \\<and> a' \\<in> Field s}",
            "by (auto simp: map_prod_imageI)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\ncompat (t +o r) (t +o s) (map_sum id f)",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\ncompat (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. iso (t +o r) (t +o s) (map_sum id f)",
            "by (subst iso_iff3) (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. (t +o r, t +o s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt +o r =o t +o s\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t +o r =o u +o s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. t +o r =o u +o s",
            "using ordIso_transitive[OF osum_congL[OF assms(1)] osum_congR[OF assms(2)]]\n  assms[unfolded ordIso_def]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Well_order r; Well_order u\\<rbrakk> \\<Longrightarrow> t +o r =o u +o s\n(t, u) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. t +o r =o u +o s",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma Well_order_empty[simp]: \"Well_order {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Well_order {}",
            "unfolding Field_empty",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. well_order_on {} {}",
            "by (rule well_order_on_empty)",
            1,
            "NA"
        ],
        [
            "",
            "lemma well_order_on_singleton[simp]: \"well_order_on {x} {(x, x)}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. well_order_on {x} {(x, x)}",
            "unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def total_on_def\n    Field_def refl_on_def trans_def antisym_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (((({(x, x)} \\<subseteq> {x} \\<times> {x} \\<and> (\\<forall>xa\\<in>{x}. (xa, xa) \\<in> {(x, x)})) \\<and> (\\<forall>xa y z. (xa, y) \\<in> {(x, x)} \\<longrightarrow> (y, z) \\<in> {(x, x)} \\<longrightarrow> (xa, z) \\<in> {(x, x)})) \\<and> (\\<forall>xa y. (xa, y) \\<in> {(x, x)} \\<longrightarrow> (y, xa) \\<in> {(x, x)} \\<longrightarrow> xa = y)) \\<and> (\\<forall>xa\\<in>{x}. \\<forall>y\\<in>{x}. xa \\<noteq> y \\<longrightarrow> (xa, y) \\<in> {(x, x)} \\<or> (y, xa) \\<in> {(x, x)})) \\<and> wf ({(x, x)} - Id)",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_empty[simp]:\n  assumes \"Well_order r\"\n  shows \"r ^o {} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o {} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}",
            "unfolding oexp_def[OF assms Well_order_empty] FinFunc_def fin_support_def support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> Func (Field {}) (Field r) \\<inter> {f. finite {x \\<in> Field {}. f x \\<noteq> zero r}} \\<and> g \\<in> Func (Field {}) (Field r) \\<inter> {f. finite {x \\<in> Field {}. f x \\<noteq> zero r}} \\<and> ((let m = wo_rel.max_fun_diff {} f g in (f m, g m) \\<in> r) \\<or> f = g)} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_empty2[simp]:\n  assumes \"Well_order r\" \"r \\<noteq> {}\"\n  shows \"{} ^o r = {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {} ^o r = {}",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. {} ^o r = {}",
            "from assms(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr \\<noteq> {}",
            "have \"Field r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}",
            "unfolding Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {} ^o r = {}",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {} ^o r = {}",
            "unfolding oexp_def[OF Well_order_empty assms(1)] FinFunc_def fin_support_def support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> Func (Field r) (Field {}) \\<inter> {f. finite {x \\<in> Field r. f x \\<noteq> zero {}}} \\<and> g \\<in> Func (Field r) (Field {}) \\<inter> {f. finite {x \\<in> Field r. f x \\<noteq> zero {}}} \\<and> ((let m = wo_rel.max_fun_diff r f g in (f m, g m) \\<in> {}) \\<or> f = g)} = {}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n{} ^o r = {}\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_zero[simp]: \"{} *o r = {}\" \"r *o {} = {}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {} *o r = {} &&& r *o {} = {}",
            "unfolding oprod_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field {} \\<and> x2 \\<in> Field {} \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> {}} = {} &&& {((x1, y1), x2, y2). (y1, y2) \\<in> {} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field {}) \\<and> (x1, x2) \\<in> r} = {}",
            "by simp_all",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r *o t =o s *o t\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr =o s",
            "obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "let ?f = \"map_prod f id\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_prod f id) (Field (r *o t))",
            "unfolding Field_oprod iso_def bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r \\<times> Field t. \\<forall>y\\<in>Field r \\<times> Field t. map_prod f id x = map_prod f id y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_prod f id) (Field (r *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "with f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f\ninj_on (map_prod f id) (Field (r *o t))",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\ninj_on (map_prod f id) (Field (r *o t))\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))",
            "unfolding Field_oprod iso_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_prod f id) (Field r \\<times> Field t)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod f id) (Field r \\<times> Field t) \\<and> map_prod f id ` (Field r \\<times> Field t) = Field s \\<times> Field t",
            "by (auto intro!: map_prod_surj_on)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (r *o t) (s *o t) (map_prod f id)",
            "unfolding iso_iff3[OF r s] compat_def oprod_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (map_prod f id a, map_prod f id b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}",
            "by (auto simp: map_prod_imageI)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\ncompat (r *o t) (s *o t) (map_prod f id)",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\ncompat (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. iso (r *o t) (s *o t) (map_prod f id)",
            "by (subst iso_iff3) (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. (r *o t, s *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr *o t =o s *o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t *o r =o t *o s\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr =o s",
            "obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "let ?f = \"map_prod id f\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field (t *o r))",
            "unfolding Field_oprod iso_def bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field t \\<times> Field r. \\<forall>y\\<in>Field t \\<times> Field r. map_prod id f x = map_prod id f y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_prod id f) (Field (t *o r))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "with f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f\ninj_on (map_prod id f) (Field (t *o r))",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\ninj_on (map_prod id f) (Field (t *o r))\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))",
            "unfolding Field_oprod iso_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_prod id f) (Field t \\<times> Field r)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field t \\<times> Field r) \\<and> map_prod id f ` (Field t \\<times> Field r) = Field t \\<times> Field s",
            "by (auto intro!: map_prod_surj_on)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "from f well_order_on_domain[OF r]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\niso r s f\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r s f\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. compat (t *o r) (t *o s) (map_prod id f)",
            "unfolding iso_iff3[OF r s] compat_def oprod_def bij_betw_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field t \\<and> x2 \\<in> Field t \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> t} \\<longrightarrow> (map_prod id f a, map_prod id f b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field t \\<and> x2 \\<in> Field t \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> t}",
            "by (auto simp: map_prod_imageI dest: inj_onD)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\ncompat (t *o r) (t *o s) (map_prod id f)",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\ncompat (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. iso (t *o r) (t *o s) (map_prod id f)",
            "by (subst iso_iff3) (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. (t *o r, t *o s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt *o r =o t *o s\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t *o r =o u *o s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. t *o r =o u *o s",
            "using ordIso_transitive[OF oprod_congL[OF assms(1)] oprod_congR[OF assms(2)]]\n  assms[unfolded ordIso_def]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Well_order r; Well_order u\\<rbrakk> \\<Longrightarrow> t *o r =o u *o s\n(t, u) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. t *o r =o u *o s",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma Field_singleton[simp]: \"Field {(z,z)} = {z}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field {(z, z)} = {z}",
            "by (metis well_order_on_Field well_order_on_singleton)",
            1,
            "NA"
        ],
        [
            "",
            "lemma zero_singleton[simp]: \"zero {(z,z)} = z\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. zero {(z, z)} = z",
            "using wo_rel.zero_in_Field[unfolded wo_rel_def, of \"{(z, z)}\"] well_order_on_singleton[of z]",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>Well_order {(z, z)}; Field {(z, z)} \\<noteq> {}\\<rbrakk> \\<Longrightarrow> zero {(z, z)} \\<in> Field {(z, z)}\nwell_order_on {z} {(z, z)}\n\ngoal (1 subgoal):\n 1. zero {(z, z)} = z",
            "by auto",
            1,
            "NA"
        ],
        [
            "",
            "lemma FinFunc_singleton: \"FinFunc {(z,z)} s = {\\<lambda>x. if x \\<in> Field s then z else undefined}\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. FinFunc {(z, z)} s = {\\<lambda>x. if x \\<in> Field s then z else undefined}",
            "unfolding FinFunc_def Func_def fin_support_def support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. {f. (\\<forall>a\\<in>Field s. f a \\<in> Field {(z, z)}) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero {(z, z)}}} = {\\<lambda>x. if x \\<in> Field s then z else undefined}",
            "by (auto simp: fun_eq_iff split: if_split_asm intro!: finite_subset[of _ \"{}\"])",
            1,
            "NA"
        ],
        [
            "",
            "lemma oone_ordIso_oexp:\n  assumes \"r =o oone\" and s: \"Well_order s\"\n  shows \"r ^o s =o oone\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "from \\<open>r =o oone\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr =o oone",
            "obtain f where *: \"\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\" and \"f ` Field r = {()}\"\n    and r: \"Well_order r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr =o oone\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y; f ` Field r = {()}; Well_order r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordIso_def oone_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, {((), ())}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y; f ` Field r = {()}; Well_order r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (auto simp add: iso_def [abs_def] bij_betw_def inj_on_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r\n\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "then",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r",
            "obtain x where \"x \\<in> Field r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> Field r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "with *",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nx \\<in> Field r",
            "have Fr: \"Field r = {x}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. Field r = {x}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r = {x}\n\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "interpret r: wo_rel r",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r",
            "by unfold_locales (rule r)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "from Fr well_order_on_domain[OF r] refl_onD[OF r.REFL, of x]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nField r = {x}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r",
            "have r_def: \"r = {(x, x)}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r = {x}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(x, x)}",
            "by fast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr = {(x, x)}\n\ngoal (1 subgoal):\n 1. r ^o s =o oone",
            "interpret wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. oexp =o oone",
            "have \"bij_betw (\\<lambda>x. ()) (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)",
            "unfolding bij_betw_def Field_oexp",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. ()) FINFUNC \\<and> (\\<lambda>x. ()) ` FINFUNC = Field oone",
            "by (auto simp: r_def FinFunc_singleton)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "have \"compat ?L ?R (\\<lambda>x. ())\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat oexp oone (\\<lambda>x. ())",
            "unfolding compat_def oone_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> oexp \\<longrightarrow> ((), ()) \\<in> {((), ())}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())",
            "have \"iso ?L ?R (\\<lambda>x. ())\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. iso oexp oone (\\<lambda>x. ())",
            "using s oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso oexp oone (\\<lambda>x. ())",
            "by (subst iso_iff3) (auto intro: oexp_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "using s oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. oexp =o oone",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. (oexp, oone) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oexp_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\noexp =o oone\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "context\n  fixes r s t\n  assumes r: \"Well_order r\"\n  assumes s: \"Well_order s\"\n  assumes t: \"Well_order t\"\nbegin",
            0,
            "NA"
        ],
        [
            "",
            "lemma osum_ozeroL: \"ozero +o r =o r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ozero +o r =o r",
            "using r",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ozero +o r =o r",
            "unfolding osum_def ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` {} \\<union> map_prod Inr Inr ` r \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field {} \\<and> a' \\<in> Field r} =o r",
            "by (auto intro: map_prod_ordIso)",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_ozeroR: \"r +o ozero =o r\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r +o ozero =o r",
            "using r",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. r +o ozero =o r",
            "unfolding osum_def ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` {} \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field {}} =o r",
            "by (auto intro: map_prod_ordIso)",
            1,
            "NA"
        ],
        [
            "",
            "lemma osum_assoc: \"(r +o s) +o t =o r +o s +o t\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "let ?f =\n    \"\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))",
            "unfolding Field_osum bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t. \\<forall>y\\<in>Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t. (case x of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) = (case y of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<longrightarrow> x = y) \\<and> case_sum (case_sum Inl (\\<lambda>s. Inr (Inl s))) (\\<lambda>t. Inr (Inr t)) ` (Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t) = Inl ` Field r \\<union> Inr ` (Inl ` Field s \\<union> Inr ` Field t)",
            "by (auto simp: image_Un image_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))",
            "proof (unfold compat_def, safe)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t",
            "fix a b",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t",
            "assume \"(a, b) \\<in> ?L\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, b) \\<in> (r +o s) +o t\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t",
            "thus \"(?f a, ?f b) \\<in> ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> (r +o s) +o t\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t",
            "unfolding osum_def[of \"r +o s\" t] osum_def[of r \"s +o t\"] Field_osum",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> map_prod Inl Inl ` (r +o s) \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Inl ` Field r \\<union> Inr ` Field s \\<and> a' \\<in> Field t}\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` (s +o t) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Inl ` Field s \\<union> Inr ` Field t}",
            "unfolding osum_def Field_osum image_iff image_Un map_prod_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inl x, Inl y)) ` (\\<lambda>(x, y). (Inr x, Inr y)) ` s \\<union> (\\<lambda>(x, y). (Inl x, Inl y)) ` {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field s} \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Inl ` Field r \\<union> Inr ` Field s \\<and> a' \\<in> Field t}\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> ((\\<lambda>(x, y). (Inr x, Inr y)) ` (\\<lambda>(x, y). (Inl x, Inl y)) ` s \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t}) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Inl ` Field s \\<union> Inr ` Field t}",
            "by fastforce",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. iso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))",
            "by (subst iso_iff3) (auto intro: osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. ((r +o s) +o t, r +o s +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(r +o s) +o t =o r +o s +o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_monoR:\n  assumes \"s <o t\"\n  shows \"r +o s <o r +o t\" (is \"?L <o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns <o t",
            "obtain f where s: \"Well_order s\" and t:\" Well_order t\" and \"embedS s t f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "unfolding embedS_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nofilter t (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "let ?f = \"map_sum id f\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "from *(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ninj_on f (Field s)",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on f (Field s)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Field (r +o s))",
            "unfolding Field_osum inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x\\<in>Field s. \\<forall>y\\<in>Field s. f x = f y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field s. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field s. map_sum id f x = map_sum id f y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_sum id f) (Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_sum id f) (Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "from *(2,4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncompat s t f\nf ` Field s \\<subset> Field t",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncompat s t f\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. compat (r +o s) (r +o t) (map_sum id f)",
            "unfolding compat_def osum_def map_prod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` s \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field s} \\<longrightarrow> (map_sum id f a, map_sum id f b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field t}",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "interpret rt: wo_rel ?R",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (r +o t)",
            "by unfold_locales (rule osum_Well_order[OF r t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "from *(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nt.ofilter (f ` Field s)",
            "have \"ofilter ?R (?f ` Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. rt.ofilter (map_sum id f ` Field (r +o s))",
            "unfolding t.ofilter_def rt.ofilter_def Field_osum image_Un image_image under_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s \\<subseteq> Inl ` Field r \\<union> Inr ` Field t \\<and> (\\<forall>a\\<in>(\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s. {b. (b, a) \\<in> r +o t} \\<subseteq> (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s)",
            "by (auto simp: osum_def intro!: imageI) (auto simp: Field_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.ofilter (map_sum id f ` Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))",
            "have \"embed ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))\n\ngoal (1 subgoal):\n 1. embed (r +o s) (r +o t) (map_sum id f)",
            "using embed_iff_compat_inj_on_ofilter[of ?L ?R ?f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))\n\\<lbrakk>Well_order (r +o s); Well_order (r +o t)\\<rbrakk> \\<Longrightarrow> embed (r +o s) (r +o t) (map_sum id f) = (compat (r +o s) (r +o t) (map_sum id f) \\<and> inj_on (map_sum id f) (Field (r +o s)) \\<and> rt.ofilter (map_sum id f ` Field (r +o s)))\n\ngoal (1 subgoal):\n 1. embed (r +o s) (r +o t) (map_sum id f)",
            "by (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "from *(4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf ` Field s \\<subset> Field t",
            "have \"?f ` Field ?L \\<subset> Field ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. map_sum id f ` Field (r +o s) \\<subset> Field (r +o t)",
            "unfolding Field_osum image_Un image_image",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s \\<subset> Inl ` Field r \\<union> Inr ` Field t",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)",
            "have \"embedS ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\n\ngoal (1 subgoal):\n 1. embedS (r +o s) (r +o t) (map_sum id f)",
            "using embedS_iff[OF osum_Well_order[OF r s], of ?R ?f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\nembed (r +o s) (r +o t) (map_sum id f) \\<Longrightarrow> embedS (r +o s) (r +o t) (map_sum id f) = (map_sum id f ` Field (r +o s) \\<subset> Field (r +o t))\n\ngoal (1 subgoal):\n 1. embedS (r +o s) (r +o t) (map_sum id f)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. (r +o s, r +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}",
            "by (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr +o s <o r +o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma osum_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r +o t \\<le>o s +o t\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr \\<le>o s",
            "obtain f where f: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLeq_def2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r \\<and> Well_order s \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a))\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "let ?f = \"map_sum f id\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)",
            "have \"\\<forall>a\\<in>Field (r +o t).\n     ?f a \\<in> Field (s +o t) \\<and> ?f ` underS (r +o t) a \\<subseteq> underS (s +o t) (?f a)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)",
            "unfolding Field_osum underS_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Inl ` Field r \\<union> Inr ` Field t. map_sum f id a \\<in> Inl ` Field s \\<union> Inr ` Field t \\<and> map_sum f id ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r +o t} \\<subseteq> {b. b \\<noteq> map_sum f id a \\<and> (b, map_sum f id a) \\<in> s +o t}",
            "by (fastforce simp: osum_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t",
            "unfolding ordLeq_def2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. Well_order (r +o t) \\<and> Well_order (s +o t) \\<and> (\\<exists>f. \\<forall>a\\<in>Field (r +o t). f a \\<in> Field (s +o t) \\<and> f ` underS (r +o t) a \\<subseteq> underS (s +o t) (f a))",
            "by (auto intro: osum_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr +o t \\<le>o s +o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_ozeroL: \"ozero *o r =o ozero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. ozero *o r =o ozero",
            "using ozero_ordIso",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nozero =o ozero\n\ngoal (1 subgoal):\n 1. ozero *o r =o ozero",
            "unfolding ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n{} =o {}\n\ngoal (1 subgoal):\n 1. {} *o r =o {}",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_ozeroR: \"r *o ozero =o ozero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o ozero =o ozero",
            "using ozero_ordIso",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nozero =o ozero\n\ngoal (1 subgoal):\n 1. r *o ozero =o ozero",
            "unfolding ozero_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n{} =o {}\n\ngoal (1 subgoal):\n 1. r *o {} =o {}",
            "by simp",
            1,
            "NA"
        ],
        [
            "",
            "lemma oprod_ooneR: \"r *o oone =o r\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "have \"bij_betw fst (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw fst (Field (r *o oone)) (Field r)",
            "unfolding Field_oprod bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field r \\<times> Field oone. \\<forall>y\\<in>Field r \\<times> Field oone. fst x = fst y \\<longrightarrow> x = y) \\<and> fst ` (Field r \\<times> Field oone) = Field r",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw fst (Field (r *o oone)) (Field r)\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw fst (Field (r *o oone)) (Field r)\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "have \"compat ?L ?R fst\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat (r *o oone) r fst",
            "unfolding compat_def oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> oone - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field oone) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (fst a, fst b) \\<in> r",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst",
            "have \"iso ?L ?R fst\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. iso (r *o oone) r fst",
            "using r oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso (r *o oone) r fst",
            "by (subst iso_iff3) (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "using r oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. r *o oone =o r",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. (r *o oone, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr *o oone =o r\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_ooneL: \"oone *o r =o r\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "have \"bij_betw snd (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw snd (Field (oone *o r)) (Field r)",
            "unfolding Field_oprod bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field oone \\<times> Field r. \\<forall>y\\<in>Field oone \\<times> Field r. snd x = snd y \\<longrightarrow> x = y) \\<and> snd ` (Field oone \\<times> Field r) = Field r",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw snd (Field (oone *o r)) (Field r)\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw snd (Field (oone *o r)) (Field r)\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "have \"Refl r\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Refl r",
            "by (rule wo_rel.REFL[unfolded wo_rel_def, OF r])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nRefl r\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "hence \"compat ?L ?R snd\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nRefl r\n\ngoal (1 subgoal):\n 1. compat (oone *o r) r snd",
            "unfolding compat_def oprod_def refl_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field oone \\<and> x2 \\<in> Field oone \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> oone} \\<longrightarrow> (snd a, snd b) \\<in> r",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd",
            "have \"iso ?L ?R snd\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. iso (oone *o r) r snd",
            "using r oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso (oone *o r) r snd",
            "by (subst iso_iff3) (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "using r oone_Well_order",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. oone *o r =o r",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. (oone *o r, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\noone *o r =o r\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_monoR:\n  assumes \"ozero <o r\" \"s <o t\"\n  shows \"r *o s <o r *o t\" (is \"?L <o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nozero <o r\ns <o t",
            "obtain f where s: \"Well_order s\" and t:\" Well_order t\" and \"embedS s t f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nozero <o r\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(ozero, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "unfolding embedS_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order s\nWell_order t\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nofilter t (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "let ?f = \"map_prod id f\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "from *(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ninj_on f (Field s)",
            "have \"inj_on ?f (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on f (Field s)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field (r *o s))",
            "unfolding Field_oprod inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>x\\<in>Field s. \\<forall>y\\<in>Field s. f x = f y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r \\<times> Field s. \\<forall>y\\<in>Field r \\<times> Field s. map_prod id f x = map_prod id f y \\<longrightarrow> x = y",
            "by fastforce",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_prod id f) (Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (map_prod id f) (Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "from *(2,4) the_inv_into_f_f[OF *(1)]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncompat s t f\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncompat s t f\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. compat (r *o s) (r *o t) (map_prod id f)",
            "unfolding compat_def oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (map_prod id f a, map_prod id f b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r}",
            "by auto (metis well_order_on_domain t, metis well_order_on_domain s)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "interpret rt: wo_rel ?R",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (r *o t)",
            "by unfold_locales (rule oprod_Well_order[OF r t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "from *(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nt.ofilter (f ` Field s)",
            "have \"ofilter ?R (?f ` Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. rt.ofilter (map_prod id f ` Field (r *o s))",
            "unfolding t.ofilter_def rt.ofilter_def Field_oprod under_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. map_prod id f ` (Field r \\<times> Field s) \\<subseteq> Field r \\<times> Field t \\<and> (\\<forall>a\\<in>map_prod id f ` (Field r \\<times> Field s). {b. (b, a) \\<in> r *o t} \\<subseteq> map_prod id f ` (Field r \\<times> Field s))",
            "by (auto simp: oprod_def image_iff) (fast | metis r well_order_on_domain)+",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.ofilter (map_prod id f ` Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))",
            "have \"embed ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))\n\ngoal (1 subgoal):\n 1. embed (r *o s) (r *o t) (map_prod id f)",
            "using embed_iff_compat_inj_on_ofilter[of ?L ?R ?f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))\n\\<lbrakk>Well_order (r *o s); Well_order (r *o t)\\<rbrakk> \\<Longrightarrow> embed (r *o s) (r *o t) (map_prod id f) = (compat (r *o s) (r *o t) (map_prod id f) \\<and> inj_on (map_prod id f) (Field (r *o s)) \\<and> rt.ofilter (map_prod id f ` Field (r *o s)))\n\ngoal (1 subgoal):\n 1. embed (r *o s) (r *o t) (map_prod id f)",
            "by (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "from not_ordLess_ordIso[OF assms(1)]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(ozero, r) \\<notin> ordIso",
            "have \"r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(ozero, r) \\<notin> ordIso\n\ngoal (1 subgoal):\n 1. r \\<noteq> {}",
            "by (metis ozero_def ozero_ordIso)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "hence \"Field r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}",
            "unfolding Field_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "with *(4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}",
            "have \"?f ` Field ?L \\<subset> Field ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_prod id f ` Field (r *o s) \\<subset> Field (r *o t)",
            "unfolding Field_oprod",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_prod id f ` (Field r \\<times> Field s) \\<subset> Field r \\<times> Field t",
            "by auto (metis SigmaD2 SigmaI map_prod_surj_on)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)",
            "have \"embedS ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\n\ngoal (1 subgoal):\n 1. embedS (r *o s) (r *o t) (map_prod id f)",
            "using embedS_iff[OF oprod_Well_order[OF r s], of ?R ?f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\nembed (r *o s) (r *o t) (map_prod id f) \\<Longrightarrow> embedS (r *o s) (r *o t) (map_prod id f) = (map_prod id f ` Field (r *o s) \\<subset> Field (r *o t))\n\ngoal (1 subgoal):\n 1. embedS (r *o s) (r *o t) (map_prod id f)",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. (r *o s, r *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}",
            "by (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr *o s <o r *o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r *o t \\<le>o s *o t\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "from assms",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr \\<le>o s",
            "obtain f where f: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLeq_def2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nWell_order r \\<and> Well_order s \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a))\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "let ?f = \"map_prod f id\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "from f",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)",
            "have \"\\<forall>a\\<in>Field (r *o t).\n     ?f a \\<in> Field (s *o t) \\<and> ?f ` underS (r *o t) a \\<subseteq> underS (s *o t) (?f a)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)",
            "unfolding Field_oprod underS_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r \\<times> Field t. map_prod f id a \\<in> Field s \\<times> Field t \\<and> map_prod f id ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r *o t} \\<subseteq> {b. b \\<noteq> map_prod f id a \\<and> (b, map_prod f id a) \\<in> s *o t}",
            "unfolding map_prod_def oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r \\<times> Field t. (case a of (x, y) \\<Rightarrow> (f x, id y)) \\<in> Field s \\<times> Field t \\<and> (\\<lambda>(x, y). (f x, id y)) ` {b. b \\<noteq> a \\<and> (b, a) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r}} \\<subseteq> {b. b \\<noteq> (case a of (x, y) \\<Rightarrow> (f x, id y)) \\<and> (b, case a of (x, y) \\<Rightarrow> (f x, id y)) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t",
            "unfolding ordLeq_def2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. Well_order (r *o t) \\<and> Well_order (s *o t) \\<and> (\\<exists>f. \\<forall>a\\<in>Field (r *o t). f a \\<in> Field (s *o t) \\<and> f ` underS (r *o t) a \\<subseteq> underS (s *o t) (f a))",
            "by (auto intro: oprod_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr *o t \\<le>o s *o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_assoc: \"(r *o s) *o t =o r *o s *o t\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "let ?f = \"\\<lambda>((a,b),c). (a,b,c)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))",
            "unfolding Field_oprod bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>(Field r \\<times> Field s) \\<times> Field t. \\<forall>y\\<in>(Field r \\<times> Field s) \\<times> Field t. (case x of (x, xa) \\<Rightarrow> (case x of (a, b) \\<Rightarrow> \\<lambda>c. (a, b, c)) xa) = (case y of (x, xa) \\<Rightarrow> (case x of (a, b) \\<Rightarrow> \\<lambda>c. (a, b, c)) xa) \\<longrightarrow> x = y) \\<and> (\\<lambda>((a, b), c). (a, b, c)) ` ((Field r \\<times> Field s) \\<times> Field t) = Field r \\<times> Field s \\<times> Field t",
            "by (auto simp: image_Un image_iff)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))",
            "proof (unfold compat_def, safe)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t",
            "fix a1 a2 a3 b1 b2 b3",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t",
            "assume \"(((a1, a2), a3), ((b1, b2), b3)) \\<in> ?L\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(((a1, a2), a3), (b1, b2), b3) \\<in> (r *o s) *o t\n\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t",
            "thus \"((a1, a2, a3), (b1, b2, b3)) \\<in> ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> (r *o s) *o t\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> r *o s *o t",
            "unfolding oprod_def[of \"r *o s\" t] oprod_def[of r \"s *o t\"] Field_oprod",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<times> Field s \\<and> x2 \\<in> Field r \\<times> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r *o s}\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s *o t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s \\<times> Field t) \\<and> (x1, x2) \\<in> r}",
            "unfolding oprod_def Field_oprod image_iff image_Un",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<times> Field s \\<and> x2 \\<in> Field r \\<times> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r}}\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s \\<times> Field t) \\<and> (x1, x2) \\<in> r}",
            "by fast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n((a1, a2, a3), b1, b2, b3) \\<in> r *o s *o t\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. iso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))",
            "by (subst iso_iff3) (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. ((r *o s) *o t, r *o s *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(r *o s) *o t =o r *o s *o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oprod_osum: \"r *o (s +o t) =o r *o s +o r *o t\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "let ?f = \"\\<lambda>(a,bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))",
            "unfolding Field_oprod Field_osum bij_betw_def inj_on_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t). \\<forall>y\\<in>Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t). (case x of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) = (case y of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<longrightarrow> x = y) \\<and> (\\<lambda>(a, y). case_sum (\\<lambda>b. Inl (a, b)) (\\<lambda>c. Inr (a, c)) y) ` (Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t)) = Inl ` (Field r \\<times> Field s) \\<union> Inr ` (Field r \\<times> Field t)",
            "by (fastforce simp: image_Un image_iff split: sum.splits)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))",
            "proof (unfold compat_def, intro allI impI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t",
            "fix a b",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t",
            "assume \"(a, b) \\<in> ?L\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(a, b) \\<in> r *o (s +o t)\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t",
            "thus \"(?f a, ?f b) \\<in> ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> r *o (s +o t)\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t",
            "unfolding oprod_def[of r \"s +o t\"] osum_def[of \"r *o s\" \"r *o t\"] Field_oprod Field_osum",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s +o t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Inl ` Field s \\<union> Inr ` Field t) \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> map_prod Inl Inl ` (r *o s) \\<union> map_prod Inr Inr ` (r *o t) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<times> Field s \\<and> a' \\<in> Field r \\<times> Field t}",
            "unfolding oprod_def osum_def Field_oprod Field_osum image_iff image_Un",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Inl ` Field s \\<union> Inr ` Field t) \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> map_prod Inl Inl ` {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r} \\<union> map_prod Inr Inr ` {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r} \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<times> Field s \\<and> a' \\<in> Field r \\<times> Field t}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. iso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))",
            "by (subst iso_iff3) (auto intro: oprod_Well_order osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r *o (s +o t), r *o s +o r *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oprod_Well_order osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr *o (s +o t) =o r *o s +o r *o t\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma ozero_oexp: \"\\<not> (s =o ozero) \\<Longrightarrow> ozero ^o s =o ozero\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (s, ozero) \\<notin> ordIso \\<Longrightarrow> ozero ^o s =o ozero",
            "unfolding oexp_def[OF ozero_Well_order s] FinFunc_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (s, ozero) \\<notin> ordIso \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field ozero) \\<inter> fin_support (zero ozero) (Field s) \\<and> g \\<in> Func (Field s) (Field ozero) \\<inter> fin_support (zero ozero) (Field s) \\<and> ((let m = wo_rel.max_fun_diff s f g in (f m, g m) \\<in> ozero) \\<or> f = g)} =o ozero",
            "by simp (metis Func_emp2 bot.extremum_uniqueI emptyE well_order_on_domain s subrelI)",
            1,
            "NA"
        ],
        [
            "",
            "lemma oone_oexp: \"oone ^o s =o oone\" (is \"?L =o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. oone ^o s =o oone",
            "by (rule oone_ordIso_oexp[OF ordIso_reflexive[OF oone_Well_order] s])",
            1,
            "NA"
        ],
        [
            "",
            "lemma oexp_monoR:\n  assumes \"oone <o r\" \"s <o t\"\n  shows   \"r ^o s <o r ^o t\" (is \"?L <o ?R\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o s <o r ^o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o s <o r ^o t",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o r ^o t",
            "interpret rt: wo_rel2 r t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t",
            "by unfold_locales (rule r, rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "interpret rexpt: wo_rel \"r ^o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel rt.oexp",
            "by unfold_locales (rule rt.oexp_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "interpret r: wo_rel r",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r",
            "by unfold_locales (rule r)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "interpret s: wo_rel s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "have \"Field r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}",
            "by (metis assms(1) internalize_ordLess not_psubset_empty)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "assume \"Field r = {r.zero}\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r = {r.zero}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "hence \"r = {(r.zero, r.zero)}\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r = {r.zero}\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}",
            "using refl_onD[OF r.REFL, of r.zero]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r = {r.zero}\nr.zero \\<in> Field r \\<Longrightarrow> (r.zero, r.zero) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}",
            "unfolding Field_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nDomain r \\<union> Range r = {r.zero}\nr.zero \\<in> Domain r \\<union> Range r \\<Longrightarrow> (r.zero, r.zero) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr = {(r.zero, r.zero)}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "hence \"r =o oone\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr = {(r.zero, r.zero)}\n\ngoal (1 subgoal):\n 1. r =o oone",
            "by (metis oone_ordIso ordIso_symmetric)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr =o oone\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "with not_ordLess_ordIso[OF assms(1)]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(oone, r) \\<notin> ordIso\nr =o oone",
            "have False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(oone, r) \\<notin> ordIso\nr =o oone\n\ngoal (1 subgoal):\n 1. False",
            "by (metis ordIso_symmetric)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r = {r.zero} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nField r \\<noteq> {}\nField r = {r.zero} \\<Longrightarrow> False",
            "obtain x where x: \"x \\<in> Field r\" \"r.zero \\<in> Field r\" \"x \\<noteq> r.zero\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nField r \\<noteq> {}\nField r = {r.zero} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (metis insert_iff r.zero_in_Field subsetI subset_singletonD)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "from assms(2)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ns <o t",
            "obtain f where \"embedS s t f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. embedS s t f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. embedS s t f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembedS s t f\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> t.ofilter (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "unfolding embedS_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> t.ofilter (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nt.ofilter (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "note invff = the_inv_into_f_f[OF *(1)] and injfD = inj_onD[OF *(1)]",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\\<lbrakk>f ?x = f ?y; ?x \\<in> Field s; ?y \\<in> Field s\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "define F where [abs_def]: \"F g z =\n    (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z)\n     else if z \\<in> Field t then r.zero else undefined)\" for g z",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF \\<equiv> \\<lambda>g z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "from *(4) x(2) the_inv_into_f_eq[OF *(1)]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x",
            "have FLR: \"F ` Field ?L \\<subseteq> Field ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp",
            "unfolding rt.Field_oexp rs.Field_oexp FinFunc_def Func_def fin_support_def support_def F_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>g z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) ` ({f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}) \\<subseteq> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}",
            "by (fastforce split: option.splits if_split_asm elim!: finite_surj[of _ _ f])",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "have \"inj_on F (Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on F (Field rs.oexp)",
            "unfolding rs.Field_oexp inj_on_def fun_eq_iff",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>rs.FINFUNC. \\<forall>y\\<in>rs.FINFUNC. (\\<forall>xa. F x xa = F y xa) \\<longrightarrow> (\\<forall>xa. x xa = y xa)",
            "proof safe",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa",
            "fix g h x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa",
            "assume \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r s\" \"\\<forall>y. F g y = F h y\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa",
            "with invff",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y",
            "show \"g x = h x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y\n\ngoal (1 subgoal):\n 1. g x = h x",
            "unfolding F_def fun_eq_iff FinFunc_def Func_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\nh \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\n\\<forall>y. (if y \\<in> f ` Field s then g (the_inv_into (Field s) f y) else if y \\<in> Field t then r.zero else undefined) = (if y \\<in> f ` Field s then h (the_inv_into (Field s) f y) else if y \\<in> Field t then r.zero else undefined)\n\ngoal (1 subgoal):\n 1. g x = h x",
            "by auto (metis image_eqI)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng x = h x\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on F (Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on F (Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "have \"compat ?L ?R F\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat rs.oexp rt.oexp F",
            "unfolding compat_def rs.oexp_def rt.oexp_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<longrightarrow> (F a, F b) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}",
            "proof (safe elim!: bspec[OF iffD1[OF image_subset_iff FLR[unfolded rs.Field_oexp rt.Field_oexp]]])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "fix g h",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "assume gh: \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r s\" \"F g \\<noteq> F h\"\n      \"let m = s.max_fun_diff g h in (g m, h m) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "hence \"g \\<noteq> h\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n\ngoal (1 subgoal):\n 1. g \\<noteq> h",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<noteq> h\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "note max_fun_diff_in = rs.max_fun_diff_in[OF \\<open>g \\<noteq> h\\<close> gh(1,2)]\n    and max_fun_diff_max = rs.max_fun_diff_max[OF \\<open>g \\<noteq> h\\<close> gh(1,2)]",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "with *(4) invff *(2)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ncompat s t f\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s",
            "have \"t.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ncompat s t f\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)",
            "unfolding t.max_fun_diff_def compat_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. t.maxim {a \\<in> Field t. F g a \\<noteq> F h a} = f (s.max_fun_diff g h)",
            "by (intro t.maxim_equality) (auto simp: t.isMaxim_def F_def dest: injfD)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r",
            "with gh invff max_fun_diff_in",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)",
            "show \"let m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. let m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r",
            "unfolding F_def Let_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n(\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<noteq> (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. (if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then g (the_inv_into (Field s) f (t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined, if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then h (the_inv_into (Field s) f (t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined) \\<in> r",
            "by (auto simp: dest: injfD)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlet m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "from FLR",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp",
            "have \"ofilter ?R (F ` Field ?L)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rexpt.ofilter (F ` Field rs.oexp)",
            "unfolding rexpt.ofilter_def under_def rs.Field_oexp rt.Field_oexp",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF ` rs.FINFUNC \\<subseteq> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. F ` rs.FINFUNC \\<subseteq> rt.FINFUNC \\<and> (\\<forall>a\\<in>F ` rs.FINFUNC. {b. (b, a) \\<in> rt.oexp} \\<subseteq> F ` rs.FINFUNC)",
            "unfolding rt.oexp_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF ` rs.FINFUNC \\<subseteq> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. F ` rs.FINFUNC \\<subseteq> rt.FINFUNC \\<and> (\\<forall>a\\<in>F ` rs.FINFUNC. {b. (b, a) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}} \\<subseteq> F ` rs.FINFUNC)",
            "proof (safe elim!: imageI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC",
            "fix g h",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC",
            "assume gh: \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r t\" \"F g \\<in> FinFunc r t\"\n      \"let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC",
            "thus \"h \\<in> F ` FinFunc r s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\n\ngoal (1 subgoal):\n 1. h \\<in> F ` rs.FINFUNC",
            "proof (cases \"h = F g\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<noteq> F g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "hence max_Field: \"t.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<noteq> F g\n\ngoal (1 subgoal):\n 1. t.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}",
            "by (rule rt.max_fun_diff_in[OF _ gh(2,3)])",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "assume *: \"t.max_fun_diff h (F g) \\<notin> f ` Field s\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "with max_Field",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nt.max_fun_diff h (F g) \\<notin> f ` Field s",
            "have **: \"F g (t.max_fun_diff h (F g)) = r.zero\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. F g (t.max_fun_diff h (F g)) = r.zero",
            "unfolding F_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> {a \\<in> Field t. h a \\<noteq> (if a \\<in> f ` Field s then g (the_inv_into (Field s) f a) else if a \\<in> Field t then r.zero else undefined)}\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. (if t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then g (the_inv_into (Field s) f (t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined) = r.zero",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "with * gh(4)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero",
            "have \"h (t.max_fun_diff h (F g)) = r.zero\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. h (t.max_fun_diff h (F g)) = r.zero",
            "unfolding Let_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n(h (t.max_fun_diff h (F g)), F g (t.max_fun_diff h (F g))) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. h (t.max_fun_diff h (F g)) = r.zero",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh (t.max_fun_diff h (F g)) = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "with **",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero",
            "have False",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. False",
            "using max_Field gh(2,3)",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. False",
            "unfolding FinFunc_def Func_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\nF g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\n\ngoal (1 subgoal):\n 1. False",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<notin> f ` Field s \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "hence max_f_Field: \"t.max_fun_diff h (F g) \\<in> f ` Field s\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. t.max_fun_diff h (F g) \\<in> f ` Field s",
            "by blast",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "fix z",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "assume z: \"z \\<in> Field t - f ` Field s\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> Field t - f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "have \"(t.max_fun_diff h (F g), z) \\<in> t\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<in> t",
            "proof (rule ccontr)",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False",
            "assume \"(t.max_fun_diff h (F g), z) \\<notin> t\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False",
            "hence \"(z, t.max_fun_diff h (F g)) \\<in> t\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\ngoal (1 subgoal):\n 1. (z, t.max_fun_diff h (F g)) \\<in> t",
            "using t.in_notinI[of \"t.max_fun_diff h (F g)\" z]\n            z max_Field",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\\<lbrakk>(t.max_fun_diff h (F g), z) \\<notin> t \\<or> t.max_fun_diff h (F g) = z; z \\<in> Field t; t.max_fun_diff h (F g) \\<in> Field t\\<rbrakk> \\<Longrightarrow> (z, t.max_fun_diff h (F g)) \\<in> t\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (1 subgoal):\n 1. (z, t.max_fun_diff h (F g)) \\<in> t",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(z, t.max_fun_diff h (F g)) \\<in> t\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False",
            "hence \"z \\<in> f ` Field s\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s",
            "using *(3) max_f_Field",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\nt.ofilter (f ` Field s)\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s",
            "unfolding t.ofilter_def under_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s",
            "by fastforce",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False",
            "with z",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nz \\<in> Field t - f ` Field s\nz \\<in> f ` Field s",
            "show False",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> Field t - f ` Field s\nz \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. False",
            "by blast",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(t.max_fun_diff h (F g), z) \\<in> t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "hence \"h z = r.zero\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<in> t\n\ngoal (1 subgoal):\n 1. h z = r.zero",
            "using rt.max_fun_diff_le_eq[OF _ False gh(2,3), of z]\n          z max_f_Field",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<in> t\n\\<lbrakk>(t.max_fun_diff h (F g), z) \\<in> t; z \\<noteq> t.max_fun_diff h (F g)\\<rbrakk> \\<Longrightarrow> h z = F g z\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. h z = r.zero",
            "unfolding F_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined), z) \\<in> t\n\\<lbrakk>(t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined), z) \\<in> t; z \\<noteq> t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\\<rbrakk> \\<Longrightarrow> h z = (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. h z = r.zero",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh z = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "note ** = this",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "with *(3) gh(2)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero",
            "have \"h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (1 subgoal):\n 1. h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)",
            "using invff",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)",
            "unfolding F_def fun_eq_iff FinFunc_def Func_def Let_def t.ofilter_def under_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. h x = (if x \\<in> f ` Field s then if the_inv_into (Field s) f x \\<in> Field s then h (f (the_inv_into (Field s) f x)) else undefined else if x \\<in> Field t then r.zero else undefined)",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "from gh(2) *(1,3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nh \\<in> rt.FINFUNC\ninj_on f (Field s)\nt.ofilter (f ` Field s)",
            "have \"(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> FinFunc r s\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> rt.FINFUNC\ninj_on f (Field s)\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC",
            "unfolding FinFunc_def Func_def fin_support_def support_def t.ofilter_def under_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\ninj_on f (Field s)\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}",
            "by (auto intro: subset_inj_on elim!: finite_imageD[OF finite_subset[rotated]])",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC",
            "show \"?thesis\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. h \\<in> F ` rs.FINFUNC",
            "by (rule image_eqI)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> F ` rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC",
            "qed simp",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> F ` rs.FINFUNC\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrexpt.ofilter (F ` Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)",
            "have \"embed ?L ?R F\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)\n\ngoal (1 subgoal):\n 1. embed rs.oexp rt.oexp F",
            "using embed_iff_compat_inj_on_ofilter[of ?L ?R F]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)\n\\<lbrakk>Well_order rs.oexp; Well_order rt.oexp\\<rbrakk> \\<Longrightarrow> embed rs.oexp rt.oexp F = (compat rs.oexp rt.oexp F \\<and> inj_on F (Field rs.oexp) \\<and> rexpt.ofilter (F ` Field rs.oexp))\n\ngoal (1 subgoal):\n 1. embed rs.oexp rt.oexp F",
            "by (auto intro: oexp_Well_order r s t)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "from FLR",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp",
            "have \"F ` Field ?L \\<subset> Field ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subset> Field rt.oexp",
            "proof (intro psubsetI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "from *(4)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf ` Field s \\<subset> Field t",
            "obtain z where z: \"z \\<in> Field t\" \"z \\<notin> f ` Field s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. (\\<And>z. \\<lbrakk>z \\<in> Field t; z \\<notin> f ` Field s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "define h where [abs_def]: \"h z' =\n      (if z' \\<in> Field t then if z' = z then x else r.zero else undefined)\" for z'",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<equiv> \\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "from z x(3)",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero",
            "have \"rt.SUPP h = {z}\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rt.SUPP h = {z}",
            "unfolding support_def h_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. {xa \\<in> Field t. (if xa \\<in> Field t then if xa = z then x else r.zero else undefined) \\<noteq> r.zero} = {z}",
            "by simp",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.SUPP h = {z}\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "with x",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP h = {z}",
            "have \"h \\<in> Field ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP h = {z}\n\ngoal (1 subgoal):\n 1. h \\<in> Field rt.oexp",
            "unfolding h_def rt.Field_oexp FinFunc_def Func_def fin_support_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP (\\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined) = {z}\n\ngoal (1 subgoal):\n 1. (\\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rt.SUPP f)}",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "{",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "fix g",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "from z",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nz \\<in> Field t\nz \\<notin> f ` Field s",
            "have \"F g z = r.zero\" \"h z = x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. F g z = r.zero &&& h z = x",
            "unfolding support_def h_def F_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) = r.zero &&& (if z \\<in> Field t then if z = z then x else r.zero else undefined) = x",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF g z = r.zero\nh z = x\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "with x(3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x",
            "have \"F g \\<noteq> h\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x\n\ngoal (1 subgoal):\n 1. F g \\<noteq> h",
            "unfolding fun_eq_iff",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. F g x = h x)",
            "by fastforce",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF g \\<noteq> h\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "}",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF ?g3 \\<noteq> h\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "hence \"h \\<notin> F ` Field ?L\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nF ?g3 \\<noteq> h\n\ngoal (1 subgoal):\n 1. h \\<notin> F ` Field rs.oexp",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<notin> F ` Field rs.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nh \\<in> Field rt.oexp\nh \\<notin> F ` Field rs.oexp",
            "show \"F ` Field ?L \\<noteq> Field ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> Field rt.oexp\nh \\<notin> F ` Field rs.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<noteq> Field rt.oexp",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF ` Field rs.oexp \\<noteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nF ` Field rs.oexp \\<subset> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp",
            "have \"embedS ?L ?R F\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp\n\ngoal (1 subgoal):\n 1. embedS rs.oexp rt.oexp F",
            "using embedS_iff[OF rs.oexp_Well_order, of ?R F]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp\nembed rs.oexp rt.oexp F \\<Longrightarrow> embedS rs.oexp rt.oexp F = (F ` Field rs.oexp \\<subset> Field rt.oexp)\n\ngoal (1 subgoal):\n 1. embedS rs.oexp rt.oexp F",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp",
            "unfolding ordLess_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. (rs.oexp, rt.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (rs.oexp, rt.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}",
            "by (auto intro: oexp_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrs.oexp <o rt.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_monoL:\n  assumes \"r \\<le>o s\"\n  shows   \"r ^o t \\<le>o s ^o t\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o t \\<le>o s ^o t",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o t \\<le>o s ^o t",
            "interpret rt: wo_rel2 r t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t",
            "by unfold_locales (rule r, rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o s ^o t",
            "interpret st: wo_rel2 s t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 s t",
            "by unfold_locales (rule s, rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "interpret r: wo_rel r",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r",
            "by unfold_locales (rule r)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "interpret s: wo_rel s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "proof (cases \"t = {}\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. t = {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt = {}\n\ngoal (2 subgoals):\n 1. t = {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt = {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "using r s",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt = {}\nWell_order r\nWell_order s\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "unfolding ordLeq_def2 underS_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt = {}\nWell_order r\nWell_order s\n\ngoal (1 subgoal):\n 1. Well_order rt.oexp \\<and> Well_order st.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field rt.oexp. f a \\<in> Field st.oexp \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> rt.oexp} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> st.oexp})",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt \\<noteq> {}\n\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "thus ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "proof (cases \"r = {}\")",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<noteq> {}; r = {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "case True",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<noteq> {}; r = {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "thus ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr = {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "using t \\<open>t \\<noteq> {}\\<close> st.oexp_Well_order ozero_ordLeq[unfolded ozero_def]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr = {}\nWell_order t\nt \\<noteq> {}\nWell_order st.oexp\nWell_order ?r \\<Longrightarrow> {} \\<le>o ?r\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "next",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "case False",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "from assms",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr \\<le>o s",
            "obtain f where f: \"embed r s f\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. embed r s f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLeq_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. embed r s f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by blast",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nembed r s f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "hence f_underS: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)",
            "using embed_in_Field embed_underS2 rt.rWELL",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\n\\<lbrakk>embed ?r ?r' ?f; ?a \\<in> Field ?r\\<rbrakk> \\<Longrightarrow> ?f ?a \\<in> Field ?r'\n\\<lbrakk>Well_order ?r; embed ?r ?s ?g; ?a \\<in> Field ?r\\<rbrakk> \\<Longrightarrow> ?g ` underS ?r ?a = underS ?s (?g ?a)\nWell_order r\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)",
            "by fastforce",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "from f \\<open>t \\<noteq> {}\\<close> False",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed r s f\nt \\<noteq> {}\nr \\<noteq> {}",
            "have *: \"Field r \\<noteq> {}\" \"Field s \\<noteq> {}\" \"Field t \\<noteq> {}\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\nt \\<noteq> {}\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} &&& Field s \\<noteq> {} &&& Field t \\<noteq> {}",
            "unfolding Field_def embed_def under_def bij_betw_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Domain r \\<union> Range r. inj_on f {b. (b, a) \\<in> r} \\<and> f ` {b. (b, a) \\<in> r} = {b. (b, f a) \\<in> s}\nt \\<noteq> {}\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {} &&& Domain s \\<union> Range s \\<noteq> {} &&& Domain t \\<union> Range t \\<noteq> {}",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "with f",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed r s f\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}",
            "obtain x where \"s.zero = f x\" \"x \\<in> Field r\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding embed_def bij_betw_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. inj_on f (r.under a) \\<and> f ` r.under a = s.under (f a)\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "using s.zero_under subsetD[OF under_Field[of r]]",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. inj_on f (r.under a) \\<and> f ` r.under a = s.under (f a)\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n?x \\<in> Field s \\<Longrightarrow> s.zero \\<in> s.under ?x\n?c \\<in> r.under ?a1 \\<Longrightarrow> ?c \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (metis (no_types, lifting) f_inv_into_f f_underS inv_into_into r.zero_in_Field)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "with f",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed r s f\ns.zero = f x\nx \\<in> Field r",
            "have fz: \"f r.zero = s.zero\" and inj: \"inj_on f (Field r)\" and compat: \"compat r s f\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. f r.zero = s.zero &&& inj_on f (Field r) &&& compat r s f",
            "unfolding embed_iff_compat_inj_on_ofilter[OF r s] compat_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s) \\<and> inj_on f (Field r) \\<and> s.ofilter (f ` Field r)\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. f r.zero = s.zero &&& inj_on f (Field r) &&& \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s",
            "by (fastforce intro: s.leq_zero_imp)+",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf r.zero = s.zero\ninj_on f (Field r)\ncompat r s f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "let ?f = \"\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined\"",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "fix g",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "assume g: \"g \\<in> Field (r ^o t)\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "with fz f_underS",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> Field rt.oexp",
            "have Field_fg: \"?f g \\<in> Field (s ^o t)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp",
            "unfolding st.Field_oexp rt.Field_oexp FinFunc_def Func_def fin_support_def support_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field s) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> s.zero}}",
            "by (auto elim!: finite_subset[rotated])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "have \"?f ` underS (r ^o t) g \\<subseteq> underS (s ^o t) (?f g)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "proof safe",
            9,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "fix h",
            10,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "assume h_underS: \"h \\<in> underS (r ^o t) g\"",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "hence \"h \\<in> Field (r ^o t)\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. h \\<in> Field rt.oexp",
            "unfolding underS_def Field_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> {b. b \\<noteq> g \\<and> (b, g) \\<in> rt.oexp}\n\ngoal (1 subgoal):\n 1. h \\<in> Domain rt.oexp \\<union> Range rt.oexp",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "with fz f_underS",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> Field rt.oexp",
            "have Field_fh: \"?f h \\<in> Field (s ^o t)\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp",
            "unfolding st.Field_oexp rt.Field_oexp FinFunc_def Func_def fin_support_def support_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field s) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> s.zero}}",
            "by (auto elim!: finite_subset[rotated])",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "from h_underS",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nh \\<in> underS rt.oexp g",
            "have \"h \\<noteq> g\" and hg: \"(h, g) \\<in> rt.oexp\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. h \\<noteq> g &&& (h, g) \\<in> rt.oexp",
            "unfolding underS_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nh \\<in> {b. b \\<noteq> g \\<and> (b, g) \\<in> rt.oexp}\n\ngoal (1 subgoal):\n 1. h \\<noteq> g &&& (h, g) \\<in> rt.oexp",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nh \\<noteq> g\n(h, g) \\<in> rt.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "with f inj",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nembed r s f\ninj_on f (Field r)\nh \\<noteq> g\n(h, g) \\<in> rt.oexp",
            "have neq: \"?f h \\<noteq> ?f g\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\ninj_on f (Field r)\nh \\<noteq> g\n(h, g) \\<in> rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "unfolding fun_eq_iff inj_on_def rt.oexp_def map_option_case FinFunc_def Func_def Let_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nembed r s f\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y\n\\<not> (\\<forall>x. h x = g x)\n(h, g) \\<in> {(f, g). f \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t) \\<and> g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t) \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> r \\<or> (\\<forall>x. f x = g x))}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. (if x \\<in> Field t then f (h x) else undefined) = (if x \\<in> Field t then f (g x) else undefined))",
            "by simp metis",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "with hg",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(h, g) \\<in> rt.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "have \"t.max_fun_diff (?f h) (?f g) = t.max_fun_diff h g\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(h, g) \\<in> rt.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g",
            "unfolding rt.oexp_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g",
            "using rt.max_fun_diff[OF \\<open>h \\<noteq> g\\<close>] rt.max_fun_diff_in[OF \\<open>h \\<noteq> g\\<close>]",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g",
            "by (subst t.max_fun_diff_def, intro t.maxim_equality)\n              (auto simp: t.isMaxim_def intro: inj_onD[OF inj] intro!: rt.max_fun_diff_max)",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "with Field_fg Field_fh hg fz f_underS compat neq",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g",
            "have \"(?f h, ?f g) \\<in> st.oexp\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp",
            "using rt.max_fun_diff[OF \\<open>h \\<noteq> g\\<close>] rt.max_fun_diff_in[OF \\<open>h \\<noteq> g\\<close>]",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp",
            "unfolding st.Field_oexp",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.FINFUNC\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> st.FINFUNC\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp",
            "unfolding rt.oexp_def st.oexp_def Let_def compat_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.FINFUNC\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> st.FINFUNC\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> r \\<or> f = g)}\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\n\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> {(f, g). f \\<in> st.FINFUNC \\<and> g \\<in> st.FINFUNC \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> s \\<or> f = g)}",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "with neq",
            10,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp",
            "show \"?f h \\<in> underS (s ^o t) (?f g)\"",
            10,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "unfolding underS_def",
            11,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> {b. b \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<and> (b, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp}",
            "by auto",
            11,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal:\nNo subgoals!",
            "qed",
            10,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "have \"?f g \\<in> Field (s ^o t) \\<and> ?f ` underS (r ^o t) g \\<subseteq> underS (s ^o t) (?f g)\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)",
            "by blast",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp",
            "thus ?thesis",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp",
            "unfolding ordLeq_def2",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. Well_order rt.oexp \\<and> Well_order st.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field rt.oexp. f a \\<in> Field st.oexp \\<and> f ` underS rt.oexp a \\<subseteq> underS st.oexp (f a))",
            "by (fastforce intro: oexp_Well_order r s t)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma ordLeq_oexp2:\n  assumes \"oone <o r\"\n  shows   \"s \\<le>o r ^o s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s \\<le>o r ^o s",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o r ^o s",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "interpret r: wo_rel r",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r",
            "by unfold_locales (rule r)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "interpret s: wo_rel s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "from assms well_order_on_domain[OF r]",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\noone <o r\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r",
            "obtain x where\n    x: \"x \\<in> Field r\" \"r.zero \\<in> Field r\" \"x \\<noteq> r.zero\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\noone <o r\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "unfolding ordLess_def oone_def embedS_def[abs_def] bij_betw_def embed_def under_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n({((), ())}, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f {b. (b, a) \\<in> r} \\<and> f ` {b. (b, a) \\<in> r} = {b. (b, f a) \\<in> r'}) \\<and> \\<not> (inj_on f (Field r) \\<and> f ` Field r = Field r'))}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis",
            "by (auto simp: image_def)\n       (metis (lifting) equals0D mem_Collect_eq r.zero_in_Field singletonI)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "let ?f = \"\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "from x(3)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> r.zero",
            "have SUPP: \"\\<And>y. y \\<in> Field s \\<Longrightarrow> rs.SUPP (?f y) = {y}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = {y}",
            "unfolding support_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> Field s \\<Longrightarrow> {xa \\<in> Field s. (if xa \\<in> Field s then if xa = y then x else r.zero else undefined) \\<noteq> r.zero} = {y}",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "{",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "fix y",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "assume y: \"y \\<in> Field s\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "with x(1,2) SUPP",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s",
            "have \"?f y \\<in> Field (r ^o s)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp",
            "unfolding rs.Field_oexp",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC",
            "by (auto simp: FinFunc_def Func_def fin_support_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "have \"?f ` underS s y \\<subseteq> underS (r ^o s) (?f y)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "proof safe",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "fix z",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "assume \"z \\<in> underS s y\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<in> s.underS y\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "hence z: \"z \\<noteq> y\" \"(z, y) \\<in> s\" \"z \\<in> Field s\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> s.underS y\n\ngoal (1 subgoal):\n 1. z \\<noteq> y &&& (z, y) \\<in> s &&& z \\<in> Field s",
            "unfolding underS_def Field_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nz \\<in> {b. b \\<noteq> y \\<and> (b, y) \\<in> s}\n\ngoal (1 subgoal):\n 1. z \\<noteq> y &&& (z, y) \\<in> s &&& z \\<in> Domain s \\<union> Range s",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nz \\<noteq> y\n(z, y) \\<in> s\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "from x(3) y z(1,3)",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s",
            "have \"?f z \\<noteq> ?f y\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "unfolding fun_eq_iff",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xa. (if xa \\<in> Field s then if xa = z then x else r.zero else undefined) = (if xa \\<in> Field s then if xa = y then x else r.zero else undefined))",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "moreover",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "{",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "from x(1,2)",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r",
            "have \"?f z \\<in> FinFunc r s\" \"?f y \\<in> FinFunc r s\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC &&& (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC",
            "unfolding FinFunc_def Func_def fin_support_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)} &&& (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)}",
            "by (auto simp: SUPP[OF z(3)] SUPP[OF y])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "moreover",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "from x(3) y z(1,2) refl_onD[OF s.REFL]",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s",
            "have \"s.max_fun_diff (?f z) (?f y) = y\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y",
            "unfolding rs.max_fun_diff_alt SUPP[OF z(3)] SUPP[OF y]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s\n\ngoal (1 subgoal):\n 1. s.maxim (({z} \\<union> {y}) \\<inter> {a. (if a \\<in> Field s then if a = z then x else r.zero else undefined) \\<noteq> (if a \\<in> Field s then if a = y then x else r.zero else undefined)}) = y",
            "by (intro s.maxim_equality) (auto simp: s.isMaxim_def)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "ultimately",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y",
            "have \"(?f z, ?f y) \\<in> rs.oexp\"",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp",
            "using y x(1)",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\ny \\<in> Field s\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp",
            "unfolding rs.oexp_def Let_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\ny \\<in> Field s\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}",
            "by auto",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "}",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "ultimately",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp",
            "show \"?f z \\<in> underS (r ^o s) (?f y)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "unfolding underS_def",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> {b. b \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<and> (b, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp}",
            "by blast",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "have \"?f y \\<in> Field (r ^o s) \\<and> ?f ` underS s y \\<subseteq> underS (r ^o s) (?f y)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)",
            "by blast",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "}",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "thus ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp",
            "unfolding ordLeq_def2",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. Well_order s \\<and> Well_order rs.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field s. f a \\<in> Field rs.oexp \\<and> f ` s.underS a \\<subseteq> underS rs.oexp (f a))",
            "by (fast intro: oexp_Well_order r s)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns \\<le>o rs.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma FinFunc_osum:\n  \"fg \\<in> FinFunc r (s +o t) = (fg o Inl \\<in> FinFunc r s \\<and> fg o Inr \\<in> FinFunc r t)\"\n  (is \"?L = (?R1 \\<and> ?R2)\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (fg \\<in> FinFunc r (s +o t)) = (fg \\<circ> Inl \\<in> FinFunc r s \\<and> fg \\<circ> Inr \\<in> FinFunc r t)",
            "proof safe",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inl \\<in> FinFunc r s\n 2. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 3. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "assume ?L",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (3 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inl \\<in> FinFunc r s\n 2. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 3. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "from \\<open>?L\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfg \\<in> FinFunc r (s +o t)",
            "show ?R1",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (1 subgoal):\n 1. fg \\<circ> Inl \\<in> FinFunc r s",
            "unfolding FinFunc_def Field_osum Func_def Int_iff fin_support_Field_osum o_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s) \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fg (Inl x)) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s)",
            "by (auto split: sum.splits)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<circ> Inl \\<in> FinFunc r s\n\ngoal (2 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 2. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "from \\<open>?L\\<close>",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfg \\<in> FinFunc r (s +o t)",
            "show ?R2",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (1 subgoal):\n 1. fg \\<circ> Inr \\<in> FinFunc r t",
            "unfolding FinFunc_def Field_osum Func_def Int_iff fin_support_Field_osum o_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s) \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fg (Inr x)) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)",
            "by (auto split: sum.splits)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "assume ?R1 ?R2",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<circ> Inl \\<in> FinFunc r s\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)",
            "thus \"?L\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<circ> Inl \\<in> FinFunc r s\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. fg \\<in> FinFunc r (s +o t)",
            "unfolding FinFunc_def Field_osum Func_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<circ> Inl \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)\nfg \\<circ> Inr \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. fg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Inl ` Field s \\<union> Inr ` Field t)",
            "by (auto simp: fin_support_Field_osum o_def image_iff split: sum.splits) (metis sumE)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> FinFunc r (s +o t)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_eq_Inl:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inl x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff s f1 f2 = x\" (is ?P) \"g1 = g2\" (is ?Q)",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff s f1 f2 = x &&& g1 = g2",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff s f1 f2 = x\n 2. g1 = g2",
            "interpret st: wo_rel \"s +o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s +o t)",
            "by unfold_locales (rule osum_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff s f1 f2 = x\n 2. g1 = g2",
            "interpret s: wo_rel s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2",
            "interpret rst: wo_rel2 r \"s +o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)",
            "by unfold_locales (rule r, rule osum_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x",
            "have *: \"st.isMaxim {a \\<in> Field (s +o t). case_sum f1 g1 a \\<noteq> case_sum f2 g2 a} (Inl x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)",
            "using rst.isMaxim_max_fun_diff[OF assms(2-4)]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (st.max_fun_diff (case_sum f1 g1) (case_sum f2 g2))\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2",
            "hence \"s.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x",
            "unfolding st.isMaxim_def s.isMaxim_def Field_osum",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> s +o t)\n\ngoal (1 subgoal):\n 1. x \\<in> {a \\<in> Field s. f1 a \\<noteq> f2 a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f1 a \\<noteq> f2 a}. (a, x) \\<in> s)",
            "by (auto simp: osum_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2",
            "thus ?P",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f1 f2 = x",
            "unfolding s.max_fun_diff_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (1 subgoal):\n 1. s.maxim {a \\<in> Field s. f1 a \\<noteq> f2 a} = x",
            "by (rule s.maxim_equality)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff f1 f2 = x\n\ngoal (1 subgoal):\n 1. g1 = g2",
            "from assms(3,4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ncase_sum f1 g1 \\<in> rst.FINFUNC\ncase_sum f2 g2 \\<in> rst.FINFUNC",
            "have **: \"g1 \\<in> FinFunc r t\" \"g2 \\<in> FinFunc r t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncase_sum f1 g1 \\<in> rst.FINFUNC\ncase_sum f2 g2 \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. g1 \\<in> FinFunc r t &&& g2 \\<in> FinFunc r t",
            "unfolding FinFunc_osum",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ncase_sum f1 g1 \\<circ> Inl \\<in> FinFunc r s \\<and> case_sum f1 g1 \\<circ> Inr \\<in> FinFunc r t\ncase_sum f2 g2 \\<circ> Inl \\<in> FinFunc r s \\<and> case_sum f2 g2 \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 \\<in> FinFunc r t &&& g2 \\<in> FinFunc r t",
            "by (auto simp: o_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 = g2",
            "show ?Q",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. g1 = g2",
            "proof",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g1 x = g2 x",
            "fix x",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g1 x = g2 x",
            "from * **",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t",
            "show \"g1 x = g2 x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 x = g2 x",
            "unfolding st.isMaxim_def Field_osum FinFunc_def Func_def fun_eq_iff",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> s +o t)\ng1 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\ng2 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. g1 x = g2 x",
            "unfolding osum_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t})\ng1 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\ng2 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. g1 x = g2 x",
            "by (case_tac \"x \\<in> Field t\") auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng1 x = g2 x\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng1 = g2\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_eq_Inr:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inr x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff t g1 g2 = x\" (is ?P) \"g1 \\<noteq> g2\" (is ?Q)",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff t g1 g2 = x &&& g1 \\<noteq> g2",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff t g1 g2 = x\n 2. g1 \\<noteq> g2",
            "interpret st: wo_rel \"s +o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s +o t)",
            "by unfold_locales (rule osum_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff t g1 g2 = x\n 2. g1 \\<noteq> g2",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2",
            "interpret rst: wo_rel2 r \"s +o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)",
            "by unfold_locales (rule r, rule osum_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2",
            "from assms(1)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x",
            "have *: \"st.isMaxim {a \\<in> Field (s +o t). case_sum f1 g1 a \\<noteq> case_sum f2 g2 a} (Inr x)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)",
            "using rst.isMaxim_max_fun_diff[OF assms(2-4)]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (st.max_fun_diff (case_sum f1 g1) (case_sum f2 g2))\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)",
            "by simp",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)\n\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2",
            "hence \"t.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)\n\ngoal (1 subgoal):\n 1. t.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x",
            "unfolding st.isMaxim_def t.isMaxim_def Field_osum",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nInr x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inr x) \\<in> s +o t)\n\ngoal (1 subgoal):\n 1. x \\<in> {a \\<in> Field t. g1 a \\<noteq> g2 a} \\<and> (\\<forall>a\\<in>{a \\<in> Field t. g1 a \\<noteq> g2 a}. (a, x) \\<in> t)",
            "by (auto simp: osum_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2",
            "thus ?P ?Q",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (1 subgoal):\n 1. t.max_fun_diff g1 g2 = x &&& g1 \\<noteq> g2",
            "unfolding t.max_fun_diff_def fun_eq_iff",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (1 subgoal):\n 1. t.maxim {a \\<in> Field t. g1 a \\<noteq> g2 a} = x &&& \\<not> (\\<forall>x. g1 x = g2 x)",
            "by (auto intro: t.maxim_equality simp: t.isMaxim_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nt.max_fun_diff g1 g2 = x\ng1 \\<noteq> g2\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_osum: \"r ^o (s +o t) =o (r ^o s) *o (r ^o t)\" (is \"?R =o ?L\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o (s +o t) =o r ^o s *o r ^o t",
            "proof (rule ordIso_symmetric)",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o s *o r ^o t =o r ^o (s +o t)",
            "interpret rst: wo_rel2 r \"s +o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)",
            "by unfold_locales (rule r, rule osum_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o s *o r ^o t =o rst.oexp",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o r ^o t =o rst.oexp",
            "interpret rt: wo_rel2 r t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t",
            "by unfold_locales (rule r, rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "let ?f = \"\\<lambda>(f, g). case_sum f g\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "have \"bij_betw ?f (Field ?L) (Field ?R)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)",
            "unfolding bij_betw_def rst.Field_oexp rs.Field_oexp rt.Field_oexp Field_oprod",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). case_sum x y) (rs.FINFUNC \\<times> rt.FINFUNC) \\<and> (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC",
            "proof (intro conjI)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>(x, y). case_sum x y) (rs.FINFUNC \\<times> rt.FINFUNC)\n 2. (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC",
            "show \"inj_on ?f (FinFunc r s \\<times> FinFunc r t)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(f, g). case_sum f g) (rs.FINFUNC \\<times> rt.FINFUNC)",
            "unfolding inj_on_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>rs.FINFUNC \\<times> rt.FINFUNC. \\<forall>y\\<in>rs.FINFUNC \\<times> rt.FINFUNC. (case x of (x, xa) \\<Rightarrow> case_sum x xa) = (case y of (x, xa) \\<Rightarrow> case_sum x xa) \\<longrightarrow> x = y",
            "by (auto simp: fun_eq_iff split: sum.splits)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on (\\<lambda>(f, g). case_sum f g) (rs.FINFUNC \\<times> rt.FINFUNC)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC",
            "show \"?f ` (FinFunc r s \\<times> FinFunc r t) = FinFunc r (s +o t)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC",
            "proof safe",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)",
            "fix fg",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)",
            "assume \"fg \\<in> FinFunc r (s +o t)\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> rst.FINFUNC\n\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)",
            "thus \"fg \\<in> ?f ` (FinFunc r s \\<times> FinFunc r t)\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. fg \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)",
            "by (intro image_eqI[of _ _ \"(fg o Inl, fg o Inr)\"])\n          (auto simp: FinFunc_osum fun_eq_iff split: sum.splits)",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)\n\ngoal (1 subgoal):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC",
            "qed (auto simp: FinFunc_osum o_def)",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "moreover",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "have \"compat ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)",
            "unfolding compat_def rst.Field_oexp rs.Field_oexp rt.Field_oexp oprod_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> rt.oexp - Id \\<and> x1 \\<in> rs.FINFUNC \\<and> x2 \\<in> rs.FINFUNC \\<or> (y1, y2) \\<in> Restr Id rt.FINFUNC \\<and> (x1, x2) \\<in> rs.oexp} \\<longrightarrow> (case a of (x, xa) \\<Rightarrow> case_sum x xa, case b of (x, xa) \\<Rightarrow> case_sum x xa) \\<in> rst.oexp",
            "unfolding rst.oexp_def Let_def rs.oexp_def rt.oexp_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((f (wo_rel.max_fun_diff t f g), g (wo_rel.max_fun_diff t f g)) \\<in> r \\<or> f = g)} - Id \\<and> x1 \\<in> rs.FINFUNC \\<and> x2 \\<in> rs.FINFUNC \\<or> (y1, y2) \\<in> Restr Id rt.FINFUNC \\<and> (x1, x2) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((f (wo_rel.max_fun_diff s f g), g (wo_rel.max_fun_diff s f g)) \\<in> r \\<or> f = g)}} \\<longrightarrow> (case a of (x, xa) \\<Rightarrow> case_sum x xa, case b of (x, xa) \\<Rightarrow> case_sum x xa) \\<in> {(f, g). f \\<in> rst.FINFUNC \\<and> g \\<in> rst.FINFUNC \\<and> ((f (wo_rel.max_fun_diff (s +o t) f g), g (wo_rel.max_fun_diff (s +o t) f g)) \\<in> r \\<or> f = g)}",
            "by (fastforce simp: Field_osum FinFunc_osum o_def split: sum.splits\n        dest: max_fun_diff_eq_Inl max_fun_diff_eq_Inr)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "ultimately",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)",
            "have \"iso ?L ?R ?f\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. iso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)",
            "by (subst iso_iff3) (auto intro: oexp_Well_order oprod_Well_order osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "thus \"?L =o ?R\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "using r s t",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp",
            "unfolding ordIso_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (rs.oexp *o rt.oexp, rst.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oexp_Well_order oprod_Well_order osum_Well_order)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrs.oexp *o rt.oexp =o rst.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "definition \"rev_curr f b = (if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined)\"",
            0,
            "NA"
        ],
        [
            "",
            "lemma rev_curr_FinFunc:\n  assumes Field: \"Field r \\<noteq> {}\"\n  shows \"rev_curr ` (FinFunc r (s *o t)) = FinFunc (r ^o s) t\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. local.rev_curr ` FinFunc r (s *o t) = FinFunc (r ^o s) t",
            "proof safe",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> FinFunc (r ^o s) t\n 2. \\<And>x. x \\<in> FinFunc (r ^o s) t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> FinFunc rs.oexp t\n 2. \\<And>x. x \\<in> FinFunc rs.oexp t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "interpret rst: wo_rel2 \"r ^o s\" t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t",
            "by unfold_locales (rule oexp_Well_order[OF r s], rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "fix g",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "assume g: \"g \\<in> FinFunc r (s *o t)\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\ng \\<in> FinFunc r (s *o t)\n\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "hence \"finite (rst.SUPP (rev_curr g))\" \"\\<forall>x \\<in> Field t. finite (rs.SUPP (rev_curr g x))\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> FinFunc r (s *o t)\n\ngoal (1 subgoal):\n 1. finite (rst.SUPP (local.rev_curr g)) &&& \\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))",
            "unfolding FinFunc_def Field_oprod rs.Field_oexp Func_def fin_support_def support_def\n      rs.zero_oexp[OF Field] rev_curr_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}\n\ngoal (1 subgoal):\n 1. finite {x \\<in> Field t. (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) \\<noteq> rs.const} &&& \\<forall>x\\<in>Field t. finite {xa \\<in> Field s. (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa \\<noteq> zero r}",
            "by (auto simp: fun_eq_iff rs.const_def elim!: finite_surj)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "with g",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\ng \\<in> FinFunc r (s *o t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))",
            "show \"rev_curr g \\<in> FinFunc (r ^o s) t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> FinFunc r (s *o t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (1 subgoal):\n 1. local.rev_curr g \\<in> rst.FINFUNC",
            "unfolding FinFunc_def Field_oprod rs.Field_oexp Func_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ng \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (1 subgoal):\n 1. local.rev_curr g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero rs.oexp) (Field t)",
            "by (auto simp: rev_curr_def fin_support_def)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> FinFunc (r ^o s) t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> FinFunc rs.oexp t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "interpret rst: wo_rel2 \"r ^o s\" t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t",
            "by unfold_locales (rule oexp_Well_order[OF r s], rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "fix fg",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "assume *: \"fg \\<in> FinFunc (r ^o s) t\"",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "let ?g = \"\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined\"",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "show \"fg \\<in> rev_curr ` FinFunc r (s *o t)\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. fg \\<in> local.rev_curr ` FinFunc r (s *o t)",
            "proof (rule image_eqI[of _ _ ?g])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. fg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)\n 2. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "show \"fg = rev_curr ?g\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. fg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)",
            "proof",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x",
            "fix x",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x",
            "from *",
            6,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC",
            "show \"fg x = rev_curr ?g x\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x",
            "unfolding FinFunc_def rs.Field_oexp Func_def rev_curr_def Field_oprod",
            7,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero rs.oexp) (Field t)\n\ngoal (1 subgoal):\n 1. fg x = (if x \\<in> Field t then \\<lambda>a. case (a, x) of (a, b) \\<Rightarrow> if (a, b) \\<in> Field s \\<times> Field t then fg b a else undefined else undefined)",
            "by auto",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "have **: \"(\\<Union>g \\<in> fg ` Field t. rs.SUPP g) =\n              (\\<Union>g \\<in> fg ` Field t - {rs.const}. rs.SUPP g)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (rs.SUPP ` fg ` Field t) = \\<Union> (rs.SUPP ` (fg ` Field t - {rs.const}))",
            "unfolding support_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>g\\<in>fg ` Field t. {x \\<in> Field s. g x \\<noteq> zero r}) = (\\<Union>g\\<in>fg ` Field t - {rs.const}. {x \\<in> Field s. g x \\<noteq> zero r})",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<Union> (rs.SUPP ` fg ` Field t) = \\<Union> (rs.SUPP ` (fg ` Field t - {rs.const}))\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "from *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC",
            "have ***: \"\\<forall>g \\<in> fg ` Field t. finite (rs.SUPP g)\" \"finite (rst.SUPP fg)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g) &&& finite (rst.SUPP fg)",
            "unfolding rs.Field_oexp FinFunc_def Func_def fin_support_def Option.these_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)}) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rst.SUPP f)}\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g) &&& finite (rst.SUPP fg)",
            "by force+",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "hence \"finite (fg ` Field t - {rs.const})\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})",
            "using *",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})",
            "unfolding support_def rs.zero_oexp[OF Field] FinFunc_def Func_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite {x \\<in> Field s. g x \\<noteq> zero r}\nfinite {x \\<in> Field t. fg x \\<noteq> rs.const}\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field rs.oexp) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support rs.const (Field t)\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})",
            "by (elim finite_surj[of _ _ fg]) (fastforce simp: image_iff Option.these_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (fg ` Field t - {rs.const})\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "with ***",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfinite (fg ` Field t - {rs.const})",
            "have \"finite ((\\<Union>g \\<in> fg ` Field t. rs.SUPP g) \\<times> rst.SUPP fg)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfinite (fg ` Field t - {rs.const})\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)",
            "by (subst **) (auto intro!: finite_cartesian_product)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "with *",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)",
            "show \"?g \\<in> FinFunc r (s *o t)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)",
            "unfolding Field_oprod rs.Field_oexp FinFunc_def Func_def fin_support_def Option.these_def\n        support_def rs.zero_oexp[OF Field]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero r}}) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> rs.const}}\nfinite ((\\<Union>g\\<in>fg ` Field t. {x \\<in> Field s. g x \\<noteq> zero r}) \\<times> {x \\<in> Field t. fg x \\<noteq> rs.const})\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field s \\<times> Field t then fg b a else undefined) \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}",
            "by (auto elim!: finite_subset[rotated])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg \\<in> local.rev_curr ` FinFunc r (s *o t)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma rev_curr_app_FinFunc[elim!]:\n  \"\\<lbrakk>f \\<in> FinFunc r (s *o t); z \\<in> Field t\\<rbrakk> \\<Longrightarrow> rev_curr f z \\<in> FinFunc r s\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FinFunc r (s *o t); z \\<in> Field t\\<rbrakk> \\<Longrightarrow> local.rev_curr f z \\<in> FinFunc r s",
            "unfolding rev_curr_def FinFunc_def Func_def Field_oprod fin_support_def support_def",
            1,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}; z \\<in> Field t\\<rbrakk> \\<Longrightarrow> (if z \\<in> Field t then \\<lambda>a. f (a, z) else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero r}}",
            "by (auto elim: finite_surj)",
            1,
            "NA"
        ],
        [
            "",
            "lemma max_fun_diff_oprod:\n  assumes Field: \"Field r \\<noteq> {}\" and \"f \\<noteq> g\" \"f \\<in> FinFunc r (s *o t)\" \"g \\<in> FinFunc r (s *o t)\"\n  defines \"m \\<equiv> wo_rel.max_fun_diff t (rev_curr f) (rev_curr g)\"\n  shows \"wo_rel.max_fun_diff (s *o t) f g =\n    (wo_rel.max_fun_diff s (rev_curr f m) (rev_curr g m), m)\"",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff (s *o t) f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)",
            "proof -",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff (s *o t) f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret st: wo_rel \"s *o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s *o t)",
            "by unfold_locales (rule oprod_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret s: wo_rel s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s",
            "by unfold_locales (rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret t: wo_rel t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t",
            "by unfold_locales (rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret r_st: wo_rel2 r \"s *o t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s *o t)",
            "by unfold_locales (rule r, rule oprod_Well_order[OF s t])",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "interpret rst: wo_rel2 \"r ^o s\" t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t",
            "by unfold_locales (rule oexp_Well_order[OF r s], rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "from fun_unequal_in_support[OF assms(2), of \"Field (s *o t)\" \"Field r\" \"Field r\"] assms(3,4)",
            2,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC",
            "have diff1: \"rev_curr f \\<noteq> rev_curr g\"\n      \"rev_curr f \\<in> FinFunc (r ^o s) t\" \"rev_curr g \\<in> FinFunc (r ^o s) t\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f \\<noteq> local.rev_curr g &&& local.rev_curr f \\<in> rst.FINFUNC &&& local.rev_curr g \\<in> rst.FINFUNC",
            "using rev_curr_FinFunc[OF Field]",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\nlocal.rev_curr ` r_st.FINFUNC = rst.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f \\<noteq> local.rev_curr g &&& local.rev_curr f \\<in> rst.FINFUNC &&& local.rev_curr g \\<in> rst.FINFUNC",
            "unfolding fun_eq_iff rev_curr_def[abs_def] FinFunc_def support_def Field_oprod",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field s \\<times> Field t) (Field r); g \\<in> Func (Field s \\<times> Field t) (Field r)\\<rbrakk> \\<Longrightarrow> ({x \\<in> Field s \\<times> Field t. f x \\<noteq> ?z} \\<union> {x \\<in> Field s \\<times> Field t. g x \\<noteq> ?z}) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)\ng \\<in> Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)\n(\\<lambda>f b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) ` (Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)) = Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x xa. (if x \\<in> Field t then \\<lambda>a. f (a, x) else undefined) xa = (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa) &&& (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) \\<in> Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t) &&& (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t)",
            "by auto fast",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "hence diff2: \"rev_curr f m \\<noteq> rev_curr g m\" \"rev_curr f m \\<in> FinFunc r s\" \"rev_curr g m \\<in> FinFunc r s\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f m \\<noteq> local.rev_curr g m &&& local.rev_curr f m \\<in> rs.FINFUNC &&& local.rev_curr g m \\<in> rs.FINFUNC",
            "using rst.max_fun_diff[OF diff1] assms(3,4) rst.max_fun_diff_in",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field rs.oexp \\<and> b \\<in> Field rs.oexp \\<and> local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = a \\<and> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = b\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> rst.FINFUNC; ?g \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff ?f ?g \\<in> {a \\<in> Field t. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. local.rev_curr f m \\<noteq> local.rev_curr g m &&& local.rev_curr f m \\<in> rs.FINFUNC &&& local.rev_curr g m \\<in> rs.FINFUNC",
            "unfolding m_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field rs.oexp \\<and> b \\<in> Field rs.oexp \\<and> local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = a \\<and> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = b\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> rst.FINFUNC; ?g \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff ?f ?g \\<in> {a \\<in> Field t. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<noteq> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) &&& local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> rs.FINFUNC &&& local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> rs.FINFUNC",
            "by auto",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlocal.rev_curr f m \\<noteq> local.rev_curr g m\nlocal.rev_curr f m \\<in> rs.FINFUNC\nlocal.rev_curr g m \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "unfolding st.max_fun_diff_def",
            3,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. st.maxim {a \\<in> Field (s *o t). f a \\<noteq> g a} = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)",
            "proof (intro st.maxim_equality, unfold st.isMaxim_def Field_oprod, safe)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (4 subgoals):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s\n 2. m \\<in> Field t\n 3. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 4. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "show \"s.max_fun_diff (rev_curr f m) (rev_curr g m) \\<in> Field s\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s",
            "using rs.max_fun_diff_in[OF diff2]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> {a \\<in> Field s. local.rev_curr f m a \\<noteq> local.rev_curr g m a}\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s\n\ngoal (3 subgoals):\n 1. m \\<in> Field t\n 2. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 3. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (3 subgoals):\n 1. m \\<in> Field t\n 2. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 3. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "show \"m \\<in> Field t\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> Field t",
            "using rst.max_fun_diff_in[OF diff1]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\n\ngoal (1 subgoal):\n 1. m \\<in> Field t",
            "unfolding m_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> Field t",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nm \\<in> Field t\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "assume \"f (s.max_fun_diff (rev_curr f m) (rev_curr g m), m) =\n            g (s.max_fun_diff (rev_curr f m) (rev_curr g m), m)\"\n           (is \"f (?x, m) = g (?x, m)\")",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "hence \"rev_curr f m ?x = rev_curr g m ?x\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal (1 subgoal):\n 1. local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))",
            "unfolding rev_curr_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined), m) = g (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined), m)\n\ngoal (1 subgoal):\n 1. (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined)) = (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined) (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined))",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "with rs.max_fun_diff[OF diff2]",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = a \\<and> local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = b\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))",
            "show False",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = a \\<and> local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = b\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))\n\ngoal (1 subgoal):\n 1. False",
            "by auto",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "fix x y",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "assume \"f (x, y) \\<noteq> g (x, y)\" \"x \\<in> Field s\" \"y \\<in> Field t\"",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "thus \"((x, y), (s.max_fun_diff (rev_curr f m) (rev_curr g m), m)) \\<in> s *o t\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "using rst.max_fun_diff_in[OF diff1] rs.max_fun_diff_in[OF diff2] diff1 diff2\n        rst.max_fun_diff_max[OF diff1, of y] rs.max_fun_diff_le_eq[OF _ diff2, of x]",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> {a \\<in> Field s. local.rev_curr f m a \\<noteq> local.rev_curr g m a}\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\nlocal.rev_curr f m \\<noteq> local.rev_curr g m\nlocal.rev_curr f m \\<in> rs.FINFUNC\nlocal.rev_curr g m \\<in> rs.FINFUNC\ny \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a} \\<Longrightarrow> (y, t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> t\n\\<lbrakk>(s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), x) \\<in> s; x \\<noteq> s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)\\<rbrakk> \\<Longrightarrow> local.rev_curr f m x = local.rev_curr g m x\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t",
            "unfolding oprod_def m_def rev_curr_def fun_eq_iff",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\nt.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> {a \\<in> Field t. \\<not> (\\<forall>x. (if a \\<in> Field t then \\<lambda>aa. f (aa, a) else undefined) x = (if a \\<in> Field t then \\<lambda>aa. g (aa, a) else undefined) x)}\ns.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> {a \\<in> Field s. (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) a \\<noteq> (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) a}\n\\<not> (\\<forall>x xa. (if x \\<in> Field t then \\<lambda>a. f (a, x) else undefined) xa = (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa)\n(\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) \\<in> rst.FINFUNC\n(\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> rst.FINFUNC\n\\<not> (\\<forall>x. (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x = (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x)\n(if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> rs.FINFUNC\n(if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> rs.FINFUNC\ny \\<in> {a \\<in> Field t. \\<not> (\\<forall>x. (if a \\<in> Field t then \\<lambda>aa. f (aa, a) else undefined) x = (if a \\<in> Field t then \\<lambda>aa. g (aa, a) else undefined) x)} \\<Longrightarrow> (y, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) \\<in> t\n\\<lbrakk>(s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined), x) \\<in> s; x \\<noteq> s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined)\\<rbrakk> \\<Longrightarrow> (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x = (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined), t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}",
            "by (auto intro: s.in_notinI)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\n((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nst.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "lemma oexp_oexp: \"(r ^o s) ^o t =o r ^o (s *o t)\" (is \"?R =o ?L\")",
            0,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o s ^o t =o r ^o (s *o t)",
            "proof (cases \"r = {}\")",
            1,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)",
            "case True",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr = {}\n\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)",
            "interpret rs: wo_rel2 r s",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> rs.oexp ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> rs.oexp ^o t =o r ^o (s *o t)",
            "interpret rst: wo_rel2 \"r ^o s\" t",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t",
            "by unfold_locales (rule oexp_Well_order[OF r s], rule t)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)",
            "proof (cases \"s = {} \\<or> t = {}\")",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. s = {} \\<or> t = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "case True",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns = {} \\<or> t = {}\n\ngoal (2 subgoals):\n 1. s = {} \\<or> t = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "with \\<open>r = {}\\<close>",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nr = {}\ns = {} \\<or> t = {}",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr = {}\ns = {} \\<or> t = {}\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)",
            "by (auto simp: oexp_empty[OF oexp_Well_order[OF Well_order_empty s]]\n        intro!: ordIso_transitive[OF ordIso_symmetric[OF oone_ordIso] oone_ordIso]\n          ordIso_transitive[OF oone_ordIso_oexp[OF ordIso_symmetric[OF oone_ordIso] t] oone_ordIso])",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "next",
            4,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "case False",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "hence \"s *o t \\<noteq> {}\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. s *o t \\<noteq> {}",
            "unfolding oprod_def Field_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Domain s \\<union> Range s \\<and> x2 \\<in> Domain s \\<union> Range s \\<or> (y1, y2) \\<in> Restr Id (Domain t \\<union> Range t) \\<and> (x1, x2) \\<in> s} \\<noteq> {}",
            "by fastforce",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\ns *o t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "with False",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}",
            "show ?thesis",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)",
            "using \\<open>r = {}\\<close> ozero_ordIso",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}\nr = {}\nozero =o ozero\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)",
            "by (auto simp add: s t oprod_Well_order ozero_def)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)",
            "next",
            2,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)",
            "case False",
            2,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)",
            "hence Field: \"Field r \\<noteq> {}\"",
            2,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}",
            "by (metis Field_def Range_empty_iff Un_empty)",
            3,
            "NA"
        ],
        [
            "proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)",
            "show ?thesis",
            2,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. r ^o s ^o t =o r ^o (s *o t)",
            "proof (rule ordIso_symmetric)",
            3,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r ^o (s *o t) =o r ^o s ^o t",
            "interpret r_st: wo_rel2 r \"s *o t\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s *o t)",
            "by unfold_locales (rule r, rule oprod_Well_order[OF s t])",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o r ^o s ^o t",
            "interpret rs: wo_rel2 r s",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s",
            "by unfold_locales (rule r, rule s)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o rs.oexp ^o t",
            "interpret rst: wo_rel2 \"r ^o s\" t",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t",
            "by unfold_locales (rule oexp_Well_order[OF r s], rule t)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "have bij: \"bij_betw rev_curr (Field ?L) (Field ?R)\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. bij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)",
            "unfolding bij_betw_def r_st.Field_oexp rst.Field_oexp Field_oprod",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.rev_curr r_st.FINFUNC \\<and> local.rev_curr ` r_st.FINFUNC = rst.FINFUNC",
            "proof (intro conjI)",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. inj_on local.rev_curr r_st.FINFUNC\n 2. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC",
            "show \"inj_on rev_curr (FinFunc r (s *o t))\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.rev_curr r_st.FINFUNC",
            "unfolding inj_on_def FinFunc_def Func_def Field_oprod rs.Field_oexp rev_curr_def[abs_def]",
            7,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t). \\<forall>y\\<in>{f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t). (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. x (a, b) else undefined) = (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. y (a, b) else undefined) \\<longrightarrow> x = y",
            "by (auto simp: fun_eq_iff) metis",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\ninj_on local.rev_curr r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC",
            "show \"rev_curr ` (FinFunc r (s *o t)) = FinFunc (r ^o s) t\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC",
            "by (rule rev_curr_FinFunc[OF Field])",
            7,
            "NA"
        ],
        [
            "proof (state)\nthis:\nlocal.rev_curr ` r_st.FINFUNC = rst.FINFUNC\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "moreover",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "have \"compat ?L ?R rev_curr\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. compat r_st.oexp rst.oexp local.rev_curr",
            "unfolding compat_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r_st.oexp \\<longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp",
            "proof safe",
            5,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp",
            "fix fg1 fg2",
            6,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp",
            "assume fg: \"(fg1, fg2) \\<in> r ^o (s *o t)\"",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(fg1, fg2) \\<in> r_st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp",
            "show \"(rev_curr fg1, rev_curr fg2) \\<in> r ^o s ^o t\"",
            6,
            "NA"
        ],
        [
            "proof (prove)\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "proof (cases \"fg1 = fg2\")",
            7,
            "NA"
        ],
        [
            "proof (state)\ngoal (2 subgoals):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n 2. fg1 \\<noteq> fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "assume \"fg1 \\<noteq> fg2\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg1 \\<noteq> fg2\n\ngoal (2 subgoals):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n 2. fg1 \\<noteq> fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "with fg",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "using rst.max_fun_diff_in[of \"rev_curr fg1\" \"rev_curr fg2\"]\n          max_fun_diff_oprod[OF Field, of fg1 fg2]  rev_curr_FinFunc[OF Field, symmetric]",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "unfolding r_st.Field_oexp rs.Field_oexp rst.Field_oexp",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "unfolding r_st.oexp_def rst.oexp_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> {(f, g). f \\<in> r_st.FINFUNC \\<and> g \\<in> r_st.FINFUNC \\<and> ((let m = wo_rel.max_fun_diff (s *o t) f g in (f m, g m) \\<in> r) \\<or> f = g)}\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> {(f, g). f \\<in> rst.FINFUNC \\<and> g \\<in> rst.FINFUNC \\<and> ((let m = wo_rel.max_fun_diff t f g in (f m, g m) \\<in> rs.oexp) \\<or> f = g)}",
            "by (auto simp: rs.oexp_def Let_def) (auto simp: rev_curr_def[abs_def])",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "next",
            8,
            "NA"
        ],
        [
            "proof (state)\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "assume \"fg1 = fg2\"",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "with fg bij",
            8,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\n(fg1, fg2) \\<in> r_st.oexp\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\nfg1 = fg2",
            "show ?thesis",
            8,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "unfolding r_st.Field_oexp rs.Field_oexp rst.Field_oexp bij_betw_def",
            9,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\ninj_on local.rev_curr r_st.FINFUNC \\<and> local.rev_curr ` r_st.FINFUNC = rst.FINFUNC\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp",
            "by (auto simp: r_st.oexp_def rst.oexp_def)",
            9,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            8,
            "NA"
        ],
        [
            "proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            6,
            "NA"
        ],
        [
            "proof (state)\nthis:\ncompat r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "ultimately",
            4,
            "NA"
        ],
        [
            "proof (chain)\npicking this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr",
            "have \"iso ?L ?R rev_curr\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. iso r_st.oexp rst.oexp local.rev_curr",
            "using r s t",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso r_st.oexp rst.oexp local.rev_curr",
            "by (subst iso_iff3) (auto intro: oexp_Well_order oprod_Well_order)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\niso r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "thus \"?L =o ?R\"",
            4,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "using r s t",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp",
            "unfolding ordIso_def",
            5,
            "NA"
        ],
        [
            "proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r_st.oexp, rst.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}",
            "by (auto intro: oexp_Well_order oprod_Well_order)",
            5,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr_st.oexp =o rst.oexp\n\ngoal:\nNo subgoals!",
            "qed",
            4,
            "NA"
        ],
        [
            "proof (state)\nthis:\nr ^o s ^o t =o r ^o (s *o t)\n\ngoal:\nNo subgoals!",
            "qed",
            2,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ],
        [
            "",
            "end",
            0,
            "NA"
        ]
    ],
    "whole_thing": "<\\STATESEP>section \\<open>Ordinal Arithmetic\\<close><\\STATESEP>0<\\TRANSEP><\\STATESEP>theory Ordinal_Arithmetic\nimports Wellorder_Constructions\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition osum :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a + 'b) rel\"  (infixr \"+o\" 70)\nwhere\n  \"r +o r' = map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union>\n     {(Inl a, Inr a') | a a' . a \\<in> Field r \\<and> a' \\<in> Field r'}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma Field_osum: \"Field(r +o r') = Inl ` Field r \\<union> Inr ` Field r'\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field (r +o r') = Inl ` Field r \\<union> Inr ` Field r'<\\STATESEP>unfolding osum_def Field_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Domain (map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}) \\<union> Range (map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}) = Inl ` (Domain r \\<union> Range r) \\<union> Inr ` (Domain r' \\<union> Range r')<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r')<\\STATESEP>unfolding refl_on_def Field_osum<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> r +o r' \\<subseteq> (Inl ` Field r \\<union> Inr ` Field r') \\<times> (Inl ` Field r \\<union> Inr ` Field r') \\<and> (\\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. (x, x) \\<in> r +o r')<\\STATESEP>unfolding osum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<subseteq> (Inl ` Field r \\<union> Inr ` Field r') \\<times> (Inl ` Field r \\<union> Inr ` Field r') \\<and> (\\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. (x, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'})<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_trans:\nassumes TRANS: \"trans r\" and TRANS': \"trans r'\"\nshows \"trans (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. trans (r +o r')<\\STATESEP>proof(unfold trans_def, safe)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>fix x y z<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>assume *: \"(x, y) \\<in> r +o r'\" \"(y, z) \\<in> r +o r'\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\n\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>thus \"(x, z) \\<in> r +o r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'<\\STATESEP>proof (cases x y z rule: sum.exhaust[case_product sum.exhaust sum.exhaust])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>case (Inl_Inl_Inl a b c)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inl c<\\STATESEP>have \"(a,b) \\<in> r\" \"(b,c) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r &&& (b, c) \\<in> r<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\nx = Inl a\ny = Inl b\nz = Inl c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r &&& (b, c) \\<in> r<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with TRANS<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ntrans r\n(a, b) \\<in> r\n(b, c) \\<in> r<\\STATESEP>have \"(a,c) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ntrans r\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r<\\STATESEP>unfolding trans_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x y z. (x, y) \\<in> r \\<longrightarrow> (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r\n(a, b) \\<in> r\n(b, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(a, c) \\<in> r\n\ngoal (8 subgoals):\n 1. \\<And>x1___ x1a___ x1b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inl x1b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 8. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with Inl_Inl_Inl<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inl c\n(a, c) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>case (Inl_Inl_Inr a b c)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inr c<\\STATESEP>have \"a \\<in> Field r\" \"c \\<in> Field r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Field r &&& c \\<in> Field r'<\\STATESEP>unfolding osum_def Field_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\nx = Inl a\ny = Inl b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Domain r \\<union> Range r &&& c \\<in> Domain r' \\<union> Range r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (7 subgoals):\n 1. \\<And>x1___ x1a___ x2__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inl x1a___; z = Inr x2__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 7. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with Inl_Inl_Inr<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inl b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>case (Inl_Inr_Inr a b c)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inr b\nz = Inr c<\\STATESEP>have \"a \\<in> Field r\" \"c \\<in> Field r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Field r &&& c \\<in> Field r'<\\STATESEP>unfolding osum_def Field_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}\nx = Inl a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. a \\<in> Domain r \\<union> Range r &&& c \\<in> Domain r' \\<union> Range r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (6 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x1___ x2___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 6. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with Inl_Inr_Inr<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx = Inl a\ny = Inr b\nz = Inr c\na \\<in> Field r\nc \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>case (Inr_Inr_Inr a b c)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inr a\ny = Inr b\nz = Inr c<\\STATESEP>have \"(a,b) \\<in> r'\" \"(b,c) \\<in> r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r +o r'\n(y, z) \\<in> r +o r'\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r' &&& (b, c) \\<in> r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\n(y, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}\nx = Inr a\ny = Inr b\nz = Inr c\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> r' &&& (b, c) \\<in> r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with TRANS'<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ntrans r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'<\\STATESEP>have \"(a,c) \\<in> r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ntrans r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r'<\\STATESEP>unfolding trans_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x y z. (x, y) \\<in> r' \\<longrightarrow> (y, z) \\<in> r' \\<longrightarrow> (x, z) \\<in> r'\n(a, b) \\<in> r'\n(b, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> r'<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(a, c) \\<in> r'\n\ngoal (5 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 5. \\<And>x2___ x2a___ x2b__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inr x2b__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>with Inr_Inr_Inr<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx = Inr a\ny = Inr b\nz = Inr c\n(a, c) \\<in> r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal (4 subgoals):\n 1. \\<And>x1___ x2___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inl x1___; y = Inr x2___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 2. \\<And>x2___ x1___ x1a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inl x1a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 3. \\<And>x2___ x1___ x2a__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inl x1___; z = Inr x2a__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'\n 4. \\<And>x2___ x2a___ x1__. \\<lbrakk>(x, y) \\<in> r +o r'; (y, z) \\<in> r +o r'; x = Inr x2___; y = Inr x2a___; z = Inl x1__\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> r +o r'<\\STATESEP>qed (auto simp: osum_def)<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r +o r'\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_Preorder: \"\\<lbrakk>Preorder r; Preorder r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r; Preorder r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r')<\\STATESEP>unfolding preorder_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r') \\<and> trans (r +o r')<\\STATESEP>using osum_Refl osum_trans<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Refl ?r; Refl ?r'\\<rbrakk> \\<Longrightarrow> Refl (?r +o ?r')\n\\<lbrakk>trans ?r; trans ?r'\\<rbrakk> \\<Longrightarrow> trans (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'\\<rbrakk> \\<Longrightarrow> Refl (r +o r') \\<and> trans (r +o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r +o r')<\\STATESEP>unfolding antisym_def osum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y; \\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y\\<rbrakk> \\<Longrightarrow> \\<forall>x y. (x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<longrightarrow> (y, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<longrightarrow> x = y<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r')<\\STATESEP>unfolding partial_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r') \\<and> antisym (r +o r')<\\STATESEP>using osum_Preorder osum_antisym<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Preorder ?r; Preorder ?r'\\<rbrakk> \\<Longrightarrow> Preorder (?r +o ?r')\n\\<lbrakk>antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> antisym (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r +o r') \\<and> antisym (r +o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r +o r')<\\STATESEP>unfolding total_on_def Field_osum<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r +o r' \\<or> (y, x) \\<in> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field r'. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} \\<or> (y, x) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r +o r')<\\STATESEP>unfolding linear_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r') \\<and> Total (r +o r')<\\STATESEP>using osum_Partial_order osum_Total<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Partial_order ?r; Partial_order ?r'\\<rbrakk> \\<Longrightarrow> Partial_order (?r +o ?r')\n\\<lbrakk>Total ?r; Total ?r'\\<rbrakk> \\<Longrightarrow> Total (?r +o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r +o r') \\<and> Total (r +o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (r +o r')<\\STATESEP>unfolding wf_eq_minimal2<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field (r +o r') \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r')<\\STATESEP>unfolding Field_osum<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r')<\\STATESEP>proof(intro allI impI, elim conjE)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>fix A<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>assume *: \"A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\" and **: \"A \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nA \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>obtain B where B_def: \"B = A Int Inl ` Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. B = A \\<inter> Inl ` Field r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>proof(cases \"B = {}\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nB \\<noteq> {}\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>hence \"B \\<noteq> {}\" \"B \\<le> Inl ` Field r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} &&& B \\<subseteq> Inl ` Field r<\\STATESEP>using B_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} &&& B \\<subseteq> Inl ` Field r<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>hence \"Inl -` B \\<noteq> {}\" \"Inl -` B \\<le> Field r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (1 subgoal):\n 1. Inl -` B \\<noteq> {} &&& Inl -` B \\<subseteq> Field r<\\STATESEP>unfolding vimage_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nB \\<subseteq> Inl ` Field r\n\ngoal (1 subgoal):\n 1. {x. Inl x \\<in> B} \\<noteq> {} &&& {x. Inl x \\<in> B} \\<subseteq> Field r<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>then<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r<\\STATESEP>obtain a where 1: \"a \\<in> Inl -` B\" and \"\\<forall>a1 \\<in> Inl -` B. (a1, a) \\<notin> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using WF<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\nwf r\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding wf_eq_minimal2<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nInl -` B \\<noteq> {}\nInl -` B \\<subseteq> Field r\n\\<forall>A. A \\<subseteq> Field r \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>a. \\<lbrakk>a \\<in> Inl -` B; \\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by metis<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>hence \"\\<forall>a1 \\<in> A. (a1, Inl a) \\<notin> r +o r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>using B_def **<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\na \\<in> Inl -` B\n\\<forall>a1\\<in>Inl -` B. (a1, a) \\<notin> r\nB = A \\<inter> Inl ` Field r\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>A. (a1, Inl a) \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by (auto simp: vimage_def Field_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n 2. B \\<noteq> {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>using 1<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\na \\<in> Inl -` B\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>unfolding B_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a1\\<in>A. (a1, Inl a) \\<notin> r +o r'\na \\<in> Inl -` (A \\<inter> Inl ` Field r)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nB = {}\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>hence 1: \"A \\<le> Inr ` Field r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nB = {}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Inr ` Field r'<\\STATESEP>using * B_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nB = {}\nA \\<subseteq> Inl ` Field r \\<union> Inr ` Field r'\nB = A \\<inter> Inl ` Field r\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Inr ` Field r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>with **<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'<\\STATESEP>have \"Inr -`A \\<noteq> {}\" \"Inr -` A \\<le> Field r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. Inr -` A \\<noteq> {} &&& Inr -` A \\<subseteq> Field r'<\\STATESEP>unfolding vimage_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. {x. Inr x \\<in> A} \\<noteq> {} &&& {x. Inr x \\<in> A} \\<subseteq> Field r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>with **<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'<\\STATESEP>obtain a' where 2: \"a' \\<in> Inr -` A\" and \"\\<forall>a1' \\<in> Inr -` A. (a1',a') \\<notin> r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using WF'<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\nwf r'\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding wf_eq_minimal2<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\nInr -` A \\<noteq> {}\nInr -` A \\<subseteq> Field r'\n\\<forall>A. A \\<subseteq> Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r')\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<lbrakk>a' \\<in> Inr -` A; \\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by metis<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>hence \"\\<forall>a1' \\<in> A. (a1', Inr a') \\<notin> r +o r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>using ** 1<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\na' \\<in> Inr -` A\n\\<forall>a1'\\<in>Inr -` A. (a1', a') \\<notin> r'\nA \\<noteq> {}\nA \\<subseteq> Inr ` Field r'\n\ngoal (1 subgoal):\n 1. \\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by (auto simp: vimage_def Field_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>using 2<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a1'\\<in>A. (a1', Inr a') \\<notin> r +o r'\na' \\<in> Inr -` A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r +o r'\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r +o r') - Id \\<le> (r - Id) +o (r' - Id)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)<\\STATESEP>unfolding osum_def Total_Id_Field[OF r] Total_Id_Field[OF r']<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field (r - Id) \\<and> a' \\<in> Field (r' - Id)} - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> map_prod Inr Inr ` (r' - Id) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field (r - Id) \\<and> a' \\<in> Field (r' - Id)}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (Inl ` Field r \\<times> Inr ` Field r') \\<union> (map_prod Inr Inr ` (r' - Id))\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> r +o r' - Id \\<subseteq> Inl ` Field r \\<times> Inr ` Field r' \\<union> map_prod Inr Inr ` (r' - Id)<\\STATESEP>unfolding osum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} - Id \\<subseteq> Inl ` Field r \\<times> Inr ` Field r' \\<union> map_prod Inr Inr ` (r' - Id)<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> (r +o r') - Id \\<le> (map_prod Inl Inl ` (r - Id)) \\<union> (Inl ` Field r \\<times> Inr ` Field r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> r +o r' - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> Inl ` Field r \\<times> Inr ` Field r'<\\STATESEP>unfolding osum_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'} - Id \\<subseteq> map_prod Inl Inl ` (r - Id) \\<union> Inl ` Field r \\<times> Inr ` Field r'<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r +o r') - Id)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>proof(cases \"r \\<le> Id \\<or> r' \\<le> Id\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>using osum_minus_Id[of r r'] assms osum_wf[of \"r - Id\" \"r' - Id\"]\n    wf_subset[of \"(r - Id) +o (r' - Id)\" \"(r +o r') - Id\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\\<lbrakk>Total r; \\<not> r \\<subseteq> Id; Total r'; \\<not> r' \\<subseteq> Id\\<rbrakk> \\<Longrightarrow> r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)\nTotal r\nTotal r'\nwf (r - Id)\nwf (r' - Id)\n\\<lbrakk>wf (r - Id); wf (r' - Id)\\<rbrakk> \\<Longrightarrow> wf ((r - Id) +o (r' - Id))\n\\<lbrakk>wf ((r - Id) +o (r' - Id)); r +o r' - Id \\<subseteq> (r - Id) +o (r' - Id)\\<rbrakk> \\<Longrightarrow> wf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>have 1: \"wf (Inl ` Field r \\<times> Inr ` Field r')\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (Inl ` Field r \\<times> Inr ` Field r')<\\STATESEP>by (rule wf_Int_Times) auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf (Inl ` Field r \\<times> Inr ` Field r')\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>proof (elim disjE)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>assume \"r \\<subseteq> Id\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nr \\<subseteq> Id\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)\n 2. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>thus \"wf ((r +o r') - Id)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nr \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>by (rule wf_subset[rotated, OF osum_minus_Id1 wf_Un[OF 1 wf_map_prod_image[OF WF']]]) auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>assume \"r' \\<subseteq> Id\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nr' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> wf (r +o r' - Id)<\\STATESEP>thus \"wf ((r +o r') - Id)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nr' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r +o r' - Id)<\\STATESEP>by (rule wf_subset[rotated, OF osum_minus_Id2 wf_Un[OF wf_map_prod_image[OF WF] 1]]) auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nwf (r +o r' - Id)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r +o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>proof-<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>have \"Total r \\<and> Total r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'<\\STATESEP>using WELL WELL'<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'<\\STATESEP>by (auto simp add: order_on_defs)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>unfolding well_order_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r +o r') \\<and> wf (r +o r' - Id)<\\STATESEP>using osum_Linear_order osum_wf_Id<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\\<lbrakk>Linear_order ?r; Linear_order ?r'\\<rbrakk> \\<Longrightarrow> Linear_order (?r +o ?r')\n\\<lbrakk>Total ?r; Total ?r'; wf (?r - Id); wf (?r' - Id)\\<rbrakk> \\<Longrightarrow> wf (?r +o ?r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r +o r') \\<and> wf (r +o r' - Id)<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order (r +o r')\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_embedL:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\n  shows \"embed r (r +o r') Inl\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>have 1: \"Well_order (r +o r')\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r +o r')<\\STATESEP>by (auto simp add: osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order (r +o r')\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nWell_order (r +o r')\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>have \"compat r (r +o r') Inl\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat r (r +o r') Inl<\\STATESEP>unfolding compat_def osum_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (Inl a, Inl b) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat r (r +o r') Inl\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncompat r (r +o r') Inl\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>have \"ofilter (r +o r') (Inl ` Field r)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ofilter (r +o r') (Inl ` Field r)<\\STATESEP>unfolding wo_rel.ofilter_def[unfolded wo_rel_def, OF 1] Field_osum under_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Inl ` Field r \\<subseteq> Inl ` Field r \\<union> Inr ` Field r' \\<and> (\\<forall>a\\<in>Inl ` Field r. {b. (b, a) \\<in> r +o r'} \\<subseteq> Inl ` Field r)<\\STATESEP>unfolding osum_def Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Inl ` (Domain r \\<union> Range r) \\<subseteq> Inl ` (Domain r \\<union> Range r) \\<union> Inr ` (Domain r' \\<union> Range r') \\<and> (\\<forall>a\\<in>Inl ` (Domain r \\<union> Range r). {b. (b, a) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` r' \\<union> {(Inl a, Inr a') |a a'. a \\<in> Domain r \\<union> Range r \\<and> a' \\<in> Domain r' \\<union> Range r'}} \\<subseteq> Inl ` (Domain r \\<union> Range r))<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nofilter (r +o r') (Inl ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order (r +o r')\ncompat r (r +o r') Inl\nofilter (r +o r') (Inl ` Field r)\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. embed r (r +o r') Inl<\\STATESEP>by (auto simp add: embed_iff_compat_inj_on_ofilter)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembed r (r +o r') Inl\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>corollary osum_ordLeqL:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\n  shows \"r \\<le>o r +o r'\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r \\<le>o r +o r'<\\STATESEP>using assms osum_embedL osum_Well_order<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> embed ?r (?r +o ?r') Inl\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r +o ?r')\n\ngoal (1 subgoal):\n 1. r \\<le>o r +o r'<\\STATESEP>unfolding ordLeq_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> embed ?r (?r +o ?r') Inl\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r +o ?r')\n\ngoal (1 subgoal):\n 1. (r, r +o r') \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma dir_image_alt: \"dir_image r f = map_prod f f ` r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. dir_image r f = map_prod f f ` r<\\STATESEP>unfolding dir_image_def map_prod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {(f a, f b) |a b. (a, b) \\<in> r} = (\\<lambda>(x, y). (f x, f y)) ` r<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma map_prod_ordIso: \"\\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> map_prod f f ` r =o r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> map_prod f f ` r =o r<\\STATESEP>unfolding dir_image_alt[symmetric]<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; inj_on f (Field r)\\<rbrakk> \\<Longrightarrow> dir_image r f =o r<\\STATESEP>by (rule ordIso_symmetric[OF dir_image_ordIso])<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition oprod :: \"'a rel \\<Rightarrow> 'b rel \\<Rightarrow> ('a \\<times> 'b) rel\"  (infixr \"*o\" 80)\nwhere \"r *o r' = {((x1, y1), (x2, y2)).\n  (((y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r) \\<or>\n   ((y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r))}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma Field_oprod: \"Field (r *o r') = Field r \\<times> Field r'\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field (r *o r') = Field r \\<times> Field r'<\\STATESEP>unfolding oprod_def Field_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Domain {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Domain r \\<union> Range r \\<and> x2 \\<in> Domain r \\<union> Range r \\<or> (y1, y2) \\<in> Restr Id (Domain r' \\<union> Range r') \\<and> (x1, x2) \\<in> r} \\<union> Range {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Domain r \\<union> Range r \\<and> x2 \\<in> Domain r \\<union> Range r \\<or> (y1, y2) \\<in> Restr Id (Domain r' \\<union> Range r') \\<and> (x1, x2) \\<in> r} = (Domain r \\<union> Range r) \\<times> (Domain r' \\<union> Range r')<\\STATESEP>by auto blast+<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_Refl:\"\\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r; Refl r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r')<\\STATESEP>unfolding refl_on_def Field_oprod<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> r *o r' \\<subseteq> (Field r \\<times> Field r') \\<times> Field r \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r \\<times> Field r'. (x, x) \\<in> r *o r')<\\STATESEP>unfolding oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r); r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')\\<rbrakk> \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<subseteq> (Field r \\<times> Field r') \\<times> Field r \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r \\<times> Field r'. (x, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r})<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_trans:\n  assumes \"trans r\" \"trans r'\" \"antisym r\" \"antisym r'\"\n  shows \"trans (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. trans (r *o r')<\\STATESEP>proof(unfold trans_def, safe)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'<\\STATESEP>fix x y z<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'<\\STATESEP>assume *: \"(x, y) \\<in> r *o r'\" \"(y, z) \\<in> r *o r'\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(x, y) \\<in> r *o r'\n(y, z) \\<in> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb. \\<lbrakk>((a, b), aa, ba) \\<in> r *o r'; ((aa, ba), ab, bb) \\<in> r *o r'\\<rbrakk> \\<Longrightarrow> ((a, b), ab, bb) \\<in> r *o r'<\\STATESEP>thus \"(x, z) \\<in> r *o r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> r *o r'\n(y, z) \\<in> r *o r'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r *o r'<\\STATESEP>unfolding oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}\n(y, z) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}<\\STATESEP>apply safe<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (17 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> ya \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\nA total of 17 subgoals...<\\STATESEP>apply (metis assms(2) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (16 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> ya \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 16 subgoals...<\\STATESEP>apply (metis assms(2) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (15 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (ya, yb) \\<notin> r'\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 15 subgoals...<\\STATESEP>apply (metis assms(2) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (14 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 14 subgoals...<\\STATESEP>apply (metis assms(4) antisymD)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (13 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; \\<not> False\\<rbrakk> \\<Longrightarrow> yb \\<in> Field r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\nA total of 13 subgoals...<\\STATESEP>apply (metis assms(4) antisymD)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (12 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yaa); z = (xb, yb); (ya, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; ya \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (ya, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\nA total of 12 subgoals...<\\STATESEP>apply (metis assms(2) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (11 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yaa); z = (xb, yb); (yb, yaa) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (yaa, yb) \\<in> r'; yb \\<noteq> yaa; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\nA total of 11 subgoals...<\\STATESEP>apply (metis assms(4) antisymD)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (10 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 10. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Range_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; ya \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 9. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Range_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, ya); y = (xaa, yb); z = (xb, yb); (ya, yb) \\<in> r'; xa \\<in> Field r; xaa \\<in> Field r; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; ya \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 8. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Range_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (7 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yaa \\<noteq> yb\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 7. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Domain_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; yb \\<notin> Field r'\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 6. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Domain_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yaa); y = (xaa, yaa); z = (xb, yb); (xa, xaa) \\<in> r; yaa \\<in> Field r'; yaa \\<in> Field r'; (yaa, yb) \\<in> r'; xaa \\<in> Field r; xb \\<in> Field r; yaa \\<noteq> yb; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 5. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis Field_def Domain_iff Un_iff)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> (yb, yb) \\<in> r'\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 4. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis assms(1) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> False\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 3. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis assms(1) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xa \\<in> Field r\n 2. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis assms(1) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya xaa yaa xb yb. \\<lbrakk>x = (xa, yb); y = (xaa, yb); z = (xb, yb); (xa, xaa) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xaa, xb) \\<in> r; yb \\<in> Field r'; yb \\<in> Field r'; (xa, xb) \\<notin> r\\<rbrakk> \\<Longrightarrow> xb \\<in> Field r<\\STATESEP>apply (metis assms(1) transE)<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal:\nNo subgoals!<\\STATESEP>done<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(x, z) \\<in> r *o r'\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_Preorder: \"\\<lbrakk>Preorder r; Preorder r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r; Preorder r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r')<\\STATESEP>unfolding preorder_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r') \\<and> trans (r *o r')<\\STATESEP>using oprod_Refl oprod_trans<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Refl ?r; Refl ?r'\\<rbrakk> \\<Longrightarrow> Refl (?r *o ?r')\n\\<lbrakk>trans ?r; trans ?r'; antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> trans (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Refl r \\<and> trans r; Refl r' \\<and> trans r'; antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> Refl (r *o r') \\<and> trans (r *o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_antisym: \"\\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antisym r; antisym r'\\<rbrakk> \\<Longrightarrow> antisym (r *o r')<\\STATESEP>unfolding antisym_def oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y; \\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y\\<rbrakk> \\<Longrightarrow> \\<forall>x y. (x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (y, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<longrightarrow> x = y<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_Partial_order: \"\\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r; Partial_order r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r')<\\STATESEP>unfolding partial_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r') \\<and> antisym (r *o r')<\\STATESEP>using oprod_Preorder oprod_antisym<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Preorder ?r; Preorder ?r'; antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> Preorder (?r *o ?r')\n\\<lbrakk>antisym ?r; antisym ?r'\\<rbrakk> \\<Longrightarrow> antisym (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Preorder r \\<and> antisym r; Preorder r' \\<and> antisym r'\\<rbrakk> \\<Longrightarrow> Preorder (r *o r') \\<and> antisym (r *o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_Total: \"\\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Total r; Total r'\\<rbrakk> \\<Longrightarrow> Total (r *o r')<\\STATESEP>unfolding total_on_def Field_oprod<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Field r \\<times> Field r'. \\<forall>y\\<in>Field r \\<times> Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r *o r' \\<or> (y, x) \\<in> r *o r'<\\STATESEP>unfolding oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r; \\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r'\\<rbrakk> \\<Longrightarrow> \\<forall>x\\<in>Field r \\<times> Field r'. \\<forall>y\\<in>Field r \\<times> Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} \\<or> (y, x) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_Linear_order: \"\\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Linear_order r; Linear_order r'\\<rbrakk> \\<Longrightarrow> Linear_order (r *o r')<\\STATESEP>unfolding linear_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r') \\<and> Total (r *o r')<\\STATESEP>using oprod_Partial_order oprod_Total<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Partial_order ?r; Partial_order ?r'\\<rbrakk> \\<Longrightarrow> Partial_order (?r *o ?r')\n\\<lbrakk>Total ?r; Total ?r'\\<rbrakk> \\<Longrightarrow> Total (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Partial_order r \\<and> Total r; Partial_order r' \\<and> Total r'\\<rbrakk> \\<Longrightarrow> Partial_order (r *o r') \\<and> Total (r *o r')<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_wf:\nassumes WF: \"wf r\" and WF': \"wf r'\"\nshows \"wf (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (r *o r')<\\STATESEP>unfolding wf_eq_minimal2<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field (r *o r') \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r')<\\STATESEP>unfolding Field_oprod<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<subseteq> Field r \\<times> Field r' \\<and> A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r')<\\STATESEP>proof(intro allI impI, elim conjE)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>fix A<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>assume *: \"A \\<subseteq> Field r \\<times> Field r'\" and **: \"A \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}<\\STATESEP>obtain y where y: \"y \\<in> snd ` A\" \"\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. \\<lbrakk>y \\<in> snd ` A; \\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using spec[OF WF'[unfolded wf_eq_minimal2], of \"snd ` A\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\nA \\<noteq> {}\nsnd ` A \\<subseteq> Field r' \\<and> snd ` A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>snd ` A. \\<forall>a'\\<in>snd ` A. (a', a) \\<notin> r')\n\ngoal (1 subgoal):\n 1. (\\<And>y. \\<lbrakk>y \\<in> snd ` A; \\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>let ?A = \"fst ` A \\<inter> {x. (x, y) \\<in> A}\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>from * y<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nA \\<subseteq> Field r \\<times> Field r'\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'<\\STATESEP>have \"?A \\<noteq> {}\" \"?A \\<subseteq> Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nA \\<subseteq> Field r \\<times> Field r'\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\n\ngoal (1 subgoal):\n 1. fst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {} &&& fst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r<\\STATESEP>obtain x where x: \"x \\<in> ?A\" and \"\\<forall>x'\\<in> ?A. (x', x) \\<notin> r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}; \\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using spec[OF WF[unfolded wf_eq_minimal2], of \"?A\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {}\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r\nfst ` A \\<inter> {x. (x, y) \\<in> A} \\<subseteq> Field r \\<and> fst ` A \\<inter> {x. (x, y) \\<in> A} \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. \\<forall>a'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}; \\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>with y<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r<\\STATESEP>have \"\\<forall>a'\\<in>A. (a', (x, y)) \\<notin> r *o r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'<\\STATESEP>unfolding oprod_def mem_Collect_eq split_beta fst_conv snd_conv Id_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ny \\<in> snd ` A\n\\<forall>y'\\<in>snd ` A. (y', y) \\<notin> r'\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\\<forall>x'\\<in>fst ` A \\<inter> {x. (x, y) \\<in> A}. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>A. \\<not> ((snd a', y) \\<in> r' - {p. \\<exists>x. p = (x, x)} \\<and> fst a' \\<in> Field r \\<and> x \\<in> Field r \\<or> (snd a', y) \\<in> Restr {p. \\<exists>x. p = (x, x)} (Field r') \\<and> (fst a', x) \\<in> r)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>from x<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}<\\STATESEP>have \"(x, y) \\<in> A\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> fst ` A \\<inter> {x. (x, y) \\<in> A}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> A<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> Field r \\<times> Field r'; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n(x, y) \\<in> A<\\STATESEP>show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a'\\<in>A. (a', x, y) \\<notin> r *o r'\n(x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a', a) \\<notin> r *o r'\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_minus_Id:\n  assumes r: \"Total r\" \"\\<not> (r \\<le> Id)\" and r': \"Total r'\" \"\\<not> (r' \\<le> Id)\"\n  shows \"(r *o r') - Id \\<le> (r - Id) *o (r' - Id)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)<\\STATESEP>unfolding oprod_def Total_Id_Field[OF r] Total_Id_Field[OF r']<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field (r - Id) \\<and> x2 \\<in> Field (r - Id) \\<or> (y1, y2) \\<in> Restr Id (Field (r' - Id)) \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id - Id \\<and> x1 \\<in> Field (r - Id) \\<and> x2 \\<in> Field (r - Id) \\<or> (y1, y2) \\<in> Restr Id (Field (r' - Id)) \\<and> (x1, x2) \\<in> r - Id}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_minus_Id1:\n  \"r \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x,y1), (x,y2)). x \\<in> Field r \\<and> (y1, y2) \\<in> (r' - Id)}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> r *o r' - Id \\<subseteq> {((x, y1), x, y2). x \\<in> Field r \\<and> (y1, y2) \\<in> r' - Id}<\\STATESEP>unfolding oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x, y1), x, y2). x \\<in> Field r \\<and> (y1, y2) \\<in> r' - Id}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma wf_extend_oprod1:\n  assumes \"wf r\"\n  shows \"wf {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>proof (unfold wf_eq_minimal2, intro allI impI, elim conjE)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>fix B<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>assume *: \"B \\<subseteq> Field {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\" and \"B \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>from image_mono[OF *, of snd]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nsnd ` B \\<subseteq> snd ` Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>have \"snd ` B \\<subseteq> Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nsnd ` B \\<subseteq> snd ` Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. snd ` B \\<subseteq> Field r<\\STATESEP>unfolding Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nsnd ` B \\<subseteq> snd ` (Domain {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r} \\<union> Range {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r})\n\ngoal (1 subgoal):\n 1. snd ` B \\<subseteq> Domain r \\<union> Range r<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nsnd ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>with \\<open>B \\<noteq> {}\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r<\\STATESEP>obtain x where x: \"x \\<in> snd ` B\" \"\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> snd ` B; \\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using spec[OF assms[unfolded wf_eq_minimal2], of \"snd ` B\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nsnd ` B \\<subseteq> Field r\nsnd ` B \\<subseteq> Field r \\<and> snd ` B \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>snd ` B. \\<forall>a'\\<in>snd ` B. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> snd ` B; \\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r<\\STATESEP>obtain a where \"(a, x) \\<in> B\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (\\<And>a. (a, x) \\<in> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(a, x) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(a, x) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>from * x<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r<\\STATESEP>have \"\\<forall>a'\\<in>B. (a', (a, x)) \\<notin> {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nB \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\nx \\<in> snd ` B\n\\<forall>x'\\<in>snd ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(a, x) \\<in> B\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>show \"\\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x,y1), (x,y2)) . x \\<in> A \\<and> (y1, y2) \\<in> r}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(a, x) \\<in> B\n\\<forall>a'\\<in>B. (a', a, x) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<exists>ax\\<in>B. \\<forall>a'\\<in>B. (a', ax) \\<notin> {((x, y1), x, y2). x \\<in> A \\<and> (y1, y2) \\<in> r}\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_minus_Id2:\n  \"r' \\<le> Id \\<Longrightarrow> r *o r' - Id \\<le> {((x1,y), (x2,y)). (x1, x2) \\<in> (r - Id) \\<and> y \\<in> Field r'}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> r *o r' - Id \\<subseteq> {((x1, y), x2, y). (x1, x2) \\<in> r - Id \\<and> y \\<in> Field r'}<\\STATESEP>unfolding oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r' \\<subseteq> Id \\<Longrightarrow> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r} - Id \\<subseteq> {((x1, y), x2, y). (x1, x2) \\<in> r - Id \\<and> y \\<in> Field r'}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma wf_extend_oprod2:\n  assumes \"wf r\"\n  shows \"wf {((x1,y), (x2,y)) . (x1, x2) \\<in> r \\<and> y \\<in> A}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>proof (unfold wf_eq_minimal2, intro allI impI, elim conjE)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>fix B<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>assume *: \"B \\<subseteq> Field {((x1, y), (x2, y)). (x1, x2) \\<in> r \\<and> y \\<in> A}\" and \"B \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>from image_mono[OF *, of fst]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfst ` B \\<subseteq> fst ` Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>have \"fst ` B \\<subseteq> Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfst ` B \\<subseteq> fst ` Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. fst ` B \\<subseteq> Field r<\\STATESEP>unfolding Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfst ` B \\<subseteq> fst ` (Domain {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A} \\<union> Range {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A})\n\ngoal (1 subgoal):\n 1. fst ` B \\<subseteq> Domain r \\<union> Range r<\\STATESEP>by force<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfst ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>with \\<open>B \\<noteq> {}\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r<\\STATESEP>obtain x where x: \"x \\<in> fst ` B\" \"\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` B; \\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using spec[OF assms[unfolded wf_eq_minimal2], of \"fst ` B\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nB \\<noteq> {}\nfst ` B \\<subseteq> Field r\nfst ` B \\<subseteq> Field r \\<and> fst ` B \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>fst ` B. \\<forall>a'\\<in>fst ` B. (a', a) \\<notin> r)\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> fst ` B; \\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r<\\STATESEP>obtain a where \"(x, a) \\<in> B\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (\\<And>a. (x, a) \\<in> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(x, a) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(x, a) \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>from * x<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r<\\STATESEP>have \"\\<forall>a'\\<in>B. (a', (x, a)) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nB \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\nx \\<in> fst ` B\n\\<forall>x'\\<in>fst ` B. (x', x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<And>Aa. \\<lbrakk>Aa \\<subseteq> Field {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}; Aa \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>Aa. \\<forall>a'\\<in>Aa. (a', a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(x, a) \\<in> B\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>show \"\\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(x, a) \\<in> B\n\\<forall>a'\\<in>B. (a', x, a) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<exists>xa\\<in>B. \\<forall>a'\\<in>B. (a', xa) \\<notin> {((x1, y), x2, y). (x1, x2) \\<in> r \\<and> y \\<in> A}\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_wf_Id:\n  assumes TOT: \"Total r\" and TOT': \"Total r'\" and WF: \"wf(r - Id)\" and WF': \"wf(r' - Id)\"\n  shows \"wf ((r *o r') - Id)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)<\\STATESEP>proof(cases \"r \\<le> Id \\<or> r' \\<le> Id\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r *o r' - Id)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (2 subgoals):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)\n 2. \\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id) \\<Longrightarrow> wf (r *o r' - Id)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)<\\STATESEP>using oprod_minus_Id[of r r'] assms oprod_wf[of \"r - Id\" \"r' - Id\"]\n    wf_subset[of \"(r - Id) *o (r' - Id)\" \"(r *o r') - Id\"]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (r \\<subseteq> Id \\<or> r' \\<subseteq> Id)\n\\<lbrakk>Total r; \\<not> r \\<subseteq> Id; Total r'; \\<not> r' \\<subseteq> Id\\<rbrakk> \\<Longrightarrow> r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)\nTotal r\nTotal r'\nwf (r - Id)\nwf (r' - Id)\n\\<lbrakk>wf (r - Id); wf (r' - Id)\\<rbrakk> \\<Longrightarrow> wf ((r - Id) *o (r' - Id))\n\\<lbrakk>wf ((r - Id) *o (r' - Id)); r *o r' - Id \\<subseteq> (r - Id) *o (r' - Id)\\<rbrakk> \\<Longrightarrow> wf (r *o r' - Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf (r *o r' - Id)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. r \\<subseteq> Id \\<or> r' \\<subseteq> Id \\<Longrightarrow> wf (r *o r' - Id)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)<\\STATESEP>using wf_subset[OF wf_extend_oprod1[OF WF'] oprod_minus_Id1]\n                     wf_subset[OF wf_extend_oprod2[OF WF] oprod_minus_Id2]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr \\<subseteq> Id \\<or> r' \\<subseteq> Id\n?r3 \\<subseteq> Id \\<Longrightarrow> wf (?r3 *o r' - Id)\n?r'3 \\<subseteq> Id \\<Longrightarrow> wf (r *o ?r'3 - Id)\n\ngoal (1 subgoal):\n 1. wf (r *o r' - Id)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf (r *o r' - Id)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_Well_order:\nassumes WELL: \"Well_order r\" and WELL': \"Well_order r'\"\nshows \"Well_order (r *o r')\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>proof-<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>have \"Total r \\<and> Total r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'<\\STATESEP>using WELL WELL'<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Total r \\<and> Total r'<\\STATESEP>by (auto simp add: order_on_defs)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nWell_order r\nWell_order r'\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>unfolding well_order_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r *o r') \\<and> wf (r *o r' - Id)<\\STATESEP>using oprod_Linear_order oprod_wf_Id<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nTotal r \\<and> Total r'\nLinear_order r \\<and> wf (r - Id)\nLinear_order r' \\<and> wf (r' - Id)\n\\<lbrakk>Linear_order ?r; Linear_order ?r'\\<rbrakk> \\<Longrightarrow> Linear_order (?r *o ?r')\n\\<lbrakk>Total ?r; Total ?r'; wf (?r - Id); wf (?r' - Id)\\<rbrakk> \\<Longrightarrow> wf (?r *o ?r' - Id)\n\ngoal (1 subgoal):\n 1. Linear_order (r *o r') \\<and> wf (r *o r' - Id)<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order (r *o r')\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_embed:\n  assumes WELL: \"Well_order r\" and WELL': \"Well_order r'\" and \"r' \\<noteq> {}\"\n  shows \"embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\" (is \"embed _ _ ?f\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>from assms(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr' \\<noteq> {}<\\STATESEP>have r': \"Field r' \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r' \\<noteq> {}<\\STATESEP>unfolding Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r' \\<union> Range r' \\<noteq> {}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>have minim[simp]: \"minim r' (Field r') \\<in> Field r'\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. minim r' (Field r') \\<in> Field r'<\\STATESEP>using wo_rel.minim_inField[unfolded wo_rel_def, OF WELL' _ r']<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r' \\<subseteq> Field r' \\<Longrightarrow> minim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. minim r' (Field r') \\<in> Field r'<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nminim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nminim r' (Field r') \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>fix b<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>assume b: \"(b, minim r' (Field r')) \\<in> r'\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(b, minim r' (Field r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>hence \"b \\<in> Field r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(b, minim r' (Field r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. b \\<in> Field r'<\\STATESEP>unfolding Field_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(b, minim r' (Domain r' \\<union> Range r')) \\<in> r'\n\ngoal (1 subgoal):\n 1. b \\<in> Domain r' \\<union> Range r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nb \\<in> Field r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>hence \"(minim r' (Field r'), b) \\<in> r'\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> Field r'\n\ngoal (1 subgoal):\n 1. (minim r' (Field r'), b) \\<in> r'<\\STATESEP>using wo_rel.minim_least[unfolded wo_rel_def, OF WELL' subset_refl] r'<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nb \\<in> Field r'\n?b \\<in> Field r' \\<Longrightarrow> (minim r' (Field r'), ?b) \\<in> r'\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (minim r' (Field r'), b) \\<in> r'<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(minim r' (Field r'), b) \\<in> r'\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>with b<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(b, minim r' (Field r')) \\<in> r'\n(minim r' (Field r'), b) \\<in> r'<\\STATESEP>have \"b = minim r' (Field r')\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(b, minim r' (Field r')) \\<in> r'\n(minim r' (Field r'), b) \\<in> r'\n\ngoal (1 subgoal):\n 1. b = minim r' (Field r')<\\STATESEP>by (metis WELL' antisym_def linear_order_on_def partial_order_on_def well_order_on_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nb = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>note * = this<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>have 1: \"Well_order (r *o r')\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\nWell_order r'\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Well_order (r *o r')<\\STATESEP>by (auto simp add: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order (r *o r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nWell_order (r *o r')\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>from r'<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nField r' \\<noteq> {}<\\STATESEP>have \"compat r (r *o r') ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. compat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>unfolding compat_def oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> ((a, minim r' (Field r')), b, minim r' (Field r')) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>from *<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')<\\STATESEP>have \"ofilter (r *o r') (?f ` Field r)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. ofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)<\\STATESEP>unfolding wo_rel.ofilter_def[unfolded wo_rel_def, OF 1] Field_oprod under_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (x, minim r' (Field r'))) ` Field r \\<subseteq> Field r \\<times> Field r' \\<and> (\\<forall>a\\<in>(\\<lambda>x. (x, minim r' (Field r'))) ` Field r. {b. (b, a) \\<in> r *o r'} \\<subseteq> (\\<lambda>x. (x, minim r' (Field r'))) ` Field r)<\\STATESEP>unfolding oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(?b2, minim r' (Field r')) \\<in> r' \\<Longrightarrow> ?b2 = minim r' (Field r')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (x, minim r' (Field r'))) ` Field r \\<subseteq> Field r \\<times> Field r' \\<and> (\\<forall>a\\<in>(\\<lambda>x. (x, minim r' (Field r'))) ` Field r. {b. (b, a) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r' - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field r') \\<and> (x1, x2) \\<in> r}} \\<subseteq> (\\<lambda>x. (x, minim r' (Field r'))) ` Field r)<\\STATESEP>by auto (auto simp: image_iff Field_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>have \"inj_on ?f (Field r)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)<\\STATESEP>unfolding inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. (x, minim r' (Field r')) = (y, minim r' (Field r')) \\<longrightarrow> x = y<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>using assms<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order (r *o r')\ncompat r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\nofilter (r *o r') ((\\<lambda>x. (x, minim r' (Field r'))) ` Field r)\ninj_on (\\<lambda>x. (x, minim r' (Field r'))) (Field r)\nWell_order r\nWell_order r'\nr' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. embed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))<\\STATESEP>by (auto simp add: embed_iff_compat_inj_on_ofilter)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembed r (r *o r') (\\<lambda>x. (x, minim r' (Field r')))\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>corollary oprod_ordLeq: \"\\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'<\\STATESEP>using oprod_embed oprod_Well_order<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Well_order ?r; Well_order ?r'; ?r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> embed ?r (?r *o ?r') (\\<lambda>x. (x, minim ?r' (Field ?r')))\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> r \\<le>o r *o r'<\\STATESEP>unfolding ordLeq_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Well_order ?r; Well_order ?r'; ?r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> embed ?r (?r *o ?r') (\\<lambda>x. (x, minim ?r' (Field ?r')))\n\\<lbrakk>Well_order ?r; Well_order ?r'\\<rbrakk> \\<Longrightarrow> Well_order (?r *o ?r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order r'; r' \\<noteq> {}\\<rbrakk> \\<Longrightarrow> (r, r *o r') \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition \"support z A f = {x \\<in> A. f x \\<noteq> z}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma support_Un[simp]: \"support z (A \\<union> B) f = support z A f \\<union> support z B f\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. support z (A \\<union> B) f = support z A f \\<union> support z B f<\\STATESEP>unfolding support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> A \\<union> B. f x \\<noteq> z} = {x \\<in> A. f x \\<noteq> z} \\<union> {x \\<in> B. f x \\<noteq> z}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma support_upd[simp]: \"support z A (f(x := z)) = support z A f - {x}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. support z A (f(x := z)) = support z A f - {x}<\\STATESEP>unfolding support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A. (f(x := z)) xa \\<noteq> z} = {x \\<in> A. f x \\<noteq> z} - {x}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma support_upd_subset[simp]: \"support z A (f(x := y)) \\<subseteq> support z A f \\<union> {x}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. support z A (f(x := y)) \\<subseteq> support z A f \\<union> {x}<\\STATESEP>unfolding support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A. (f(x := y)) xa \\<noteq> z} \\<subseteq> {x \\<in> A. f x \\<noteq> z} \\<union> {x}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fun_unequal_in_support:\n  assumes \"f \\<noteq> g\" \"f \\<in> Func A B\" \"g \\<in> Func A C\"\n  shows \"(support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\" (is \"?L \\<inter> ?R \\<noteq> {}\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf \\<noteq> g<\\STATESEP>obtain x where x: \"f x \\<noteq> g x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<noteq> g\n\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<noteq> g x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>hence \"x \\<in> ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> {a. f a \\<noteq> g a}<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> {a. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nx \\<in> {a. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>from assms(2-3) x<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> Func A B\ng \\<in> Func A C\nf x \\<noteq> g x<\\STATESEP>have \"x \\<in> A\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> Func A B\ng \\<in> Func A C\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> A<\\STATESEP>unfolding Func_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}\ng \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> C) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}\nf x \\<noteq> g x\n\ngoal (1 subgoal):\n 1. x \\<in> A<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> A\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>with x<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf x \\<noteq> g x\nx \\<in> A<\\STATESEP>have \"x \\<in> ?L\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf x \\<noteq> g x\nx \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> support z A f \\<union> support z A g<\\STATESEP>unfolding support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x \\<noteq> g x\nx \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> A. f x \\<noteq> z} \\<union> {x \\<in> A. g x \\<noteq> z}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> support z A f \\<union> support z A g\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> {a. f a \\<noteq> g a}\nx \\<in> support z A f \\<union> support z A g<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> {a. f a \\<noteq> g a}\nx \\<in> support z A f \\<union> support z A g\n\ngoal (1 subgoal):\n 1. (support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(support z A f \\<union> support z A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition fin_support where\n  \"fin_support z A = {f. finite (support z A f)}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma finite_support: \"f \\<in> fin_support z A \\<Longrightarrow> finite (support z A f)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> fin_support z A \\<Longrightarrow> finite (support z A f)<\\STATESEP>unfolding support_def fin_support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. finite {x \\<in> A. f x \\<noteq> z}} \\<Longrightarrow> finite {x \\<in> A. f x \\<noteq> z}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fin_support_Field_osum:\n  \"f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<longleftrightarrow>\n  (f o Inl) \\<in> fin_support z A \\<and> (f o Inr) \\<in> fin_support z B\" (is \"?L \\<longleftrightarrow> ?R1 \\<and> ?R2\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)) = (f \\<circ> Inl \\<in> fin_support z A \\<and> f \\<circ> Inr \\<in> fin_support z B)<\\STATESEP>proof safe<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inl \\<in> fin_support z A\n 2. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 3. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>assume ?L<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (3 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inl \\<in> fin_support z A\n 2. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 3. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>from \\<open>?L\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>show ?R1<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (1 subgoal):\n 1. f \\<circ> Inl \\<in> fin_support z A<\\STATESEP>unfolding fin_support_def support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> {f. finite {x \\<in> Inl ` A \\<union> Inr ` B. f x \\<noteq> z}}\n\ngoal (1 subgoal):\n 1. f \\<circ> Inl \\<in> {f. finite {x \\<in> A. f x \\<noteq> z}}<\\STATESEP>by (fastforce simp: image_iff elim: finite_surj[of _ _ \"case_sum id undefined\"])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf \\<circ> Inl \\<in> fin_support z A\n\ngoal (2 subgoals):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B) \\<Longrightarrow> f \\<circ> Inr \\<in> fin_support z B\n 2. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>from \\<open>?L\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>show ?R2<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal (1 subgoal):\n 1. f \\<circ> Inr \\<in> fin_support z B<\\STATESEP>unfolding fin_support_def support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> {f. finite {x \\<in> Inl ` A \\<union> Inr ` B. f x \\<noteq> z}}\n\ngoal (1 subgoal):\n 1. f \\<circ> Inr \\<in> {f. finite {x \\<in> B. f x \\<noteq> z}}<\\STATESEP>by (fastforce simp: image_iff elim: finite_surj[of _ _ \"case_sum undefined id\"])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>assume ?R1 ?R2<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf \\<circ> Inl \\<in> fin_support z A\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<circ> Inl \\<in> fin_support z A; f \\<circ> Inr \\<in> fin_support z B\\<rbrakk> \\<Longrightarrow> f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>thus ?L<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<circ> Inl \\<in> fin_support z A\nf \\<circ> Inr \\<in> fin_support z B\n\ngoal (1 subgoal):\n 1. f \\<in> fin_support z (Inl ` A \\<union> Inr ` B)<\\STATESEP>unfolding fin_support_def support_Un<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<circ> Inl \\<in> {f. finite (support z A f)}\nf \\<circ> Inr \\<in> {f. finite (support z B f)}\n\ngoal (1 subgoal):\n 1. f \\<in> {f. finite (support z (Inl ` A) f \\<union> support z (Inr ` B) f)}<\\STATESEP>by (auto simp: support_def elim: finite_surj[of _ _ Inl] finite_surj[of _ _ Inr])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf \\<in> fin_support z (Inl ` A \\<union> Inr ` B)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma Func_upd: \"\\<lbrakk>f \\<in> Func A B; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> Func A B\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> Func A B; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> Func A B<\\STATESEP>unfolding Func_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}; x \\<in> A; y \\<in> B\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> {f. (\\<forall>a\\<in>A. f a \\<in> B) \\<and> (\\<forall>a. a \\<notin> A \\<longrightarrow> f a = undefined)}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>context wo_rel\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition isMaxim :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"isMaxim A b \\<equiv> b \\<in> A \\<and> (\\<forall>a \\<in> A. (a,b) \\<in> r)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition maxim :: \"'a set \\<Rightarrow> 'a\"\nwhere \"maxim A \\<equiv> THE b. isMaxim A b\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma isMaxim_unique[intro]: \"\\<lbrakk>isMaxim A x; isMaxim A y\\<rbrakk> \\<Longrightarrow> x = y\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxim A x; isMaxim A y\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>unfolding isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<and> (\\<forall>a\\<in>A. (a, x) \\<in> r); y \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>using antisymD[OF ANTISYM, of x y]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<and> (\\<forall>a\\<in>A. (a, x) \\<in> r); y \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\\<rbrakk> \\<Longrightarrow> x = y<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_isMaxim: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (maxim A)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (maxim A)<\\STATESEP>unfolding maxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim A (THE b. isMaxim A b)<\\STATESEP>proof (rule theI', rule ex_ex1I[OF _ isMaxim_unique, rotated], assumption+,\n  induct A rule: finite_induct)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; \\<lbrakk>F \\<noteq> {}; F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim F); insert x F \\<noteq> {}; insert x F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim (insert x F))<\\STATESEP>case (insert x A)<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfinite A\nx \\<notin> A\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<noteq> {}\ninsert x A \\<subseteq> Field r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})\n 2. \\<And>x F. \\<lbrakk>finite F; x \\<notin> F; \\<lbrakk>F \\<noteq> {}; F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim F); insert x F \\<noteq> {}; insert x F \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim (insert x F))<\\STATESEP>thus ?case<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nx \\<notin> A\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<noteq> {}\ninsert x A \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a<\\STATESEP>proof (cases \"A = {}\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nA = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nA = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>have \"isMaxim {x} x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. isMaxim {x} x<\\STATESEP>unfolding isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x} \\<and> (\\<forall>a\\<in>{x}. (a, x) \\<in> r)<\\STATESEP>using refl_onD[OF REFL] insert(5)<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\ninsert x A \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. x \\<in> {x} \\<and> (\\<forall>a\\<in>{x}. (a, x) \\<in> r)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim {x} x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A = {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a\n 2. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nA = {}\nisMaxim {x} x<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nA = {}\nisMaxim {x} x\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>with insert(3,5)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<subseteq> Field r\nA \\<noteq> {}<\\STATESEP>obtain y where \"isMaxim A y\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a\ninsert x A \\<subseteq> Field r\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. isMaxim A y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim A y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>with insert(2,5)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx \\<notin> A\ninsert x A \\<subseteq> Field r\nisMaxim A y<\\STATESEP>have \"if (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx \\<notin> A\ninsert x A \\<subseteq> Field r\nisMaxim A y\n\ngoal (1 subgoal):\n 1. if (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y<\\STATESEP>unfolding isMaxim_def subset_eq<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx \\<notin> A\n\\<forall>x\\<in>insert x A. x \\<in> Field r\ny \\<in> A \\<and> (\\<forall>a\\<in>A. (a, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. if (y, x) \\<in> r then x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r) else y \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, y) \\<in> r)<\\STATESEP>by (metis insert_iff max2_def max2_equals1 max2_iff)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nif (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<notin> A; \\<lbrakk>A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim A a; insert x A \\<noteq> {}; insert x A \\<subseteq> Field r; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a. isMaxim (insert x A) a<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nif (y, x) \\<in> r then isMaxim (insert x A) x else isMaxim (insert x A) y\n\ngoal (1 subgoal):\n 1. \\<exists>a. isMaxim (insert x A) a<\\STATESEP>by metis<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<exists>a. isMaxim (insert x A) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<noteq> {}; {} \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> Ex (isMaxim {})<\\STATESEP>qed simp<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma maxim_in: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A<\\STATESEP>using maxim_isMaxim<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A<\\STATESEP>unfolding isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim ?A \\<in> ?A \\<and> (\\<forall>a\\<in>?A. (a, maxim ?A) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim A \\<in> A<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_greatest: \"\\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r<\\STATESEP>using maxim_isMaxim<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r<\\STATESEP>unfolding isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim ?A \\<in> ?A \\<and> (\\<forall>a\\<in>?A. (a, maxim ?A) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<in> A; A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (x, maxim A) \\<in> r<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma isMaxim_zero: \"isMaxim A zero \\<Longrightarrow> A = {zero}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A local.zero \\<Longrightarrow> A = {local.zero}<\\STATESEP>unfolding isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. local.zero \\<in> A \\<and> (\\<forall>a\\<in>A. (a, local.zero) \\<in> r) \\<Longrightarrow> A = {local.zero}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_insert:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"x \\<in> Field r\"\n  shows \"maxim (insert x A) = max2 x (maxim A)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r<\\STATESEP>have *: \"isMaxim (insert x A) (maxim (insert x A))\" \"isMaxim A (maxim A)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim (insert x A)) &&& isMaxim A (maxim A)<\\STATESEP>using maxim_isMaxim<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nx \\<in> Field r\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim (insert x A)) &&& isMaxim A (maxim A)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nisMaxim (insert x A) (maxim (insert x A))\nisMaxim A (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>proof (cases \"(x, maxim A) \\<in> r\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(x, maxim A) \\<in> r\n\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>with *(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim A (maxim A)\n(x, maxim A) \\<in> r<\\STATESEP>have \"isMaxim (insert x A) (maxim A)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim A (maxim A)\n(x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) (maxim A)<\\STATESEP>unfolding isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\n(x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, maxim A) \\<in> r)<\\STATESEP>using transD[OF TRANS, of _ x \"maxim A\"]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\n(x, maxim A) \\<in> r\n\\<lbrakk>(?x, x) \\<in> r; (x, maxim A) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, maxim A) \\<in> r)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim (insert x A) (maxim A)\n\ngoal (2 subgoals):\n 1. (x, maxim A) \\<in> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)\n 2. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>with *(1) True<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>unfolding max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<in> r\nisMaxim (insert x A) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = (if (x, maxim A) \\<in> r then maxim A else x)<\\STATESEP>by (metis isMaxim_unique)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(x, maxim A) \\<notin> r\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>hence \"(maxim A, x) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(x, maxim A) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim A, x) \\<in> r<\\STATESEP>by (metis *(2) assms(3,4) in_mono in_notinI isMaxim_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>with *(2) assms(4)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim A (maxim A)\nx \\<in> Field r\n(maxim A, x) \\<in> r<\\STATESEP>have \"isMaxim (insert x A) x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim A (maxim A)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (insert x A) x<\\STATESEP>unfolding isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r)<\\STATESEP>using transD[OF TRANS, of _ \"maxim A\" x] refl_onD[OF REFL, of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nx \\<in> Field r\n(maxim A, x) \\<in> r\n\\<lbrakk>(?x, maxim A) \\<in> r; (maxim A, x) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, x) \\<in> r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> insert x A \\<and> (\\<forall>a\\<in>insert x A. (a, x) \\<in> r)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. (x, maxim A) \\<notin> r \\<Longrightarrow> maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>with *(1) False<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = local.max2 x (maxim A)<\\STATESEP>unfolding max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (insert x A) (maxim (insert x A))\n(x, maxim A) \\<notin> r\nisMaxim (insert x A) x\n\ngoal (1 subgoal):\n 1. maxim (insert x A) = (if (x, maxim A) \\<in> r then maxim A else x)<\\STATESEP>by (metis isMaxim_unique)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmaxim (insert x A) = local.max2 x (maxim A)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma maxim_Un:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\" \"finite B\" \"B \\<noteq> {}\" \"B \\<subseteq> Field r\"\n  shows   \"maxim (A \\<union> B) = max2 (maxim A) (maxim B)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r<\\STATESEP>have *: \"isMaxim (A \\<union> B) (maxim (A \\<union> B))\" \"isMaxim A (maxim A)\" \"isMaxim B (maxim B)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim (A \\<union> B)) &&& isMaxim A (maxim A) &&& isMaxim B (maxim B)<\\STATESEP>using maxim_isMaxim<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nfinite B\nB \\<noteq> {}\nB \\<subseteq> Field r\n\\<lbrakk>finite ?A; ?A \\<noteq> {}; ?A \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> isMaxim ?A (maxim ?A)\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim (A \\<union> B)) &&& isMaxim A (maxim A) &&& isMaxim B (maxim B)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>proof (cases \"(maxim A, maxim B) \\<in> r\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(maxim A, maxim B) \\<in> r\n\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>with *(2,3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim A, maxim B) \\<in> r<\\STATESEP>have \"isMaxim (A \\<union> B) (maxim B)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim A, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim B)<\\STATESEP>unfolding isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim A, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim B \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim B) \\<in> r)<\\STATESEP>using transD[OF TRANS, of _ \"maxim A\" \"maxim B\"]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim A, maxim B) \\<in> r\n\\<lbrakk>(?x, maxim A) \\<in> r; (maxim A, maxim B) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim B) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim B \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim B) \\<in> r)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (2 subgoals):\n 1. (maxim A, maxim B) \\<in> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n 2. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>with *(1) True<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>unfolding max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<in> r\nisMaxim (A \\<union> B) (maxim B)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = (if (maxim A, maxim B) \\<in> r then maxim B else maxim A)<\\STATESEP>by (metis isMaxim_unique)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(maxim A, maxim B) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>hence \"(maxim B, maxim A) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(maxim A, maxim B) \\<notin> r\n\ngoal (1 subgoal):\n 1. (maxim B, maxim A) \\<in> r<\\STATESEP>by (metis *(2,3) assms(3,6) in_mono in_notinI isMaxim_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>with *(2,3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim B, maxim A) \\<in> r<\\STATESEP>have \"isMaxim (A \\<union> B) (maxim A)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim A (maxim A)\nisMaxim B (maxim B)\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. isMaxim (A \\<union> B) (maxim A)<\\STATESEP>unfolding isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim B, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim A) \\<in> r)<\\STATESEP>using transD[OF TRANS, of _ \"maxim B\" \"maxim A\"]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nmaxim A \\<in> A \\<and> (\\<forall>a\\<in>A. (a, maxim A) \\<in> r)\nmaxim B \\<in> B \\<and> (\\<forall>a\\<in>B. (a, maxim B) \\<in> r)\n(maxim B, maxim A) \\<in> r\n\\<lbrakk>(?x, maxim B) \\<in> r; (maxim B, maxim A) \\<in> r\\<rbrakk> \\<Longrightarrow> (?x, maxim A) \\<in> r\n\ngoal (1 subgoal):\n 1. maxim A \\<in> A \\<union> B \\<and> (\\<forall>a\\<in>A \\<union> B. (a, maxim A) \\<in> r)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. (maxim A, maxim B) \\<notin> r \\<Longrightarrow> maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>with *(1) False<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = local.max2 (maxim A) (maxim B)<\\STATESEP>unfolding max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nisMaxim (A \\<union> B) (maxim (A \\<union> B))\n(maxim A, maxim B) \\<notin> r\nisMaxim (A \\<union> B) (maxim A)\n\ngoal (1 subgoal):\n 1. maxim (A \\<union> B) = (if (maxim A, maxim B) \\<in> r then maxim B else maxim A)<\\STATESEP>by (metis isMaxim_unique)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nmaxim (A \\<union> B) = local.max2 (maxim A) (maxim B)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma maxim_insert_zero:\n  assumes \"finite A\" \"A \\<noteq> {}\" \"A \\<subseteq> Field r\"\n  shows \"maxim (insert zero A) = maxim A\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim (insert local.zero A) = maxim A<\\STATESEP>using assms zero_in_Field maxim_in[OF assms]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nfinite A\nA \\<noteq> {}\nA \\<subseteq> Field r\nField r \\<noteq> {} \\<Longrightarrow> local.zero \\<in> Field r\nmaxim A \\<in> A\n\ngoal (1 subgoal):\n 1. maxim (insert local.zero A) = maxim A<\\STATESEP>by (subst maxim_insert[unfolded max2_def]) auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_equality: \"isMaxim A x \\<Longrightarrow> maxim A = x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A x \\<Longrightarrow> maxim A = x<\\STATESEP>unfolding maxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. isMaxim A x \\<Longrightarrow> (THE b. isMaxim A b) = x<\\STATESEP>by (rule the_equality) auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_singleton:\n  \"x \\<in> Field r \\<Longrightarrow> maxim {x} = x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> maxim {x} = x<\\STATESEP>using refl_onD[OF REFL]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> maxim {x} = x<\\STATESEP>by (intro maxim_equality) (simp add: isMaxim_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_Int: \"\\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r; maxim A \\<in> B\\<rbrakk> \\<Longrightarrow> maxim (A \\<inter> B) = maxim A\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; A \\<subseteq> Field r; maxim A \\<in> B\\<rbrakk> \\<Longrightarrow> maxim (A \\<inter> B) = maxim A<\\STATESEP>by (rule maxim_equality) (auto simp: isMaxim_def intro: maxim_in maxim_greatest)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma maxim_mono: \"\\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r<\\STATESEP>using maxim_in[OF finite_subset, of X Y]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; X \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> maxim X \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq> Y; finite Y; X \\<noteq> {}; Y \\<subseteq> Field r\\<rbrakk> \\<Longrightarrow> (maxim X, maxim Y) \\<in> r<\\STATESEP>by (auto intro: maxim_greatest)<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition \"max_fun_diff f g \\<equiv> maxim ({a \\<in> Field r. f a \\<noteq> g a})\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma max_fun_diff_commute: \"max_fun_diff f g = max_fun_diff g f\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. max_fun_diff f g = max_fun_diff g f<\\STATESEP>unfolding max_fun_diff_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. maxim {a \\<in> Field r. f a \\<noteq> g a} = maxim {a \\<in> Field r. g a \\<noteq> f a}<\\STATESEP>by metis<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma zero_under: \"x \\<in> Field r \\<Longrightarrow> zero \\<in> under x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> local.zero \\<in> local.under x<\\STATESEP>unfolding under_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r \\<Longrightarrow> local.zero \\<in> {b. (b, x) \\<in> r}<\\STATESEP>by (auto intro: zero_smallest)<\\STATESEP>1<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition \"FinFunc r s = Func (Field s) (Field r) \\<inter> fin_support (zero r) (Field s)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma FinFuncD: \"\\<lbrakk>f \\<in> FinFunc r s; x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FinFunc r s; x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r<\\STATESEP>unfolding FinFunc_def Func_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s); x \\<in> Field s\\<rbrakk> \\<Longrightarrow> f x \\<in> Field r<\\STATESEP>by (fastforce split: option.splits)<\\STATESEP>1<\\TRANSEP><\\STATESEP>locale wo_rel2 =\n  fixes r s\n  assumes rWELL: \"Well_order r\"\n  and     sWELL: \"Well_order s\"\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>interpretation r: wo_rel r<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r<\\STATESEP>by unfold_locales (rule rWELL)<\\STATESEP>1<\\TRANSEP><\\STATESEP>interpretation s: wo_rel s<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule sWELL)<\\STATESEP>1<\\TRANSEP><\\STATESEP>abbreviation \"SUPP \\<equiv> support r.zero (Field s)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>abbreviation \"FINFUNC \\<equiv> FinFunc r s\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemmas FINFUNCD = FinFuncD[of _ r s]<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma fun_diff_alt: \"{a \\<in> Field s. f a \\<noteq> g a} = (SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {a \\<in> Field s. f a \\<noteq> g a} = (SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}<\\STATESEP>by (auto simp: support_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_alt:\n  \"s.max_fun_diff f g = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f g = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})<\\STATESEP>unfolding s.max_fun_diff_def fun_diff_alt<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}) = s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a})<\\STATESEP>..<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma isMaxim_max_fun_diff: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)<\\STATESEP>using fun_unequal_in_support[of f g]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> Func ?A ?B; g \\<in> Func ?A ?C\\<rbrakk> \\<Longrightarrow> (support ?z ?A f \\<union> support ?z ?A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)<\\STATESEP>unfolding max_fun_diff_alt fun_diff_alt fun_eq_iff<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>\\<not> (\\<forall>x. f x = g x); f \\<in> Func ?A ?B; g \\<in> Func ?A ?C\\<rbrakk> \\<Longrightarrow> (support ?z ?A f \\<union> support ?z ?A g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>x. f x = g x); f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}) (s.maxim ((SUPP f \\<union> SUPP g) \\<inter> {a. f a \\<noteq> g a}))<\\STATESEP>by (intro s.maxim_isMaxim) (auto simp: FinFunc_def fin_support_def support_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_in: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}<\\STATESEP>using isMaxim_max_fun_diff<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. ?f a \\<noteq> ?g a} (s.max_fun_diff ?f ?g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}<\\STATESEP>unfolding s.isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. ?f a \\<noteq> ?g a}. (a, s.max_fun_diff ?f ?g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_max: \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow>\n  (x, s.max_fun_diff f g) \\<in> s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>using isMaxim_max_fun_diff<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. ?f a \\<noteq> ?g a} (s.max_fun_diff ?f ?g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>unfolding s.isMaxim_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. ?f a \\<noteq> ?g a}. (a, s.max_fun_diff ?f ?g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff:\n  \"\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow>\n  (\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and>\n     f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b<\\STATESEP>using isMaxim_max_fun_diff[of f g]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b<\\STATESEP>unfolding s.isMaxim_def FinFunc_def Func_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s); g \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g; f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s); g \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> f (s.max_fun_diff f g) = a \\<and> g (s.max_fun_diff f g) = b<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_le_eq:\n  \"\\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow>\n  f x = g x\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> f x = g x<\\STATESEP>using max_fun_diff_max[of f g x] antisymD[OF s.ANTISYM, of \"s.max_fun_diff f g\" x]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<in> {a \\<in> Field s. f a \\<noteq> g a}\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; (x, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f g = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s.max_fun_diff f g, x) \\<in> s; f \\<noteq> g; f \\<in> FINFUNC; g \\<in> FINFUNC; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> f x = g x<\\STATESEP>by (auto simp: Field_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_max2:\n  assumes ineq: \"s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow>\n    f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\" and\n    fg: \"f \\<noteq> g\" and gh: \"g \\<noteq> h\" and fh: \"f \\<noteq> h\" and\n    f: \"f \\<in> FINFUNC\" and g: \"g \\<in> FINFUNC\" and h: \"h \\<in> FINFUNC\"\n  shows \"s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\"\n    (is \"?fh = s.max2 ?fg ?gh\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>proof (cases \"?fg = ?gh\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f g = s.max_fun_diff g h\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>with ineq<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\ns.max_fun_diff f g = s.max_fun_diff g h<\\STATESEP>have \"f ?fg \\<noteq> h ?fg\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\ns.max_fun_diff f g = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>assume x: \"x \\<in> {a \\<in> Field s. f a \\<noteq> h a}\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"(x, ?fg) \\<in> s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>proof (cases \"x = ?fg\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n 2. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nx \\<noteq> s.max_fun_diff f g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s\n 2. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x \\<noteq> s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>proof (rule ccontr)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>assume \"(x, ?fg) \\<notin> s\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<notin> s\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>with max_fun_diff_in[OF fg f g] x False<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\nx \\<noteq> s.max_fun_diff f g\n(x, s.max_fun_diff f g) \\<notin> s<\\STATESEP>have *: \"(?fg, x) \\<in> s\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\nx \\<noteq> s.max_fun_diff f g\n(x, s.max_fun_diff f g) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, x) \\<in> s<\\STATESEP>by (blast intro: s.in_notinI)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>hence \"f x = g x\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. f x = g x<\\STATESEP>by (rule max_fun_diff_le_eq[OF _ fg f g False])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nf x = g x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nf x = g x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>have \"g x = h x\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g x = h x<\\STATESEP>using max_fun_diff_le_eq[OF _ gh g h] False True *<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>(s.max_fun_diff g h, ?x) \\<in> s; ?x \\<noteq> s.max_fun_diff g h\\<rbrakk> \\<Longrightarrow> g ?x = h ?x\nx \\<noteq> s.max_fun_diff f g\ns.max_fun_diff f g = s.max_fun_diff g h\n(s.max_fun_diff f g, x) \\<in> s\n\ngoal (1 subgoal):\n 1. g x = h x<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ng x = h x\n\ngoal (1 subgoal):\n 1. (x, s.max_fun_diff f g) \\<notin> s \\<Longrightarrow> False<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nf x = g x\ng x = h x<\\STATESEP>show False<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\ng x = h x\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>using x<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\ng x = h x\nx \\<in> {a \\<in> Field s. f a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by simp<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {a \\<in> Field s. f a \\<noteq> h a}; x = s.max_fun_diff f g\\<rbrakk> \\<Longrightarrow> (x, s.max_fun_diff f g) \\<in> s<\\STATESEP>qed (simp add: refl_onD[OF s.REFL])<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(x, s.max_fun_diff f g) \\<in> s\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s<\\STATESEP>have \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?fg\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)<\\STATESEP>unfolding s.isMaxim_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)<\\STATESEP>using max_fun_diff_in[OF fg f g]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff f g)\n?x3 \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<Longrightarrow> (?x3, s.max_fun_diff f g) \\<in> s\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"?fh = ?fg\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g<\\STATESEP>using isMaxim_max_fun_diff[OF fh f h]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>unfolding True s.max2_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff g h, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff g h)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f g \\<noteq> s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>note * = this<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f g \\<noteq> s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<noteq> s.max_fun_diff g h \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>proof (cases \"(?fg, ?gh) \\<in> s\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence *: \"f ?gh = g ?gh\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. f (s.max_fun_diff g h) = g (s.max_fun_diff g h)<\\STATESEP>by (rule max_fun_diff_le_eq[OF _ fg f g *[symmetric]])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?gh\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)<\\STATESEP>using isMaxim_max_fun_diff[OF gh g h]\n      isMaxim_max_fun_diff[OF fg f g] transD[OF s.TRANS _ True]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. g a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n(?x, s.max_fun_diff f g) \\<in> s \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)<\\STATESEP>unfolding s.isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff g h) = g (s.max_fun_diff g h)\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. g a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n(?x, s.max_fun_diff f g) \\<in> s \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff g h \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"?fh = ?gh\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff g h<\\STATESEP>using isMaxim_max_fun_diff[OF fh f h]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff g h<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (2 subgoals):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n 2. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>using True<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>unfolding s.max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff g h\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>with max_fun_diff_in[OF fg f g] max_fun_diff_in[OF gh g h]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s<\\STATESEP>have True: \"(?gh, ?fg) \\<in> s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a}\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s<\\STATESEP>by (blast intro: s.in_notinI)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence *: \"g ?fg = h ?fg\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. g (s.max_fun_diff f g) = h (s.max_fun_diff f g)<\\STATESEP>by (rule max_fun_diff_le_eq[OF _ gh g h *])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} ?fg\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)<\\STATESEP>using isMaxim_max_fun_diff[OF gh g h]\n      isMaxim_max_fun_diff[OF fg f g] True transD[OF s.TRANS, of _ _ ?fg]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. g a \\<noteq> h a} (s.max_fun_diff g h)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> g a} (s.max_fun_diff f g)\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)<\\STATESEP>unfolding s.isMaxim_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng (s.max_fun_diff f g) = h (s.max_fun_diff f g)\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. g a \\<noteq> h a}. (a, s.max_fun_diff g h) \\<in> s)\ns.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> g a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> g a}. (a, s.max_fun_diff f g) \\<in> s)\n(s.max_fun_diff g h, s.max_fun_diff f g) \\<in> s\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, s.max_fun_diff f g) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, s.max_fun_diff f g) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f g \\<in> {a \\<in> Field s. f a \\<noteq> h a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f a \\<noteq> h a}. (a, s.max_fun_diff f g) \\<in> s)<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>hence \"?fh = ?fg\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g<\\STATESEP>using isMaxim_max_fun_diff[OF fh f h]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f g)\ns.isMaxim {a \\<in> Field s. f a \\<noteq> h a} (s.max_fun_diff f h)\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max_fun_diff f g<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>using False<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)<\\STATESEP>unfolding s.max2_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f h = s.max_fun_diff f g\n(s.max_fun_diff f g, s.max_fun_diff g h) \\<notin> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition oexp where\n  \"oexp = {(f, g) . f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and>\n    ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma Field_oexp: \"Field oexp = FINFUNC\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field oexp = FINFUNC<\\STATESEP>unfolding oexp_def FinFunc_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> g \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} = Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)<\\STATESEP>by (auto simp: Let_def Field_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_Refl: \"Refl oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Refl oexp<\\STATESEP>unfolding refl_on_def Field_oexp<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. oexp \\<subseteq> FINFUNC \\<times> FINFUNC \\<and> (\\<forall>x\\<in>FINFUNC. (x, x) \\<in> oexp)<\\STATESEP>unfolding oexp_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<subseteq> FINFUNC \\<times> FINFUNC \\<and> (\\<forall>x\\<in>FINFUNC. (x, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)})<\\STATESEP>by (auto simp: Let_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_trans: \"trans oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. trans oexp<\\STATESEP>proof (unfold trans_def, safe)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp<\\STATESEP>fix f g h :: \"'b \\<Rightarrow> 'a\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp<\\STATESEP>let ?fg = \"s.max_fun_diff f g\"\n  and ?gh = \"s.max_fun_diff g h\"\n  and ?fh = \"s.max_fun_diff f h\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp<\\STATESEP>assume oexp: \"(f, g) \\<in> oexp\" \"(g, h) \\<in> oexp\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>(x, y) \\<in> oexp; (y, z) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (x, z) \\<in> oexp<\\STATESEP>thus \"(f, h) \\<in> oexp\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>proof (cases \"f = g \\<or> g = h\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<not> (f = g \\<or> g = h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>with oexp<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\\<not> (f = g \\<or> g = h)<\\STATESEP>have \"f \\<in> FINFUNC\" \"g \\<in> FINFUNC\" \"h \\<in> FINFUNC\"\n      \"(f ?fg, g ?fg) \\<in> r\" \"(g ?gh, h ?gh) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, h) \\<in> oexp\n\\<not> (f = g \\<or> g = h)\n\ngoal (1 subgoal):\n 1. (f \\<in> FINFUNC &&& g \\<in> FINFUNC) &&& h \\<in> FINFUNC &&& (f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r &&& (g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n(g, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n\\<not> (f = g \\<or> g = h)\n\ngoal (1 subgoal):\n 1. (f \\<in> FINFUNC &&& g \\<in> FINFUNC) &&& h \\<in> FINFUNC &&& (f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r &&& (g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>note * = this False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; \\<not> (f = g \\<or> g = h)\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>proof (cases \"f \\<noteq> h\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf \\<noteq> h\n\ngoal (2 subgoals):\n 1. f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>proof (cases \"?fg = ?gh \\<longrightarrow> f ?fg \\<noteq> h ?gh\")<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h) \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>case True<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h) \\<Longrightarrow> (f, h) \\<in> oexp\n 2. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>using max_fun_diff_max2[of f g h, OF True] * \\<open>f \\<noteq> h\\<close> max_fun_diff_in\n          r.max2_iff[OF FINFUNCD FINFUNCD] r.max2_equals1[OF FINFUNCD FINFUNCD] max_fun_diff_le_eq\n          s.in_notinI[OF disjI1]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; g \\<noteq> h; f \\<noteq> h; f \\<in> FINFUNC; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f h = s.max2 (s.max_fun_diff f g) (s.max_fun_diff g h)\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\nf \\<noteq> h\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> ((r.max2 (?f2 ?x2) (?f1 ?x1), ?c) \\<in> r) = ((?f2 ?x2, ?c) \\<in> r \\<and> (?f1 ?x1, ?c) \\<in> r)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (r.max2 (?f2 ?x2) (?f1 ?x1) = ?f2 ?x2) = ((?f1 ?x1, ?f2 ?x2) \\<in> r)\n\\<lbrakk>(s.max_fun_diff ?f ?g, ?x) \\<in> s; ?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC; ?x \\<noteq> s.max_fun_diff ?f ?g\\<rbrakk> \\<Longrightarrow> ?f ?x = ?g ?x\n\\<lbrakk>(?j, ?i) \\<notin> s; ?i \\<in> Field s; ?j \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?i, ?j) \\<in> s\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>unfolding oexp_def Let_def s.max2_def mem_Collect_eq<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<noteq> g; g \\<noteq> h; f \\<noteq> h; f \\<in> FINFUNC; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f h = (if (s.max_fun_diff f g, s.max_fun_diff g h) \\<in> s then s.max_fun_diff g h else s.max_fun_diff f g)\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\nf \\<noteq> h\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> Field s \\<and> ?f (s.max_fun_diff ?f ?g) \\<noteq> ?g (s.max_fun_diff ?f ?g)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> ((r.max2 (?f2 ?x2) (?f1 ?x1), ?c) \\<in> r) = ((?f2 ?x2, ?c) \\<in> r \\<and> (?f1 ?x1, ?c) \\<in> r)\n\\<lbrakk>?f2 \\<in> FINFUNC; ?x2 \\<in> Field s; ?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (r.max2 (?f2 ?x2) (?f1 ?x1) = ?f2 ?x2) = ((?f1 ?x1, ?f2 ?x2) \\<in> r)\n\\<lbrakk>(s.max_fun_diff ?f ?g, ?x) \\<in> s; ?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC; ?x \\<noteq> s.max_fun_diff ?f ?g\\<rbrakk> \\<Longrightarrow> ?f ?x = ?g ?x\n\\<lbrakk>(?j, ?i) \\<notin> s; ?i \\<in> Field s; ?j \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?i, ?j) \\<in> s\n\ngoal (1 subgoal):\n 1. case (f, h) of (f, g) \\<Rightarrow> f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)<\\STATESEP>by safe metis<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>case False<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. \\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h)) \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>with *<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> oexp<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>using antisymD[OF r.ANTISYM, of \"g ?gh\" \"h ?gh\"] max_fun_diff_in[of g h]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> FINFUNC\ng \\<in> FINFUNC\nh \\<in> FINFUNC\n(f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n\\<not> (f = g \\<or> g = h)\n\\<not> (s.max_fun_diff f g = s.max_fun_diff g h \\<longrightarrow> f (s.max_fun_diff f g) \\<noteq> h (s.max_fun_diff g h))\n\\<lbrakk>(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r; (h (s.max_fun_diff g h), g (s.max_fun_diff g h)) \\<in> r\\<rbrakk> \\<Longrightarrow> g (s.max_fun_diff g h) = h (s.max_fun_diff g h)\n\\<lbrakk>g \\<noteq> h; g \\<in> FINFUNC; h \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> f \\<noteq> h \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>qed (auto simp: oexp_def *(3))<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> oexp; (g, h) \\<in> oexp; f = g \\<or> g = h\\<rbrakk> \\<Longrightarrow> (f, h) \\<in> oexp<\\STATESEP>qed auto<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(f, h) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_Preorder: \"Preorder oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Preorder oexp<\\STATESEP>unfolding preorder_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Refl oexp \\<and> trans oexp<\\STATESEP>using oexp_Refl oexp_trans<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nRefl oexp\ntrans oexp\n\ngoal (1 subgoal):\n 1. Refl oexp \\<and> trans oexp<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_antisym: \"antisym oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. antisym oexp<\\STATESEP>proof (unfold antisym_def, safe, rule ccontr)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>fix f g<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>assume \"(f, g) \\<in> oexp\" \"(g, f) \\<in> oexp\" \"g \\<noteq> f\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<lbrakk>(x, y) \\<in> oexp; (y, x) \\<in> oexp; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> False<\\STATESEP>thus False<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>using refl_onD[OF r.REFL FINFUNCD] max_fun_diff_in<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> oexp\n(g, f) \\<in> oexp\ng \\<noteq> f\n\\<lbrakk>?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?f1 ?x1, ?f1 ?x1) \\<in> r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\n(g, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\ng \\<noteq> f\n\\<lbrakk>?f1 \\<in> FINFUNC; ?x1 \\<in> Field s\\<rbrakk> \\<Longrightarrow> (?f1 ?x1, ?f1 ?x1) \\<in> r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by (auto dest!: antisymD[OF r.ANTISYM] simp: s.max_fun_diff_commute)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_Partial_order: \"Partial_order oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Partial_order oexp<\\STATESEP>unfolding partial_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Preorder oexp \\<and> antisym oexp<\\STATESEP>using oexp_Preorder oexp_antisym<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nPreorder oexp\nantisym oexp\n\ngoal (1 subgoal):\n 1. Preorder oexp \\<and> antisym oexp<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_Total: \"Total oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Total oexp<\\STATESEP>unfolding total_on_def Field_oexp<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> oexp \\<or> (y, x) \\<in> oexp<\\STATESEP>unfolding oexp_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<or> (y, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}<\\STATESEP>using FINFUNCD max_fun_diff_in<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>?f \\<in> FINFUNC; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> ?f ?x \\<in> Field r\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> FINFUNC; ?g \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff ?f ?g \\<in> {a \\<in> Field s. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>FINFUNC. \\<forall>y\\<in>FINFUNC. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<or> (y, x) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}<\\STATESEP>by (auto simp: Let_def s.max_fun_diff_commute intro!: r.in_notinI)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_Linear_order: \"Linear_order oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Linear_order oexp<\\STATESEP>unfolding linear_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Partial_order oexp \\<and> Total oexp<\\STATESEP>using oexp_Partial_order oexp_Total<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nPartial_order oexp\nTotal oexp\n\ngoal (1 subgoal):\n 1. Partial_order oexp \\<and> Total oexp<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition \"const = (\\<lambda>x. if x \\<in> Field s then r.zero else undefined)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma const_in[simp]: \"x \\<in> Field s \\<Longrightarrow> const x = r.zero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field s \\<Longrightarrow> const x = r.zero<\\STATESEP>unfolding const_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field s \\<Longrightarrow> (if x \\<in> Field s then r.zero else undefined) = r.zero<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma const_notin[simp]: \"x \\<notin> Field s \\<Longrightarrow> const x = undefined\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Field s \\<Longrightarrow> const x = undefined<\\STATESEP>unfolding const_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Field s \\<Longrightarrow> (if x \\<in> Field s then r.zero else undefined) = undefined<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma const_Int_Field[simp]: \"Field s \\<inter> - {x. const x = r.zero} = {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field s \\<inter> - {x. const x = r.zero} = {}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma const_FINFUNC[simp]: \"Field r \\<noteq> {} \\<Longrightarrow> const \\<in> FINFUNC\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> const \\<in> FINFUNC<\\STATESEP>unfolding FinFunc_def Func_def fin_support_def support_def const_def Int_iff mem_Collect_eq<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> ((\\<forall>a\\<in>Field s. (if a \\<in> Field s then r.zero else undefined) \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> (if a \\<in> Field s then r.zero else undefined) = undefined)) \\<and> finite {x \\<in> Field s. (if x \\<in> Field s then r.zero else undefined) \\<noteq> r.zero}<\\STATESEP>using r.zero_in_Field<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {} \\<Longrightarrow> r.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> ((\\<forall>a\\<in>Field s. (if a \\<in> Field s then r.zero else undefined) \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> (if a \\<in> Field s then r.zero else undefined) = undefined)) \\<and> finite {x \\<in> Field s. (if x \\<in> Field s then r.zero else undefined) \\<noteq> r.zero}<\\STATESEP>by (metis (lifting) Collect_empty_eq finite.emptyI)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma const_least:\n  assumes \"Field r \\<noteq> {}\" \"f \\<in> FINFUNC\"\n  shows \"(const, f) \\<in> oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>proof (cases \"f = const\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f = const \\<Longrightarrow> (const, f) \\<in> oexp\n 2. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf = const\n\ngoal (2 subgoals):\n 1. f = const \\<Longrightarrow> (const, f) \\<in> oexp\n 2. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf = const\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>using refl_onD[OF oexp_Refl] assms(2)<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf = const\n?a \\<in> Field oexp \\<Longrightarrow> (?a, ?a) \\<in> oexp\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>unfolding Field_oexp<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf = const\n?a \\<in> FINFUNC \\<Longrightarrow> (?a, ?a) \\<in> oexp\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(const, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. f \\<noteq> const \\<Longrightarrow> (const, f) \\<in> oexp<\\STATESEP>with assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>using max_fun_diff_in[of f const]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\\<lbrakk>f \\<noteq> const; f \\<in> FINFUNC; const \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f const \\<in> {a \\<in> Field s. f a \\<noteq> const a}\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> oexp<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\nf \\<in> FINFUNC\nf \\<noteq> const\n\\<lbrakk>f \\<noteq> const; f \\<in> FINFUNC; const \\<in> FINFUNC\\<rbrakk> \\<Longrightarrow> s.max_fun_diff f const \\<in> {a \\<in> Field s. f a \\<noteq> const a}\n\ngoal (1 subgoal):\n 1. (const, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by (auto intro: r.zero_smallest FinFuncD simp: s.max_fun_diff_commute)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(const, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma support_not_const:\n  assumes \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s<\\STATESEP>proof (intro ballI conjI)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s<\\STATESEP>fix f<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s<\\STATESEP>assume \"f \\<in> F\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf \\<in> F\n\ngoal (3 subgoals):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> finite (SUPP f)\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<subseteq> Field s<\\STATESEP>thus \"finite (SUPP f)\" \"SUPP f \\<subseteq> Field s\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\n\ngoal (1 subgoal):\n 1. finite (SUPP f) &&& SUPP f \\<subseteq> Field s<\\STATESEP>using assms(1)<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. finite (SUPP f) &&& SUPP f \\<subseteq> Field s<\\STATESEP>unfolding FinFunc_def fin_support_def support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. finite {x \\<in> Field s. f x \\<noteq> r.zero} &&& {x \\<in> Field s. f x \\<noteq> r.zero} \\<subseteq> Field s<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfinite (SUPP f)\nSUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> SUPP f \\<noteq> {}<\\STATESEP>show \"SUPP f \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. SUPP f \\<noteq> {}<\\STATESEP>proof (rule ccontr, unfold not_not)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False<\\STATESEP>assume \"SUPP f = {}\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nSUPP f = {}\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nSUPP f = {}\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False<\\STATESEP>from \\<open>f \\<in> F\\<close> assms(1)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> F\nF \\<subseteq> FINFUNC<\\STATESEP>have \"f \\<in> FINFUNC\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. f \\<in> FINFUNC<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nSUPP f = {}\nf \\<in> FINFUNC<\\STATESEP>have \"f = const\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nSUPP f = {}\nf \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f = const<\\STATESEP>by (auto simp: fun_eq_iff support_def FinFunc_def Func_def const_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf = const\n\ngoal (1 subgoal):\n 1. SUPP f = {} \\<Longrightarrow> False<\\STATESEP>with assms(2) \\<open>f \\<in> F\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nconst \\<notin> F\nf \\<in> F\nf = const<\\STATESEP>show False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nconst \\<notin> F\nf \\<in> F\nf = const\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nSUPP f \\<noteq> {}\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma maxim_isMaxim_support:\n  assumes f: \"F \\<subseteq> FINFUNC\" and \"const \\<notin> F\"\n  shows \"\\<forall>f \\<in> F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))<\\STATESEP>using support_not_const[OF assms]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))<\\STATESEP>by (auto intro!: s.maxim_isMaxim)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_empty2: \"Field s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}<\\STATESEP>unfolding oexp_def FinFunc_def fin_support_def support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field s = {} \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> g \\<in> Func (Field s) (Field r) \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_empty: \"\\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}<\\STATESEP>unfolding oexp_def FinFunc_def Let_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> g \\<in> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s) \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)} = {}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fun_upd_FINFUNC: \"\\<lbrakk>f \\<in> FINFUNC; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> FINFUNC\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FINFUNC; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> FINFUNC<\\STATESEP>unfolding FinFunc_def Func_def fin_support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (SUPP f)}; x \\<in> Field s; y \\<in> Field r\\<rbrakk> \\<Longrightarrow> f(x := y) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (SUPP f)}<\\STATESEP>by (auto intro: finite_subset[OF support_upd_subset])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma fun_upd_same_oexp:\n  assumes \"(f, g) \\<in> oexp\" \"f x = g x\" \"x \\<in> Field s\" \"y \\<in> Field r\"\n  shows   \"(f(x := y), g(x := y)) \\<in> oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>from assms(1) fun_upd_FINFUNC[OF _ assms(3,4)]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(f, g) \\<in> oexp\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC<\\STATESEP>have fg: \"f(x := y) \\<in> FINFUNC\" \"g(x := y) \\<in> FINFUNC\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> oexp\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f(x := y) \\<in> FINFUNC &&& g(x := y) \\<in> FINFUNC<\\STATESEP>unfolding oexp_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n?f \\<in> FINFUNC \\<Longrightarrow> ?f(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. f(x := y) \\<in> FINFUNC &&& g(x := y) \\<in> FINFUNC<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>from assms(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf x = g x<\\STATESEP>have \"s.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g<\\STATESEP>unfolding s.max_fun_diff_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf x = g x\n\ngoal (1 subgoal):\n 1. s.maxim {a \\<in> Field s. (f(x := y)) a \\<noteq> (g(x := y)) a} = s.maxim {a \\<in> Field s. f a \\<noteq> g a}<\\STATESEP>by auto metis<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>using assms refl_onD[OF r.REFL]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n(f, g) \\<in> oexp\nf x = g x\nx \\<in> Field s\ny \\<in> Field r\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> oexp<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf(x := y) \\<in> FINFUNC\ng(x := y) \\<in> FINFUNC\ns.max_fun_diff (f(x := y)) (g(x := y)) = s.max_fun_diff f g\n(f, g) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}\nf x = g x\nx \\<in> Field s\ny \\<in> Field r\n?a \\<in> Field r \\<Longrightarrow> (?a, ?a) \\<in> r\n\ngoal (1 subgoal):\n 1. (f(x := y), g(x := y)) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(f(x := y), g(x := y)) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma fun_upd_smaller_oexp:\n  assumes \"f \\<in> FINFUNC\" \"x \\<in> Field s\" \"y \\<in> Field r\"  \"(y, f x) \\<in> r\"\n  shows   \"(f(x := y), f) \\<in> oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> oexp<\\STATESEP>using assms fun_upd_FINFUNC[OF assms(1-3)] s.maxim_singleton[of \"x\"]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> FINFUNC\nx \\<in> Field s\ny \\<in> Field r\n(y, f x) \\<in> r\nf(x := y) \\<in> FINFUNC\nx \\<in> Field s \\<Longrightarrow> s.maxim {x} = x\n\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> oexp<\\STATESEP>unfolding oexp_def FinFunc_def Let_def fin_support_def s.max_fun_diff_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)}\nx \\<in> Field s\ny \\<in> Field r\n(y, f x) \\<in> r\nf(x := y) \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)}\nx \\<in> Field s \\<Longrightarrow> s.maxim {x} = x\n\ngoal (1 subgoal):\n 1. (f(x := y), f) \\<in> {(f, g). f \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)} \\<and> g \\<in> Func (Field s) (Field r) \\<inter> {f. finite (SUPP f)} \\<and> ((f (s.maxim {a \\<in> Field s. f a \\<noteq> g a}), g (s.maxim {a \\<in> Field s. f a \\<noteq> g a})) \\<in> r \\<or> f = g)}<\\STATESEP>by (auto simp: fun_eq_iff)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_wf_Id: \"wf (oexp - Id)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (oexp - Id)<\\STATESEP>proof (cases \"Field r = {} \\<or> Field s = {}\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. Field r = {} \\<or> Field s = {} \\<Longrightarrow> wf (oexp - Id)\n 2. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nField r = {} \\<or> Field s = {}\n\ngoal (2 subgoals):\n 1. Field r = {} \\<or> Field s = {} \\<Longrightarrow> wf (oexp - Id)\n 2. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r = {} \\<or> Field s = {}\n\ngoal (1 subgoal):\n 1. wf (oexp - Id)<\\STATESEP>using oexp_empty oexp_empty2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r = {} \\<or> Field s = {}\n\\<lbrakk>Field r = {}; Field s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> oexp = {}\nField s = {} \\<Longrightarrow> oexp = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\n\ngoal (1 subgoal):\n 1. wf (oexp - Id)<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nwf (oexp - Id)\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n\\<not> (Field r = {} \\<or> Field s = {})\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>hence Fields: \"Field s \\<noteq> {}\" \"Field r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (Field r = {} \\<or> Field s = {})\n\ngoal (1 subgoal):\n 1. Field s \\<noteq> {} &&& Field r \\<noteq> {}<\\STATESEP>by simp_all<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField s \\<noteq> {}\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>hence [simp]: \"r.zero \\<in> Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField s \\<noteq> {}\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r.zero \\<in> Field r<\\STATESEP>by (intro r.zero_in_Field)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>have const[simp]: \"\\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>using const_least[OF Fields(2)]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n?f \\<in> FINFUNC \\<Longrightarrow> (const, ?f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>F. \\<lbrakk>const \\<in> F; F \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<lbrakk>const \\<in> ?F1; ?F1 \\<subseteq> FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>?F1. \\<forall>f\\<in>?F1. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<not> (Field r = {} \\<or> Field s = {}) \\<Longrightarrow> wf (oexp - Id)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wf (oexp - Id)<\\STATESEP>unfolding Linear_order_wf_diff_Id[OF oexp_Linear_order] Field_oexp<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<subseteq>FINFUNC. A \\<noteq> {} \\<longrightarrow> (\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp)<\\STATESEP>proof (intro allI impI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>fix A<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>assume A: \"A \\<subseteq> FINFUNC\" \"A \\<noteq> {}\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nA \\<subseteq> FINFUNC\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nA \\<subseteq> FINFUNC\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>fix y F<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>have \"F \\<subseteq> FINFUNC \\<and> (\\<exists>f \\<in> F. y = s.maxim (SUPP f)) \\<longrightarrow>\n        (\\<exists>f0 \\<in> F. \\<forall>f \\<in> F. (f0, f) \\<in> oexp)\" (is \"?P F y\")<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)<\\STATESEP>proof (induct y arbitrary: F rule: s.well_order_induct)<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F. \\<forall>y. y \\<noteq> x \\<and> (y, x) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp)) \\<Longrightarrow> F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. x = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)<\\STATESEP>case (1 y)<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n\\<forall>y. y \\<noteq> y \\<and> (y, y) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp))\n\ngoal (1 subgoal):\n 1. \\<And>x F. \\<forall>y. y \\<noteq> x \\<and> (y, x) \\<in> s \\<longrightarrow> (\\<forall>x. x \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>x. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>x. \\<forall>f\\<in>x. (f0, f) \\<in> oexp)) \\<Longrightarrow> F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. x = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)<\\STATESEP>show ?case<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)<\\STATESEP>proof (intro impI, elim conjE bexE)<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>fix f<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>assume F: \"F \\<subseteq> FINFUNC\" \"f \\<in> F\" \"y = s.maxim (SUPP f)\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>thus \"\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>proof (cases \"const \\<in> F\")<\\STATESEP>11<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>case False<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nconst \\<notin> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>with F<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F<\\STATESEP>have maxF: \"\\<forall>f \\<in> F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\"\n              and SUPPF: \"\\<forall>f \\<in> F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f)) &&& \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s<\\STATESEP>using maxim_isMaxim_support support_not_const<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nconst \\<notin> F\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f)) &&& \\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>define z where \"z = s.minim {s.maxim (SUPP f) | f. f \\<in> F}\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nz = s.minim {s.maxim (SUPP f) |f. f \\<in> F}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from F SUPPF maxF<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))<\\STATESEP>have zmin: \"s.isMinim {s.maxim (SUPP f) | f. f \\<in> F} z\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z<\\STATESEP>unfolding z_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> F} (s.minim {s.maxim (SUPP f) |f. f \\<in> F})<\\STATESEP>by (intro s.minim_isMinim) (auto simp: s.isMaxim_def)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>with F<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z<\\STATESEP>have zy: \"(z, y) \\<in> s\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> s<\\STATESEP>unfolding s.isMinim_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> s<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\n(z, y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>hence zField: \"z \\<in> Field s\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\n(z, y) \\<in> s\n\ngoal (1 subgoal):\n 1. z \\<in> Field s<\\STATESEP>unfolding Field_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\n(z, y) \\<in> s\n\ngoal (1 subgoal):\n 1. z \\<in> Domain s \\<union> Range s<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nz \\<in> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>define x0 where \"x0 = r.minim {f z | f. f \\<in> F \\<and> z = s.maxim (SUPP f)}\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nx0 = r.minim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from F(1,2) maxF(1) SUPPF zmin<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z<\\STATESEP>have x0min: \"r.isMinim {f z | f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\n\ngoal (1 subgoal):\n 1. r.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0<\\STATESEP>unfolding x0_def s.isMaxim_def s.isMinim_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\n\ngoal (1 subgoal):\n 1. r.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} (r.minim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)})<\\STATESEP>by (blast intro!: r.minim_isMinim FinFuncD[of _ r s])<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>with maxF(1) SUPPF F(1)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0<\\STATESEP>have x0Field: \"x0 \\<in> Field r\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (1 subgoal):\n 1. x0 \\<in> Field r<\\STATESEP>unfolding r.isMinim_def s.isMaxim_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\n\ngoal (1 subgoal):\n 1. x0 \\<in> Field r<\\STATESEP>by (auto intro!: FINFUNCD)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nx0 \\<in> Field r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from x0min maxF(1) SUPPF F(1)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC<\\STATESEP>have x0notzero: \"x0 \\<noteq> r.zero\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> r.zero<\\STATESEP>unfolding r.isMinim_def s.isMaxim_def FinFunc_def Func_def support_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}}. (x0, a) \\<in> r)\n\\<forall>f\\<in>F. s.maxim {x \\<in> Field s. f x \\<noteq> r.zero} \\<in> {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> (\\<forall>a\\<in>{x \\<in> Field s. f x \\<noteq> r.zero}. (a, s.maxim {x \\<in> Field s. f x \\<noteq> r.zero}) \\<in> s)\n\\<forall>f\\<in>F. finite {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> {x \\<in> Field s. f x \\<noteq> r.zero} \\<noteq> {} \\<and> {x \\<in> Field s. f x \\<noteq> r.zero} \\<subseteq> Field s\nF \\<subseteq> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\n\ngoal (1 subgoal):\n 1. x0 \\<noteq> r.zero<\\STATESEP>by fastforce<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nx0 \\<noteq> r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>define G where \"G = {f(z := r.zero) | f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nG = {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from zmin x0min<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0<\\STATESEP>have \"G \\<noteq> {}\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\n\ngoal (1 subgoal):\n 1. G \\<noteq> {}<\\STATESEP>unfolding G_def z_def s.isMinim_def r.isMinim_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\ns.minim {s.maxim (SUPP f) |f. f \\<in> F} \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (s.minim {s.maxim (SUPP f) |f. f \\<in> F}, a) \\<in> s)\nx0 \\<in> {f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f)}. (x0, a) \\<in> r)\n\ngoal (1 subgoal):\n 1. {f(s.minim {s.maxim (SUPP f) |f. f \\<in> F} := r.zero) |f. f \\<in> F \\<and> s.minim {s.maxim (SUPP f) |f. f \\<in> F} = s.maxim (SUPP f) \\<and> f (s.minim {s.maxim (SUPP f) |f. f \\<in> F}) = x0} \\<noteq> {}<\\STATESEP>by blast<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nG \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>have GF: \"G \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\"<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F<\\STATESEP>unfolding G_def<\\STATESEP>13<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0} \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>have \"G \\<subseteq> fin_support r.zero (Field s)\"<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> fin_support r.zero (Field s)<\\STATESEP>unfolding FinFunc_def fin_support_def<\\STATESEP>13<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> {f. finite (SUPP f)}<\\STATESEP>proof safe<\\STATESEP>13<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)<\\STATESEP>fix g<\\STATESEP>14<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)<\\STATESEP>assume \"g \\<in> G\"<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\ng \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)<\\STATESEP>with GF<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\ng \\<in> G<\\STATESEP>obtain f where f: \"f \\<in> F\" \"g = f(z := r.zero)\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\ng \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\nf \\<in> F\ng = f(z := r.zero)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)<\\STATESEP>with SUPPF<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)<\\STATESEP>have \"finite (SUPP f)\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\n\ngoal (1 subgoal):\n 1. finite (SUPP f)<\\STATESEP>by blast<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\nfinite (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> finite (SUPP x)<\\STATESEP>with f<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> F\ng = f(z := r.zero)\nfinite (SUPP f)<\\STATESEP>show \"finite (SUPP g)\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\ng = f(z := r.zero)\nfinite (SUPP f)\n\ngoal (1 subgoal):\n 1. finite (SUPP g)<\\STATESEP>by (elim finite_subset[rotated]) (auto simp: support_def)<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\nfinite (SUPP g)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\nG \\<subseteq> fin_support r.zero (Field s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nG \\<subseteq> fin_support r.zero (Field s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from F GF zField<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s<\\STATESEP>have \"G \\<subseteq> Func (Field s) (Field r)\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)<\\STATESEP>using Func_upd[of _ \"Field s\" \"Field r\" z r.zero]<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> FINFUNC\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\\<lbrakk>?f \\<in> Func (Field s) (Field r); z \\<in> Field s; r.zero \\<in> Field r\\<rbrakk> \\<Longrightarrow> ?f(z := r.zero) \\<in> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)<\\STATESEP>unfolding FinFunc_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nF \\<subseteq> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)\nf \\<in> F\ny = s.maxim (SUPP f)\nG \\<subseteq> (\\<lambda>f. f(z := r.zero)) ` F\nz \\<in> Field s\n\\<lbrakk>?f \\<in> Func (Field s) (Field r); z \\<in> Field s; r.zero \\<in> Field r\\<rbrakk> \\<Longrightarrow> ?f(z := r.zero) \\<in> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r)<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)<\\STATESEP>have G: \"G \\<subseteq> FINFUNC\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> FINFUNC<\\STATESEP>unfolding FinFunc_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> fin_support r.zero (Field s)\nG \\<subseteq> Func (Field s) (Field r)\n\ngoal (1 subgoal):\n 1. G \\<subseteq> Func (Field s) (Field r) \\<inter> fin_support r.zero (Field s)<\\STATESEP>by blast<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nG \\<subseteq> FINFUNC\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>hence \"\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>proof (cases \"const \\<in> G\")<\\STATESEP>13<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>case False<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\nconst \\<notin> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>with G<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G<\\STATESEP>have maxG: \"\\<forall>g \\<in> G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\"\n                and SUPPG: \"\\<forall>g \\<in> G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g)) &&& \\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s<\\STATESEP>using maxim_isMaxim_support support_not_const<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\nconst \\<notin> G\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<lbrakk>?F \\<subseteq> FINFUNC; const \\<notin> ?F\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>?F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g)) &&& \\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>define y' where \"y' = s.minim {s.maxim (SUPP f) | f. f \\<in> G}\"<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\ny' = s.minim {s.maxim (SUPP f) |f. f \\<in> G}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>from G SUPPG maxG \\<open>G \\<noteq> {}\\<close><\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}<\\STATESEP>have y'min: \"s.isMinim {s.maxim (SUPP f) | f. f \\<in> G} y'\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'<\\STATESEP>unfolding y'_def<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\nG \\<subseteq> FINFUNC\n\\<forall>g\\<in>G. finite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s.isMinim {s.maxim (SUPP f) |f. f \\<in> G} (s.minim {s.maxim (SUPP f) |f. f \\<in> G})<\\STATESEP>by (intro s.minim_isMinim) (auto simp: s.isMaxim_def)<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>have \"\\<forall>g \\<in> G. z \\<notin> SUPP g\"<\\STATESEP>14<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. z \\<notin> SUPP g<\\STATESEP>unfolding support_def G_def<\\STATESEP>15<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>{f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim {x \\<in> Field s. f x \\<noteq> r.zero} \\<and> f z = x0}. z \\<notin> {x \\<in> Field s. g x \\<noteq> r.zero}<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>{<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>fix g<\\STATESEP>16<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>assume g: \"g \\<in> G\"<\\STATESEP>16<\\TRANSEP>proof (state)\nthis:\ng \\<in> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>then<\\STATESEP>16<\\TRANSEP>proof (chain)\npicking this:\ng \\<in> G<\\STATESEP>obtain f where \"f \\<in> F\" \"g = f(z := r.zero)\" and z: \"z = s.maxim (SUPP f)\"<\\STATESEP>16<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero); z = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding G_def<\\STATESEP>17<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>f \\<in> F; g = f(z := r.zero); z = s.maxim (SUPP f)\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>17<\\TRANSEP>proof (state)\nthis:\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>with SUPPF bspec[OF SUPPG g]<\\STATESEP>16<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)<\\STATESEP>have \"(s.maxim (SUPP g), z) \\<in> s\"<\\STATESEP>16<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(z := r.zero)\nz = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP g), z) \\<in> s<\\STATESEP>unfolding z<\\STATESEP>17<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nfinite (SUPP g) \\<and> SUPP g \\<noteq> {} \\<and> SUPP g \\<subseteq> Field s\nf \\<in> F\ng = f(s.maxim (SUPP f) := r.zero)\ns.maxim (SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP g), s.maxim (SUPP f)) \\<in> s<\\STATESEP>by (intro s.maxim_mono) auto<\\STATESEP>17<\\TRANSEP>proof (state)\nthis:\n(s.maxim (SUPP g), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>}<\\STATESEP>16<\\TRANSEP>proof (state)\nthis:\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>from y'min<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'<\\STATESEP>have \"\\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s<\\STATESEP>unfolding s.isMinim_def<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\ny' \\<in> {s.maxim (SUPP f) |f. f \\<in> G} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> G}. (y', a) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP g)) \\<in> s<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s<\\STATESEP>have \"y' \\<noteq> z\" \"(y', z) \\<in> s\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s<\\STATESEP>using maxG<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\\<forall>g\\<in>G. s.isMaxim (SUPP g) (s.maxim (SUPP g))\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s<\\STATESEP>unfolding s.isMinim_def s.isMaxim_def<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\ny' \\<in> {s.maxim (SUPP f) |f. f \\<in> G} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> G}. (y', a) \\<in> s)\n\\<forall>g\\<in>G. z \\<notin> SUPP g\n?g3 \\<in> G \\<Longrightarrow> (s.maxim (SUPP ?g3), z) \\<in> s\n?g1 \\<in> G \\<Longrightarrow> (y', s.maxim (SUPP ?g1)) \\<in> s\n\\<forall>g\\<in>G. s.maxim (SUPP g) \\<in> SUPP g \\<and> (\\<forall>a\\<in>SUPP g. (a, s.maxim (SUPP g)) \\<in> s)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> z &&& (y', z) \\<in> s<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\ny' \\<noteq> z\n(y', z) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>with zy<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s<\\STATESEP>have \"y' \\<noteq> y\" \"(y', y) \\<in> s\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y &&& (y', y) \\<in> s<\\STATESEP>using antisymD[OF s.ANTISYM] transD[OF s.TRANS]<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\n(z, y) \\<in> s\ny' \\<noteq> z\n(y', z) \\<in> s\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\\<lbrakk>(?x, ?y) \\<in> s; (?y, ?z) \\<in> s\\<rbrakk> \\<Longrightarrow> (?x, ?z) \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y &&& (y', y) \\<in> s<\\STATESEP>by blast+<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\ny' \\<noteq> y\n(y', y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\ny' \\<noteq> y\n(y', y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>from \\<open>G \\<noteq> {}\\<close><\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\nG \\<noteq> {}<\\STATESEP>have \"\\<exists>g \\<in> G. y' = wo_rel.maxim s (SUPP g)\"<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\nG \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>G. y' = s.maxim (SUPP g)<\\STATESEP>using y'min<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\nG \\<noteq> {}\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> G} y'\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>G. y' = s.maxim (SUPP g)<\\STATESEP>by (auto simp: G_def s.isMinim_def)<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n 2. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<notin> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>14<\\TRANSEP>proof (chain)\npicking this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)<\\STATESEP>show ?thesis<\\STATESEP>14<\\TRANSEP>proof (prove)\nusing this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>using mp[OF spec[OF mp[OF spec[OF 1]]], of y' G] G<\\STATESEP>15<\\TRANSEP>proof (prove)\nusing this:\ny' \\<noteq> y\n(y', y) \\<in> s\n\\<exists>g\\<in>G. y' = s.maxim (SUPP g)\n\\<lbrakk>y' \\<noteq> y \\<and> (y', y) \\<in> s; G \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>G. y' = s.maxim (SUPP f))\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>G. \\<forall>f\\<in>G. (f0, f) \\<in> oexp\nG \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>by auto<\\STATESEP>15<\\TRANSEP>proof (state)\nthis:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<subseteq> FINFUNC; const \\<in> G\\<rbrakk> \\<Longrightarrow> \\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>qed simp<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>then<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp<\\STATESEP>obtain g0 where g0: \"g0 \\<in> G\" \"\\<forall>g \\<in> G. (g0, g) \\<in> oexp\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>g0\\<in>G. \\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (\\<And>g0. \\<lbrakk>g0 \\<in> G; \\<forall>g\\<in>G. (g0, g) \\<in> oexp\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\ng0 \\<in> G\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>hence g0z: \"g0 z = r.zero\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ng0 \\<in> G\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. g0 z = r.zero<\\STATESEP>unfolding G_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\\<forall>g\\<in>{f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}. (g0, g) \\<in> oexp\n\ngoal (1 subgoal):\n 1. g0 z = r.zero<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\ng0 z = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>define f0 where \"f0 = g0(z := x0)\"<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\nf0 = g0(z := x0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>with x0notzero zField<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)<\\STATESEP>have SUPP: \"SUPP f0 = SUPP g0 \\<union> {z}\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)\n\ngoal (1 subgoal):\n 1. SUPP f0 = SUPP g0 \\<union> {z}<\\STATESEP>unfolding support_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nx0 \\<noteq> r.zero\nz \\<in> Field s\nf0 = g0(z := x0)\n\ngoal (1 subgoal):\n 1. {x \\<in> Field s. f0 x \\<noteq> r.zero} = {x \\<in> Field s. g0 x \\<noteq> r.zero} \\<union> {z}<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nSUPP f0 = SUPP g0 \\<union> {z}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from g0z<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\ng0 z = r.zero<\\STATESEP>have f0z: \"f0(z := r.zero) = g0\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ng0 z = r.zero\n\ngoal (1 subgoal):\n 1. f0(z := r.zero) = g0<\\STATESEP>unfolding f0_def fun_upd_upd<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\ng0 z = r.zero\n\ngoal (1 subgoal):\n 1. g0(z := r.zero) = g0<\\STATESEP>by auto<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf0(z := r.zero) = g0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>have f0: \"f0 \\<in> F\"<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<in> F<\\STATESEP>using x0min g0(1)\n              Func_elim[OF subsetD[OF subset_trans[OF F(1)[unfolded FinFunc_def] Int_lower1]] zField]<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ng0 \\<in> G\n?g \\<in> F \\<Longrightarrow> \\<exists>b. b \\<in> Field r \\<and> ?g z = b\n\ngoal (1 subgoal):\n 1. f0 \\<in> F<\\STATESEP>unfolding f0_def r.isMinim_def G_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n?g \\<in> F \\<Longrightarrow> \\<exists>b. b \\<in> Field r \\<and> ?g z = b\n\ngoal (1 subgoal):\n 1. g0(z := x0) \\<in> F<\\STATESEP>by (force simp: fun_upd_idem)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\nf0 \\<in> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>from g0(1) maxF(1)<\\STATESEP>12<\\TRANSEP>proof (chain)\npicking this:\ng0 \\<in> G\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))<\\STATESEP>have maxf0: \"s.maxim (SUPP f0) = z\"<\\STATESEP>12<\\TRANSEP>proof (prove)\nusing this:\ng0 \\<in> G\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0) = z<\\STATESEP>unfolding SUPP G_def<\\STATESEP>13<\\TRANSEP>proof (prove)\nusing this:\ng0 \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP g0 \\<union> {z}) = z<\\STATESEP>by (intro s.maxim_equality) (auto simp: s.isMaxim_def)<\\STATESEP>13<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f0) = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n 2. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<notin> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>show ?thesis<\\STATESEP>12<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>proof (intro bexI[OF _ f0] ballI)<\\STATESEP>13<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>fix f<\\STATESEP>14<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>assume f: \"f \\<in> F\"<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\nf \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>show \"(f0, f) \\<in> oexp\"<\\STATESEP>14<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>proof (cases \"f0 = f\")<\\STATESEP>15<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f0 = f \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case True<\\STATESEP>16<\\TRANSEP>proof (state)\nthis:\nf0 = f\n\ngoal (2 subgoals):\n 1. f0 = f \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>thus ?thesis<\\STATESEP>16<\\TRANSEP>proof (prove)\nusing this:\nf0 = f\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>by (metis F(1) Field_oexp f0 in_mono oexp_Refl refl_onD)<\\STATESEP>17<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>next<\\STATESEP>16<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case False<\\STATESEP>16<\\TRANSEP>proof (state)\nthis:\nf0 \\<noteq> f\n\ngoal (1 subgoal):\n 1. f0 \\<noteq> f \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>thus ?thesis<\\STATESEP>16<\\TRANSEP>proof (prove)\nusing this:\nf0 \\<noteq> f\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>proof (cases \"s.maxim (SUPP f) = z \\<and> f z = x0\")<\\STATESEP>17<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case True<\\STATESEP>18<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with f<\\STATESEP>18<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0<\\STATESEP>have \"f(z := r.zero) \\<in> G\"<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (1 subgoal):\n 1. f(z := r.zero) \\<in> G<\\STATESEP>unfolding G_def<\\STATESEP>19<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\ns.maxim (SUPP f) = z \\<and> f z = x0\n\ngoal (1 subgoal):\n 1. f(z := r.zero) \\<in> {f(z := r.zero) |f. f \\<in> F \\<and> z = s.maxim (SUPP f) \\<and> f z = x0}<\\STATESEP>by blast<\\STATESEP>19<\\TRANSEP>proof (state)\nthis:\nf(z := r.zero) \\<in> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with g0(2) f0z<\\STATESEP>18<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\nf0(z := r.zero) = g0\nf(z := r.zero) \\<in> G<\\STATESEP>have \"(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\"<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>g\\<in>G. (g0, g) \\<in> oexp\nf0(z := r.zero) = g0\nf(z := r.zero) \\<in> G\n\ngoal (1 subgoal):\n 1. (f0(z := r.zero), f(z := r.zero)) \\<in> oexp<\\STATESEP>by auto<\\STATESEP>19<\\TRANSEP>proof (state)\nthis:\n(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>hence oexp: \"(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\"<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\n(f0(z := r.zero), f(z := r.zero)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp<\\STATESEP>by (elim fun_upd_same_oexp[OF _ _ zField x0Field]) simp<\\STATESEP>19<\\TRANSEP>proof (state)\nthis:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with f F(1) x0min True<\\STATESEP>18<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp<\\STATESEP>have \"(f(z := x0), f) \\<in> oexp\"<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f(z := x0), f) \\<in> oexp<\\STATESEP>unfolding G_def r.isMinim_def<\\STATESEP>19<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\nF \\<subseteq> FINFUNC\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ns.maxim (SUPP f) = z \\<and> f z = x0\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f(z := x0), f) \\<in> oexp<\\STATESEP>by (intro fun_upd_smaller_oexp[OF _ zField x0Field]) auto<\\STATESEP>19<\\TRANSEP>proof (state)\nthis:\n(f(z := x0), f) \\<in> oexp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f0 \\<noteq> f; s.maxim (SUPP f) = z \\<and> f z = x0\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with oexp<\\STATESEP>18<\\TRANSEP>proof (chain)\npicking this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp<\\STATESEP>show ?thesis<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>using transD[OF oexp_trans, of f0 \"f(z := x0)\" f]<\\STATESEP>19<\\TRANSEP>proof (prove)\nusing this:\n(f0(z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\\<lbrakk>(f0, f(z := x0)) \\<in> oexp; (f(z := x0), f) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>unfolding f0_def<\\STATESEP>19<\\TRANSEP>proof (prove)\nusing this:\n(g0(z := x0, z := r.zero, z := x0), f(z := r.zero, z := x0)) \\<in> oexp\n(f(z := x0), f) \\<in> oexp\n\\<lbrakk>(g0(z := x0), f(z := x0)) \\<in> oexp; (f(z := x0), f) \\<in> oexp\\<rbrakk> \\<Longrightarrow> (g0(z := x0), f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. (g0(z := x0), f) \\<in> oexp<\\STATESEP>by auto<\\STATESEP>19<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>next<\\STATESEP>18<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case False<\\STATESEP>18<\\TRANSEP>proof (state)\nthis:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>note notG = this<\\STATESEP>18<\\TRANSEP>proof (state)\nthis:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f0 \\<noteq> f; \\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>thus ?thesis<\\STATESEP>18<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>proof (cases \"s.maxim (SUPP f) = z\")<\\STATESEP>19<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case True<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f) = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with notG<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z<\\STATESEP>have \"f0 z \\<noteq> f z\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z\n\ngoal (1 subgoal):\n 1. f0 z \\<noteq> f z<\\STATESEP>unfolding f0_def<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) = z\n\ngoal (1 subgoal):\n 1. (g0(z := x0)) z \\<noteq> f z<\\STATESEP>by auto<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\nf0 z \\<noteq> f z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>hence \"f0 z \\<noteq> f z\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\nf0 z \\<noteq> f z\n\ngoal (1 subgoal):\n 1. f0 z \\<noteq> f z<\\STATESEP>by metis<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\nf0 z \\<noteq> f z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with True maxf0 f0 f SUPPF<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z<\\STATESEP>have \"s.max_fun_diff f0 f = z\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = z<\\STATESEP>using s.maxim_Un[of \"SUPP f0\" \"SUPP f\", unfolded s.max2_def]<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = (if (s.maxim (SUPP f0), s.maxim (SUPP f)) \\<in> s then s.maxim (SUPP f) else s.maxim (SUPP f0))\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = z<\\STATESEP>unfolding max_fun_diff_alt<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\ns.maxim (SUPP f) = z\ns.maxim (SUPP f0) = z\nf0 \\<in> F\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 z \\<noteq> f z\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = (if (s.maxim (SUPP f0), s.maxim (SUPP f)) \\<in> s then s.maxim (SUPP f) else s.maxim (SUPP f0))\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = z<\\STATESEP>by (intro trans[OF s.maxim_Int]) auto<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f0 f = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f0 f = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>from x0min True f<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z\nf \\<in> F<\\STATESEP>have \"(x0, f z) \\<in> r\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\nr.isMinim {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} x0\ns.maxim (SUPP f) = z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (x0, f z) \\<in> r<\\STATESEP>unfolding r.isMinim_def<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\nx0 \\<in> {f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)} \\<and> (\\<forall>a\\<in>{f z |f. f \\<in> F \\<and> z = s.maxim (SUPP f)}. (x0, a) \\<in> r)\ns.maxim (SUPP f) = z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (x0, f z) \\<in> r<\\STATESEP>by auto<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\n(x0, f z) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) = z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp\n 2. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r<\\STATESEP>show ?thesis<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>using f f0 F(1)<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff f0 f = z\n(x0, f z) \\<in> r\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>unfolding oexp_def f0_def<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff (g0(z := x0)) f = z\n(x0, f z) \\<in> r\nf \\<in> F\ng0(z := x0) \\<in> F\nF \\<subseteq> FINFUNC\n\ngoal (1 subgoal):\n 1. (g0(z := x0), f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}<\\STATESEP>by auto<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>next<\\STATESEP>20<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>case False<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f) \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with notG<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z<\\STATESEP>have *: \"(z, s.maxim (SUPP f)) \\<in> s\" \"z \\<noteq> s.maxim (SUPP f)\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)<\\STATESEP>using zmin f<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\ns.isMinim {s.maxim (SUPP f) |f. f \\<in> F} z\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)<\\STATESEP>unfolding s.isMinim_def G_def<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0)\ns.maxim (SUPP f) \\<noteq> z\nz \\<in> {s.maxim (SUPP f) |f. f \\<in> F} \\<and> (\\<forall>a\\<in>{s.maxim (SUPP f) |f. f \\<in> F}. (z, a) \\<in> s)\nf \\<in> F\n\ngoal (1 subgoal):\n 1. (z, s.maxim (SUPP f)) \\<in> s &&& z \\<noteq> s.maxim (SUPP f)<\\STATESEP>by auto<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>have f0f: \"f0 (s.maxim (SUPP f)) = r.zero\"<\\STATESEP>20<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) = r.zero<\\STATESEP>proof (rule ccontr)<\\STATESEP>21<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False<\\STATESEP>assume \"f0 (s.maxim (SUPP f)) \\<noteq> r.zero\"<\\STATESEP>22<\\TRANSEP>proof (state)\nthis:\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False<\\STATESEP>with f SUPPF maxF(1)<\\STATESEP>22<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero<\\STATESEP>have \"s.maxim (SUPP f) \\<in> SUPP f0\"<\\STATESEP>22<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f) \\<in> SUPP f0<\\STATESEP>unfolding support_def[of _ _ f0] s.isMaxim_def<\\STATESEP>23<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> F\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\\<forall>f\\<in>F. s.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\nf0 (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f) \\<in> {x \\<in> Field s. f0 x \\<noteq> r.zero}<\\STATESEP>by auto<\\STATESEP>23<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False<\\STATESEP>with SUPPF f0<\\STATESEP>22<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0<\\STATESEP>have \"(s.maxim (SUPP f), z) \\<in> s\"<\\STATESEP>22<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP f), z) \\<in> s<\\STATESEP>unfolding maxf0[symmetric]<\\STATESEP>23<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\ns.maxim (SUPP f) \\<in> SUPP f0\n\ngoal (1 subgoal):\n 1. (s.maxim (SUPP f), s.maxim (SUPP f0)) \\<in> s<\\STATESEP>by (auto intro: s.maxim_greatest)<\\STATESEP>23<\\TRANSEP>proof (state)\nthis:\n(s.maxim (SUPP f), z) \\<in> s\n\ngoal (1 subgoal):\n 1. f0 (s.maxim (SUPP f)) \\<noteq> r.zero \\<Longrightarrow> False<\\STATESEP>with * antisymD[OF s.ANTISYM]<\\STATESEP>22<\\TRANSEP>proof (chain)\npicking this:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n(s.maxim (SUPP f), z) \\<in> s<\\STATESEP>show False<\\STATESEP>22<\\TRANSEP>proof (prove)\nusing this:\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\n\\<lbrakk>(?a, ?b) \\<in> s; (?b, ?a) \\<in> s\\<rbrakk> \\<Longrightarrow> ?a = ?b\n(s.maxim (SUPP f), z) \\<in> s\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by simp<\\STATESEP>23<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>22<\\TRANSEP>proof (state)\nthis:\nf0 (s.maxim (SUPP f)) = r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\nf0 (s.maxim (SUPP f)) = r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>have \"f (s.maxim (SUPP f)) \\<noteq> r.zero\"<\\STATESEP>20<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. f (s.maxim (SUPP f)) \\<noteq> r.zero<\\STATESEP>using bspec[OF maxF(1) f, unfolded s.isMaxim_def]<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\ns.maxim (SUPP f) \\<in> SUPP f \\<and> (\\<forall>a\\<in>SUPP f. (a, s.maxim (SUPP f)) \\<in> s)\n\ngoal (1 subgoal):\n 1. f (s.maxim (SUPP f)) \\<noteq> r.zero<\\STATESEP>by (auto simp: support_def)<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>with f0f * f f0 maxf0 SUPPF<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero<\\STATESEP>have \"s.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\"<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)<\\STATESEP>unfolding max_fun_diff_alt<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = s.maxim (SUPP f0 \\<union> SUPP f)<\\STATESEP>using s.maxim_Un[of \"SUPP f0\" \"SUPP f\"]<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf (s.maxim (SUPP f)) \\<noteq> r.zero\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = s.max2 (s.maxim (SUPP f0)) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. s.maxim ((SUPP f0 \\<union> SUPP f) \\<inter> {a. f0 a \\<noteq> f a}) = s.maxim (SUPP f0 \\<union> SUPP f)<\\STATESEP>by (intro s.maxim_Int) (auto simp: s.max2_def)<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>moreover<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>have \"s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\"<\\STATESEP>20<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)<\\STATESEP>using s.maxim_Un[of \"SUPP f0\" \"SUPP f\"] * maxf0 SUPPF f0 f<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>finite (SUPP f0); SUPP f0 \\<noteq> {}; SUPP f0 \\<subseteq> Field s; finite (SUPP f); SUPP f \\<noteq> {}; SUPP f \\<subseteq> Field s\\<rbrakk> \\<Longrightarrow> s.maxim (SUPP f0 \\<union> SUPP f) = s.max2 (s.maxim (SUPP f0)) (s.maxim (SUPP f))\n(z, s.maxim (SUPP f)) \\<in> s\nz \\<noteq> s.maxim (SUPP f)\ns.maxim (SUPP f0) = z\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\nf0 \\<in> F\nf \\<in> F\n\ngoal (1 subgoal):\n 1. s.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)<\\STATESEP>by (auto simp: s.max2_def)<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (s.maxim (SUPP f) = z \\<and> f z = x0); s.maxim (SUPP f) \\<noteq> z\\<rbrakk> \\<Longrightarrow> (f0, f) \\<in> oexp<\\STATESEP>ultimately<\\STATESEP>20<\\TRANSEP>proof (chain)\npicking this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)<\\STATESEP>show ?thesis<\\STATESEP>20<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>using f f0 F(1) maxF(1) SUPPF<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> oexp<\\STATESEP>unfolding oexp_def Let_def<\\STATESEP>21<\\TRANSEP>proof (prove)\nusing this:\nf0 (s.maxim (SUPP f)) = r.zero\ns.max_fun_diff f0 f = s.maxim (SUPP f0 \\<union> SUPP f)\ns.maxim (SUPP f0 \\<union> SUPP f) = s.maxim (SUPP f)\nf \\<in> F\nf0 \\<in> F\nF \\<subseteq> FINFUNC\n\\<forall>f\\<in>F. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\\<forall>f\\<in>F. finite (SUPP f) \\<and> SUPP f \\<noteq> {} \\<and> SUPP f \\<subseteq> Field s\n\ngoal (1 subgoal):\n 1. (f0, f) \\<in> {(f, g). f \\<in> FINFUNC \\<and> g \\<in> FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by (fastforce simp: s.isMaxim_def intro!: r.zero_smallest FINFUNCD)<\\STATESEP>21<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>20<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>18<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>16<\\TRANSEP>proof (state)\nthis:\n(f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>14<\\TRANSEP>proof (state)\nthis:\n\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<subseteq> FINFUNC; f \\<in> F; y = s.maxim (SUPP f); const \\<in> F\\<rbrakk> \\<Longrightarrow> \\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp<\\STATESEP>qed simp<\\STATESEP>12<\\TRANSEP>proof (state)\nthis:\n\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nF \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nF \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>F. y = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>F. \\<forall>f\\<in>F. (f0, f) \\<in> oexp)\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n?F3 \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>?F3. ?y3 = s.maxim (SUPP f)) \\<longrightarrow> (\\<exists>f0\\<in>?F3. \\<forall>f\\<in>?F3. (f0, f) \\<in> oexp)\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>note * = mp[OF this]<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?F4 \\<subseteq> FINFUNC \\<and> (\\<exists>f\\<in>?F4. ?y4 = s.maxim (SUPP f)) \\<Longrightarrow> \\<exists>f0\\<in>?F4. \\<forall>f\\<in>?F4. (f0, f) \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>from A(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nA \\<noteq> {}<\\STATESEP>obtain f where f: \"f \\<in> A\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nf \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A. \\<lbrakk>A \\<subseteq> FINFUNC; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>with A(1)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nA \\<subseteq> FINFUNC\nf \\<in> A<\\STATESEP>show \"\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nA \\<subseteq> FINFUNC\nf \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>proof (cases \"f = const\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n 2. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f \\<noteq> const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nf \\<noteq> const\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n 2. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f \\<noteq> const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>with f A(1)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const<\\STATESEP>show ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>using maxim_isMaxim_support[of \"{f}\"]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nf \\<in> A\nA \\<subseteq> FINFUNC\nf \\<noteq> const\n\\<lbrakk>{f} \\<subseteq> FINFUNC; const \\<notin> {f}\\<rbrakk> \\<Longrightarrow> \\<forall>f\\<in>{f}. s.isMaxim (SUPP f) (s.maxim (SUPP f))\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>by (intro *[of _ \"s.maxim (SUPP f)\"]) (auto simp: s.isMaxim_def support_def)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> FINFUNC; f \\<in> A; f = const\\<rbrakk> \\<Longrightarrow> \\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp<\\STATESEP>qed simp<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n\\<exists>a\\<in>A. \\<forall>a'\\<in>A. (a, a') \\<in> oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nwf (oexp - Id)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_Well_order: \"Well_order oexp\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order oexp<\\STATESEP>unfolding well_order_on_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Linear_order oexp \\<and> wf (oexp - Id)<\\STATESEP>using oexp_Linear_order oexp_wf_Id<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nLinear_order oexp\nwf (oexp - Id)\n\ngoal (1 subgoal):\n 1. Linear_order oexp \\<and> wf (oexp - Id)<\\STATESEP>by blast<\\STATESEP>1<\\TRANSEP><\\STATESEP>interpretation o: wo_rel oexp<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel oexp<\\STATESEP>by unfold_locales (rule oexp_Well_order)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma zero_oexp: \"Field r \\<noteq> {} \\<Longrightarrow> o.zero = const\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} \\<Longrightarrow> o.zero = const<\\STATESEP>by (rule sym[OF o.leq_zero_imp[OF const_least]])\n    (auto intro!: o.zero_in_Field[unfolded Field_oexp] dest!: const_FINFUNC)<\\STATESEP>1<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>notation wo_rel2.oexp (infixl \"^o\" 90)<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemmas oexp_def = wo_rel2.oexp_def[unfolded wo_rel2_def, OF conjI]<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemmas oexp_Well_order = wo_rel2.oexp_Well_order[unfolded wo_rel2_def, OF conjI]<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemmas Field_oexp = wo_rel2.Field_oexp[unfolded wo_rel2_def, OF conjI]<\\STATESEP>0<\\TRANSEP><\\STATESEP>definition \"ozero = {}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma ozero_Well_order[simp]: \"Well_order ozero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order ozero<\\STATESEP>unfolding ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order {}<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma ozero_ordIso[simp]: \"ozero =o ozero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ozero =o ozero<\\STATESEP>unfolding ozero_def ordIso_def iso_def[abs_def] embed_def bij_betw_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ({}, {}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f (under r a) \\<and> f ` under r a = under r' (f a)) \\<and> inj_on f (Field r) \\<and> f ` Field r = Field r')}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma Field_ozero[simp]: \"Field ozero = {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field ozero = {}<\\STATESEP>unfolding ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field {} = {}<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma iso_ozero_empty[simp]: \"r =o ozero = (r = {})\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (r =o ozero) = (r = {})<\\STATESEP>unfolding ozero_def ordIso_def iso_def[abs_def] embed_def bij_betw_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ((r, {}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f (under r a) \\<and> f ` under r a = under r' (f a)) \\<and> inj_on f (Field r) \\<and> f ` Field r = Field r')}) = (r = {})<\\STATESEP>by (auto dest: well_order_on_domain)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma ozero_ordLeq:\nassumes \"Well_order r\"  shows \"ozero \\<le>o r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ozero \\<le>o r<\\STATESEP>using assms<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ozero \\<le>o r<\\STATESEP>unfolding ozero_def ordLeq_def embed_def[abs_def] under_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ({}, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. bij_betw f {b. (b, a) \\<in> r} {b. (b, f a) \\<in> r'})}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>definition \"oone = {((),())}\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma oone_Well_order[simp]: \"Well_order oone\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order oone<\\STATESEP>unfolding oone_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order {((), ())}<\\STATESEP>unfolding well_order_on_def linear_order_on_def partial_order_on_def\n    preorder_on_def total_on_def refl_on_def trans_def antisym_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (((({((), ())} \\<subseteq> Field {((), ())} \\<times> Field {((), ())} \\<and> (\\<forall>x\\<in>Field {((), ())}. (x, x) \\<in> {((), ())})) \\<and> (\\<forall>x y z. (x, y) \\<in> {((), ())} \\<longrightarrow> (y, z) \\<in> {((), ())} \\<longrightarrow> (x, z) \\<in> {((), ())})) \\<and> (\\<forall>x y. (x, y) \\<in> {((), ())} \\<longrightarrow> (y, x) \\<in> {((), ())} \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field {((), ())}. \\<forall>y\\<in>Field {((), ())}. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> {((), ())} \\<or> (y, x) \\<in> {((), ())})) \\<and> wf ({((), ())} - Id)<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma Field_oone[simp]: \"Field oone = {()}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field oone = {()}<\\STATESEP>unfolding oone_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field {((), ())} = {()}<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oone_ordIso: \"oone =o {(x,x)}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. oone =o {(x, x)}<\\STATESEP>unfolding ordIso_def oone_def well_order_on_def linear_order_on_def partial_order_on_def\n    preorder_on_def total_on_def refl_on_def trans_def antisym_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ({((), ())}, {(x, x)}) \\<in> {(r, r'). (((((r \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r)) \\<and> (\\<forall>x y z. (x, y) \\<in> r \\<longrightarrow> (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r)) \\<and> (\\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r)) \\<and> wf (r - Id)) \\<and> (((((r' \\<subseteq> Field r' \\<times> Field r' \\<and> (\\<forall>x\\<in>Field r'. (x, x) \\<in> r')) \\<and> (\\<forall>x y z. (x, y) \\<in> r' \\<longrightarrow> (y, z) \\<in> r' \\<longrightarrow> (x, z) \\<in> r')) \\<and> (\\<forall>x y. (x, y) \\<in> r' \\<longrightarrow> (y, x) \\<in> r' \\<longrightarrow> x = y)) \\<and> (\\<forall>x\\<in>Field r'. \\<forall>y\\<in>Field r'. x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r' \\<or> (y, x) \\<in> r')) \\<and> wf (r' - Id)) \\<and> Ex (iso r r')}<\\STATESEP>by (auto simp: iso_def embed_def bij_betw_def under_def inj_on_def intro!: exI[of _ \"\\<lambda>_. x\"])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_ordLeqR: \"Well_order r \\<Longrightarrow> Well_order s \\<Longrightarrow> s \\<le>o r +o s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order s\\<rbrakk> \\<Longrightarrow> s \\<le>o r +o s<\\STATESEP>unfolding ordLeq_def2 underS_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Well_order r; Well_order s\\<rbrakk> \\<Longrightarrow> Well_order s \\<and> Well_order (r +o s) \\<and> (\\<exists>f. \\<forall>a\\<in>Field s. f a \\<in> Field (r +o s) \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> s} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> r +o s})<\\STATESEP>by (auto intro!: exI[of _ Inr] osum_Well_order) (auto simp add: osum_def Field_def)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r +o t =o s +o t\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr =o s<\\STATESEP>obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>let ?f = \"map_sum f id\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_sum f id) (Field (r +o t))<\\STATESEP>unfolding Field_osum iso_def bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field t. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field t. map_sum f id x = map_sum f id y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_sum f id) (Field (r +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>with f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f\ninj_on (map_sum f id) (Field (r +o t))<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\ninj_on (map_sum f id) (Field (r +o t))\n\ngoal (1 subgoal):\n 1. bij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))<\\STATESEP>unfolding Field_osum iso_def bij_betw_def image_image image_Un<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_sum f id) (Inl ` Field r \\<union> Inr ` Field t)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum f id) (Inl ` Field r \\<union> Inr ` Field t) \\<and> (\\<lambda>x. map_sum f id (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum f id (Inr x)) ` Field t = Inl ` Field s \\<union> Inr ` Field t<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (r +o t) (s +o t) (map_sum f id)<\\STATESEP>unfolding osum_def iso_iff3[OF r s] compat_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field t} \\<longrightarrow> (map_sum f id a, map_sum f id b) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t}<\\STATESEP>by (auto simp: map_prod_imageI)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\ncompat (r +o t) (s +o t) (map_sum f id)<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (map_sum f id) (Field (r +o t)) (Field (s +o t))\ncompat (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. iso (r +o t) (s +o t) (map_sum f id)<\\STATESEP>by (subst iso_iff3) (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. r +o t =o s +o t<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r +o t) (s +o t) (map_sum f id)\n\ngoal (1 subgoal):\n 1. (r +o t, s +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr +o t =o s +o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t +o r =o t +o s\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr =o s<\\STATESEP>obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>let ?f = \"map_sum id f\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Field (t +o r))<\\STATESEP>unfolding Field_osum iso_def bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field t \\<union> Inr ` Field r. \\<forall>y\\<in>Inl ` Field t \\<union> Inr ` Field r. map_sum id f x = map_sum id f y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_sum id f) (Field (t +o r))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>with f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f\ninj_on (map_sum id f) (Field (t +o r))<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\ninj_on (map_sum id f) (Field (t +o r))\n\ngoal (1 subgoal):\n 1. bij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))<\\STATESEP>unfolding Field_osum iso_def bij_betw_def image_image image_Un<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_sum id f) (Inl ` Field t \\<union> Inr ` Field r)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Inl ` Field t \\<union> Inr ` Field r) \\<and> (\\<lambda>x. map_sum id f (Inl x)) ` Field t \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field r = Inl ` Field t \\<union> Inr ` Field s<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (t +o r) (t +o s) (map_sum id f)<\\STATESEP>unfolding osum_def iso_iff3[OF r s] compat_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> map_prod Inl Inl ` t \\<union> map_prod Inr Inr ` r \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field t \\<and> a' \\<in> Field r} \\<longrightarrow> (map_sum id f a, map_sum id f b) \\<in> map_prod Inl Inl ` t \\<union> map_prod Inr Inr ` s \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field t \\<and> a' \\<in> Field s}<\\STATESEP>by (auto simp: map_prod_imageI)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\ncompat (t +o r) (t +o s) (map_sum id f)<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (map_sum id f) (Field (t +o r)) (Field (t +o s))\ncompat (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. iso (t +o r) (t +o s) (map_sum id f)<\\STATESEP>by (subst iso_iff3) (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. t +o r =o t +o s<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (t +o r) (t +o s) (map_sum id f)\n\ngoal (1 subgoal):\n 1. (t +o r, t +o s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nt +o r =o t +o s\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t +o r =o u +o s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. t +o r =o u +o s<\\STATESEP>using ordIso_transitive[OF osum_congL[OF assms(1)] osum_congR[OF assms(2)]]\n  assms[unfolded ordIso_def]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Well_order r; Well_order u\\<rbrakk> \\<Longrightarrow> t +o r =o u +o s\n(t, u) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. t +o r =o u +o s<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma Well_order_empty[simp]: \"Well_order {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Well_order {}<\\STATESEP>unfolding Field_empty<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. well_order_on {} {}<\\STATESEP>by (rule well_order_on_empty)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma well_order_on_singleton[simp]: \"well_order_on {x} {(x, x)}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. well_order_on {x} {(x, x)}<\\STATESEP>unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def total_on_def\n    Field_def refl_on_def trans_def antisym_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (((({(x, x)} \\<subseteq> {x} \\<times> {x} \\<and> (\\<forall>xa\\<in>{x}. (xa, xa) \\<in> {(x, x)})) \\<and> (\\<forall>xa y z. (xa, y) \\<in> {(x, x)} \\<longrightarrow> (y, z) \\<in> {(x, x)} \\<longrightarrow> (xa, z) \\<in> {(x, x)})) \\<and> (\\<forall>xa y. (xa, y) \\<in> {(x, x)} \\<longrightarrow> (y, xa) \\<in> {(x, x)} \\<longrightarrow> xa = y)) \\<and> (\\<forall>xa\\<in>{x}. \\<forall>y\\<in>{x}. xa \\<noteq> y \\<longrightarrow> (xa, y) \\<in> {(x, x)} \\<or> (y, xa) \\<in> {(x, x)})) \\<and> wf ({(x, x)} - Id)<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_empty[simp]:\n  assumes \"Well_order r\"\n  shows \"r ^o {} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o {} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}<\\STATESEP>unfolding oexp_def[OF assms Well_order_empty] FinFunc_def fin_support_def support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> Func (Field {}) (Field r) \\<inter> {f. finite {x \\<in> Field {}. f x \\<noteq> zero r}} \\<and> g \\<in> Func (Field {}) (Field r) \\<inter> {f. finite {x \\<in> Field {}. f x \\<noteq> zero r}} \\<and> ((let m = wo_rel.max_fun_diff {} f g in (f m, g m) \\<in> r) \\<or> f = g)} = {(\\<lambda>x. undefined, \\<lambda>x. undefined)}<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_empty2[simp]:\n  assumes \"Well_order r\" \"r \\<noteq> {}\"\n  shows \"{} ^o r = {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {} ^o r = {}<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. {} ^o r = {}<\\STATESEP>from assms(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr \\<noteq> {}<\\STATESEP>have \"Field r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}<\\STATESEP>unfolding Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {} ^o r = {}<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {} ^o r = {}<\\STATESEP>unfolding oexp_def[OF Well_order_empty assms(1)] FinFunc_def fin_support_def support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {(f, g). f \\<in> Func (Field r) (Field {}) \\<inter> {f. finite {x \\<in> Field r. f x \\<noteq> zero {}}} \\<and> g \\<in> Func (Field r) (Field {}) \\<inter> {f. finite {x \\<in> Field r. f x \\<noteq> zero {}}} \\<and> ((let m = wo_rel.max_fun_diff r f g in (f m, g m) \\<in> {}) \\<or> f = g)} = {}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n{} ^o r = {}\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_zero[simp]: \"{} *o r = {}\" \"r *o {} = {}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {} *o r = {} &&& r *o {} = {}<\\STATESEP>unfolding oprod_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field {} \\<and> x2 \\<in> Field {} \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> {}} = {} &&& {((x1, y1), x2, y2). (y1, y2) \\<in> {} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field {}) \\<and> (x1, x2) \\<in> r} = {}<\\STATESEP>by simp_all<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_congL:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"r *o t =o s *o t\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr =o s<\\STATESEP>obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>let ?f = \"map_prod f id\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_prod f id) (Field (r *o t))<\\STATESEP>unfolding Field_oprod iso_def bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r \\<times> Field t. \\<forall>y\\<in>Field r \\<times> Field t. map_prod f id x = map_prod f id y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_prod f id) (Field (r *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>with f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f\ninj_on (map_prod f id) (Field (r *o t))<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\ninj_on (map_prod f id) (Field (r *o t))\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))<\\STATESEP>unfolding Field_oprod iso_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_prod f id) (Field r \\<times> Field t)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod f id) (Field r \\<times> Field t) \\<and> map_prod f id ` (Field r \\<times> Field t) = Field s \\<times> Field t<\\STATESEP>by (auto intro!: map_prod_surj_on)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. compat (r *o t) (s *o t) (map_prod f id)<\\STATESEP>unfolding iso_iff3[OF r s] compat_def oprod_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (map_prod f id a, map_prod f id b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}<\\STATESEP>by (auto simp: map_prod_imageI)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\ncompat (r *o t) (s *o t) (map_prod f id)<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (map_prod f id) (Field (r *o t)) (Field (s *o t))\ncompat (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. iso (r *o t) (s *o t) (map_prod f id)<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. r *o t =o s *o t<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r *o t) (s *o t) (map_prod f id)\n\ngoal (1 subgoal):\n 1. (r *o t, s *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr *o t =o s *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_congR:\n  assumes \"r =o s\" and t: \"Well_order t\"\n  shows \"t *o r =o t *o s\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr =o s<\\STATESEP>obtain f where r: \"Well_order r\" and s: \"Well_order s\" and f: \"iso r s f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr =o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order r; Well_order s; iso r s f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order r\nWell_order s\niso r s f\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>let ?f = \"map_prod id f\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field (t *o r))<\\STATESEP>unfolding Field_oprod iso_def bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> (\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y) \\<and> f ` Field r = Field s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field t \\<times> Field r. \\<forall>y\\<in>Field t \\<times> Field r. map_prod id f x = map_prod id f y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_prod id f) (Field (t *o r))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>with f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f\ninj_on (map_prod id f) (Field (t *o r))<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\ninj_on (map_prod id f) (Field (t *o r))\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))<\\STATESEP>unfolding Field_oprod iso_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed r s f \\<and> inj_on f (Field r) \\<and> f ` Field r = Field s\ninj_on (map_prod id f) (Field t \\<times> Field r)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field t \\<times> Field r) \\<and> map_prod id f ` (Field t \\<times> Field r) = Field t \\<times> Field s<\\STATESEP>by (auto intro!: map_prod_surj_on)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>from f well_order_on_domain[OF r]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\niso r s f\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso r s f\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. compat (t *o r) (t *o s) (map_prod id f)<\\STATESEP>unfolding iso_iff3[OF r s] compat_def oprod_def bij_betw_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(inj_on f (Field r) \\<and> f ` Field r = Field s) \\<and> (\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s)\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field t \\<and> x2 \\<in> Field t \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> t} \\<longrightarrow> (map_prod id f a, map_prod id f b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field t \\<and> x2 \\<in> Field t \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> t}<\\STATESEP>by (auto simp: map_prod_imageI dest: inj_onD)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\ncompat (t *o r) (t *o s) (map_prod id f)<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (map_prod id f) (Field (t *o r)) (Field (t *o s))\ncompat (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. iso (t *o r) (t *o s) (map_prod id f)<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. t *o r =o t *o s<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (t *o r) (t *o s) (map_prod id f)\n\ngoal (1 subgoal):\n 1. (t *o r, t *o s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nt *o r =o t *o s\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_cong:\n  assumes \"t =o u\" and \"r =o s\"\n  shows \"t *o r =o u *o s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. t *o r =o u *o s<\\STATESEP>using ordIso_transitive[OF oprod_congL[OF assms(1)] oprod_congR[OF assms(2)]]\n  assms[unfolded ordIso_def]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Well_order r; Well_order u\\<rbrakk> \\<Longrightarrow> t *o r =o u *o s\n(t, u) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. t *o r =o u *o s<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma Field_singleton[simp]: \"Field {(z,z)} = {z}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field {(z, z)} = {z}<\\STATESEP>by (metis well_order_on_Field well_order_on_singleton)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma zero_singleton[simp]: \"zero {(z,z)} = z\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. zero {(z, z)} = z<\\STATESEP>using wo_rel.zero_in_Field[unfolded wo_rel_def, of \"{(z, z)}\"] well_order_on_singleton[of z]<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>Well_order {(z, z)}; Field {(z, z)} \\<noteq> {}\\<rbrakk> \\<Longrightarrow> zero {(z, z)} \\<in> Field {(z, z)}\nwell_order_on {z} {(z, z)}\n\ngoal (1 subgoal):\n 1. zero {(z, z)} = z<\\STATESEP>by auto<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma FinFunc_singleton: \"FinFunc {(z,z)} s = {\\<lambda>x. if x \\<in> Field s then z else undefined}\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. FinFunc {(z, z)} s = {\\<lambda>x. if x \\<in> Field s then z else undefined}<\\STATESEP>unfolding FinFunc_def Func_def fin_support_def support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. {f. (\\<forall>a\\<in>Field s. f a \\<in> Field {(z, z)}) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero {(z, z)}}} = {\\<lambda>x. if x \\<in> Field s then z else undefined}<\\STATESEP>by (auto simp: fun_eq_iff split: if_split_asm intro!: finite_subset[of _ \"{}\"])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oone_ordIso_oexp:\n  assumes \"r =o oone\" and s: \"Well_order s\"\n  shows \"r ^o s =o oone\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>from \\<open>r =o oone\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr =o oone<\\STATESEP>obtain f where *: \"\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\" and \"f ` Field r = {()}\"\n    and r: \"Well_order r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr =o oone\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y; f ` Field r = {()}; Well_order r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordIso_def oone_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(r, {((), ())}) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y; f ` Field r = {()}; Well_order r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (auto simp add: iso_def [abs_def] bij_betw_def inj_on_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r\n\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>then<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r<\\STATESEP>obtain x where \"x \\<in> Field r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nf ` Field r = {()}\nWell_order r\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> Field r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>with *<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nx \\<in> Field r<\\STATESEP>have Fr: \"Field r = {x}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. x = y\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. Field r = {x}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r = {x}\n\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>interpret r: wo_rel r<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r<\\STATESEP>by unfold_locales (rule r)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>from Fr well_order_on_domain[OF r] refl_onD[OF r.REFL, of x]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nField r = {x}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r<\\STATESEP>have r_def: \"r = {(x, x)}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r = {x}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\nx \\<in> Field r \\<Longrightarrow> (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(x, x)}<\\STATESEP>by fast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr = {(x, x)}\n\ngoal (1 subgoal):\n 1. r ^o s =o oone<\\STATESEP>interpret wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>have \"bij_betw (\\<lambda>x. ()) (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)<\\STATESEP>unfolding bij_betw_def Field_oexp<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. ()) FINFUNC \\<and> (\\<lambda>x. ()) ` FINFUNC = Field oone<\\STATESEP>by (auto simp: r_def FinFunc_singleton)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>have \"compat ?L ?R (\\<lambda>x. ())\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat oexp oone (\\<lambda>x. ())<\\STATESEP>unfolding compat_def oone_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> oexp \\<longrightarrow> ((), ()) \\<in> {((), ())}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())<\\STATESEP>have \"iso ?L ?R (\\<lambda>x. ())\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. iso oexp oone (\\<lambda>x. ())<\\STATESEP>using s oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>x. ()) (Field oexp) (Field oone)\ncompat oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso oexp oone (\\<lambda>x. ())<\\STATESEP>by (subst iso_iff3) (auto intro: oexp_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>using s oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. oexp =o oone<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso oexp oone (\\<lambda>x. ())\nWell_order s\nWell_order oone\n\ngoal (1 subgoal):\n 1. (oexp, oone) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oexp_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\noexp =o oone\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>context\n  fixes r s t\n  assumes r: \"Well_order r\"\n  assumes s: \"Well_order s\"\n  assumes t: \"Well_order t\"\nbegin<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma osum_ozeroL: \"ozero +o r =o r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ozero +o r =o r<\\STATESEP>using r<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. ozero +o r =o r<\\STATESEP>unfolding osum_def ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` {} \\<union> map_prod Inr Inr ` r \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field {} \\<and> a' \\<in> Field r} =o r<\\STATESEP>by (auto intro: map_prod_ordIso)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_ozeroR: \"r +o ozero =o r\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r +o ozero =o r<\\STATESEP>using r<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. r +o ozero =o r<\\STATESEP>unfolding osum_def ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nWell_order r\n\ngoal (1 subgoal):\n 1. map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` {} \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field {}} =o r<\\STATESEP>by (auto intro: map_prod_ordIso)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma osum_assoc: \"(r +o s) +o t =o r +o s +o t\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>let ?f =\n    \"\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))<\\STATESEP>unfolding Field_osum bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t. \\<forall>y\\<in>Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t. (case x of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) = (case y of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<longrightarrow> x = y) \\<and> case_sum (case_sum Inl (\\<lambda>s. Inr (Inl s))) (\\<lambda>t. Inr (Inr t)) ` (Inl ` (Inl ` Field r \\<union> Inr ` Field s) \\<union> Inr ` Field t) = Inl ` Field r \\<union> Inr ` (Inl ` Field s \\<union> Inr ` Field t)<\\STATESEP>by (auto simp: image_Un image_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))<\\STATESEP>proof (unfold compat_def, safe)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t<\\STATESEP>fix a b<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t<\\STATESEP>assume \"(a, b) \\<in> ?L\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(a, b) \\<in> (r +o s) +o t\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> (r +o s) +o t \\<Longrightarrow> (case a of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl xa) \\<Rightarrow> Inl xa | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t<\\STATESEP>thus \"(?f a, ?f b) \\<in> ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> (r +o s) +o t\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t<\\STATESEP>unfolding osum_def[of \"r +o s\" t] osum_def[of r \"s +o t\"] Field_osum<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> map_prod Inl Inl ` (r +o s) \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Inl ` Field r \\<union> Inr ` Field s \\<and> a' \\<in> Field t}\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> map_prod Inl Inl ` r \\<union> map_prod Inr Inr ` (s +o t) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Inl ` Field s \\<union> Inr ` Field t}<\\STATESEP>unfolding osum_def Field_osum image_iff image_Un map_prod_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inl x, Inl y)) ` (\\<lambda>(x, y). (Inr x, Inr y)) ` s \\<union> (\\<lambda>(x, y). (Inl x, Inl y)) ` {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field s} \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Inl ` Field r \\<union> Inr ` Field s \\<and> a' \\<in> Field t}\n\ngoal (1 subgoal):\n 1. (case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> ((\\<lambda>(x, y). (Inr x, Inr y)) ` (\\<lambda>(x, y). (Inl x, Inl y)) ` s \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t}) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Inl ` Field s \\<union> Inr ` Field t}<\\STATESEP>by fastforce<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(case a of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t), case b of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) \\<in> r +o s +o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. iso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t)) (Field ((r +o s) +o t)) (Field (r +o s +o t))\ncompat ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))<\\STATESEP>by (subst iso_iff3) (auto intro: osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r +o s) +o t =o r +o s +o t<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso ((r +o s) +o t) (r +o s +o t) (\\<lambda>rst. case rst of Inl (Inl r) \\<Rightarrow> Inl r | Inl (Inr s) \\<Rightarrow> Inr (Inl s) | Inr t \\<Rightarrow> Inr (Inr t))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. ((r +o s) +o t, r +o s +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(r +o s) +o t =o r +o s +o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_monoR:\n  assumes \"s <o t\"\n  shows \"r +o s <o r +o t\" (is \"?L <o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ns <o t<\\STATESEP>obtain f where s: \"Well_order s\" and t:\" Well_order t\" and \"embedS s t f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>unfolding embedS_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nofilter t (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>let ?f = \"map_sum id f\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>from *(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ninj_on f (Field s)<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninj_on f (Field s)\n\ngoal (1 subgoal):\n 1. inj_on (map_sum id f) (Field (r +o s))<\\STATESEP>unfolding Field_osum inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x\\<in>Field s. \\<forall>y\\<in>Field s. f x = f y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Inl ` Field r \\<union> Inr ` Field s. \\<forall>y\\<in>Inl ` Field r \\<union> Inr ` Field s. map_sum id f x = map_sum id f y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_sum id f) (Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ninj_on (map_sum id f) (Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>from *(2,4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncompat s t f\nf ` Field s \\<subset> Field t<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncompat s t f\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. compat (r +o s) (r +o t) (map_sum id f)<\\STATESEP>unfolding compat_def osum_def map_prod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` s \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field s} \\<longrightarrow> (map_sum id f a, map_sum id f b) \\<in> (\\<lambda>(x, y). (Inl x, Inl y)) ` r \\<union> (\\<lambda>(x, y). (Inr x, Inr y)) ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<and> a' \\<in> Field t}<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncompat (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>interpret rt: wo_rel ?R<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (r +o t)<\\STATESEP>by unfold_locales (rule osum_Well_order[OF r t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>from *(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nt.ofilter (f ` Field s)<\\STATESEP>have \"ofilter ?R (?f ` Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. rt.ofilter (map_sum id f ` Field (r +o s))<\\STATESEP>unfolding t.ofilter_def rt.ofilter_def Field_osum image_Un image_image under_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s \\<subseteq> Inl ` Field r \\<union> Inr ` Field t \\<and> (\\<forall>a\\<in>(\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s. {b. (b, a) \\<in> r +o t} \\<subseteq> (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s)<\\STATESEP>by (auto simp: osum_def intro!: imageI) (auto simp: Field_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nrt.ofilter (map_sum id f ` Field (r +o s))\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))<\\STATESEP>have \"embed ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))\n\ngoal (1 subgoal):\n 1. embed (r +o s) (r +o t) (map_sum id f)<\\STATESEP>using embed_iff_compat_inj_on_ofilter[of ?L ?R ?f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ninj_on (map_sum id f) (Field (r +o s))\ncompat (r +o s) (r +o t) (map_sum id f)\nrt.ofilter (map_sum id f ` Field (r +o s))\n\\<lbrakk>Well_order (r +o s); Well_order (r +o t)\\<rbrakk> \\<Longrightarrow> embed (r +o s) (r +o t) (map_sum id f) = (compat (r +o s) (r +o t) (map_sum id f) \\<and> inj_on (map_sum id f) (Field (r +o s)) \\<and> rt.ofilter (map_sum id f ` Field (r +o s)))\n\ngoal (1 subgoal):\n 1. embed (r +o s) (r +o t) (map_sum id f)<\\STATESEP>by (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembed (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nembed (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>from *(4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf ` Field s \\<subset> Field t<\\STATESEP>have \"?f ` Field ?L \\<subset> Field ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. map_sum id f ` Field (r +o s) \\<subset> Field (r +o t)<\\STATESEP>unfolding Field_osum image_Un image_image<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. map_sum id f (Inl x)) ` Field r \\<union> (\\<lambda>x. map_sum id f (Inr x)) ` Field s \\<subset> Inl ` Field r \\<union> Inr ` Field t<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)<\\STATESEP>have \"embedS ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\n\ngoal (1 subgoal):\n 1. embedS (r +o s) (r +o t) (map_sum id f)<\\STATESEP>using embedS_iff[OF osum_Well_order[OF r s], of ?R ?f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed (r +o s) (r +o t) (map_sum id f)\nmap_sum id f ` Field (r +o s) \\<subset> Field (r +o t)\nembed (r +o s) (r +o t) (map_sum id f) \\<Longrightarrow> embedS (r +o s) (r +o t) (map_sum id f) = (map_sum id f ` Field (r +o s) \\<subset> Field (r +o t))\n\ngoal (1 subgoal):\n 1. embedS (r +o s) (r +o t) (map_sum id f)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. r +o s <o r +o t<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembedS (r +o s) (r +o t) (map_sum id f)\n\ngoal (1 subgoal):\n 1. (r +o s, r +o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}<\\STATESEP>by (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr +o s <o r +o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma osum_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r +o t \\<le>o s +o t\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr \\<le>o s<\\STATESEP>obtain f where f: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r \\<and> Well_order s \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a))\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>let ?f = \"map_sum f id\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)<\\STATESEP>have \"\\<forall>a\\<in>Field (r +o t).\n     ?f a \\<in> Field (s +o t) \\<and> ?f ` underS (r +o t) a \\<subseteq> underS (s +o t) (?f a)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)<\\STATESEP>unfolding Field_osum underS_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Inl ` Field r \\<union> Inr ` Field t. map_sum f id a \\<in> Inl ` Field s \\<union> Inr ` Field t \\<and> map_sum f id ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r +o t} \\<subseteq> {b. b \\<noteq> map_sum f id a \\<and> (b, map_sum f id a) \\<in> s +o t}<\\STATESEP>by (fastforce simp: osum_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. r +o t \\<le>o s +o t<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r +o t). map_sum f id a \\<in> Field (s +o t) \\<and> map_sum f id ` underS (r +o t) a \\<subseteq> underS (s +o t) (map_sum f id a)\n\ngoal (1 subgoal):\n 1. Well_order (r +o t) \\<and> Well_order (s +o t) \\<and> (\\<exists>f. \\<forall>a\\<in>Field (r +o t). f a \\<in> Field (s +o t) \\<and> f ` underS (r +o t) a \\<subseteq> underS (s +o t) (f a))<\\STATESEP>by (auto intro: osum_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr +o t \\<le>o s +o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_ozeroL: \"ozero *o r =o ozero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. ozero *o r =o ozero<\\STATESEP>using ozero_ordIso<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nozero =o ozero\n\ngoal (1 subgoal):\n 1. ozero *o r =o ozero<\\STATESEP>unfolding ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n{} =o {}\n\ngoal (1 subgoal):\n 1. {} *o r =o {}<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_ozeroR: \"r *o ozero =o ozero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o ozero =o ozero<\\STATESEP>using ozero_ordIso<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\nozero =o ozero\n\ngoal (1 subgoal):\n 1. r *o ozero =o ozero<\\STATESEP>unfolding ozero_def<\\STATESEP>1<\\TRANSEP>proof (prove)\nusing this:\n{} =o {}\n\ngoal (1 subgoal):\n 1. r *o {} =o {}<\\STATESEP>by simp<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oprod_ooneR: \"r *o oone =o r\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>have \"bij_betw fst (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw fst (Field (r *o oone)) (Field r)<\\STATESEP>unfolding Field_oprod bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field r \\<times> Field oone. \\<forall>y\\<in>Field r \\<times> Field oone. fst x = fst y \\<longrightarrow> x = y) \\<and> fst ` (Field r \\<times> Field oone) = Field r<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw fst (Field (r *o oone)) (Field r)\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw fst (Field (r *o oone)) (Field r)\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>have \"compat ?L ?R fst\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat (r *o oone) r fst<\\STATESEP>unfolding compat_def oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> oone - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field oone) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (fst a, fst b) \\<in> r<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst<\\STATESEP>have \"iso ?L ?R fst\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. iso (r *o oone) r fst<\\STATESEP>using r oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw fst (Field (r *o oone)) (Field r)\ncompat (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso (r *o oone) r fst<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (r *o oone) r fst\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>using r oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. r *o oone =o r<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r *o oone) r fst\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. (r *o oone, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr *o oone =o r\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_ooneL: \"oone *o r =o r\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>have \"bij_betw snd (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw snd (Field (oone *o r)) (Field r)<\\STATESEP>unfolding Field_oprod bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field oone \\<times> Field r. \\<forall>y\\<in>Field oone \\<times> Field r. snd x = snd y \\<longrightarrow> x = y) \\<and> snd ` (Field oone \\<times> Field r) = Field r<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw snd (Field (oone *o r)) (Field r)\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw snd (Field (oone *o r)) (Field r)\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>have \"Refl r\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Refl r<\\STATESEP>by (rule wo_rel.REFL[unfolded wo_rel_def, OF r])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nRefl r\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>hence \"compat ?L ?R snd\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nRefl r\n\ngoal (1 subgoal):\n 1. compat (oone *o r) r snd<\\STATESEP>unfolding compat_def oprod_def refl_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr \\<subseteq> Field r \\<times> Field r \\<and> (\\<forall>x\\<in>Field r. (x, x) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> r - Id \\<and> x1 \\<in> Field oone \\<and> x2 \\<in> Field oone \\<or> (y1, y2) \\<in> Restr Id (Field r) \\<and> (x1, x2) \\<in> oone} \\<longrightarrow> (snd a, snd b) \\<in> r<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd<\\STATESEP>have \"iso ?L ?R snd\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. iso (oone *o r) r snd<\\STATESEP>using r oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw snd (Field (oone *o r)) (Field r)\ncompat (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. iso (oone *o r) r snd<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (oone *o r) r snd\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>using r oone_Well_order<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. oone *o r =o r<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (oone *o r) r snd\nWell_order r\nWell_order oone\n\ngoal (1 subgoal):\n 1. (oone *o r, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\noone *o r =o r\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_monoR:\n  assumes \"ozero <o r\" \"s <o t\"\n  shows \"r *o s <o r *o t\" (is \"?L <o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nozero <o r\ns <o t<\\STATESEP>obtain f where s: \"Well_order s\" and t:\" Well_order t\" and \"embedS s t f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nozero <o r\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(ozero, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<lbrakk>Well_order s; Well_order t; embedS s t f\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>unfolding embedS_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order s\nWell_order t\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> ofilter t (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& ofilter t (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nofilter t (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>let ?f = \"map_prod id f\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>from *(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ninj_on f (Field s)<\\STATESEP>have \"inj_on ?f (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninj_on f (Field s)\n\ngoal (1 subgoal):\n 1. inj_on (map_prod id f) (Field (r *o s))<\\STATESEP>unfolding Field_oprod inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>x\\<in>Field s. \\<forall>y\\<in>Field s. f x = f y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field r \\<times> Field s. \\<forall>y\\<in>Field r \\<times> Field s. map_prod id f x = map_prod id f y \\<longrightarrow> x = y<\\STATESEP>by fastforce<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on (map_prod id f) (Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ninj_on (map_prod id f) (Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>from *(2,4) the_inv_into_f_f[OF *(1)]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncompat s t f\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncompat s t f\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. compat (r *o s) (r *o t) (map_prod id f)<\\STATESEP>unfolding compat_def oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r} \\<longrightarrow> (map_prod id f a, map_prod id f b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r}<\\STATESEP>by auto (metis well_order_on_domain t, metis well_order_on_domain s)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncompat (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>interpret rt: wo_rel ?R<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (r *o t)<\\STATESEP>by unfold_locales (rule oprod_Well_order[OF r t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>from *(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nt.ofilter (f ` Field s)<\\STATESEP>have \"ofilter ?R (?f ` Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. rt.ofilter (map_prod id f ` Field (r *o s))<\\STATESEP>unfolding t.ofilter_def rt.ofilter_def Field_oprod under_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. map_prod id f ` (Field r \\<times> Field s) \\<subseteq> Field r \\<times> Field t \\<and> (\\<forall>a\\<in>map_prod id f ` (Field r \\<times> Field s). {b. (b, a) \\<in> r *o t} \\<subseteq> map_prod id f ` (Field r \\<times> Field s))<\\STATESEP>by (auto simp: oprod_def image_iff) (fast | metis r well_order_on_domain)+<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nrt.ofilter (map_prod id f ` Field (r *o s))\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))<\\STATESEP>have \"embed ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))\n\ngoal (1 subgoal):\n 1. embed (r *o s) (r *o t) (map_prod id f)<\\STATESEP>using embed_iff_compat_inj_on_ofilter[of ?L ?R ?f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ninj_on (map_prod id f) (Field (r *o s))\ncompat (r *o s) (r *o t) (map_prod id f)\nrt.ofilter (map_prod id f ` Field (r *o s))\n\\<lbrakk>Well_order (r *o s); Well_order (r *o t)\\<rbrakk> \\<Longrightarrow> embed (r *o s) (r *o t) (map_prod id f) = (compat (r *o s) (r *o t) (map_prod id f) \\<and> inj_on (map_prod id f) (Field (r *o s)) \\<and> rt.ofilter (map_prod id f ` Field (r *o s)))\n\ngoal (1 subgoal):\n 1. embed (r *o s) (r *o t) (map_prod id f)<\\STATESEP>by (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembed (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nembed (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>from not_ordLess_ordIso[OF assms(1)]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n(ozero, r) \\<notin> ordIso<\\STATESEP>have \"r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n(ozero, r) \\<notin> ordIso\n\ngoal (1 subgoal):\n 1. r \\<noteq> {}<\\STATESEP>by (metis ozero_def ozero_ordIso)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>hence \"Field r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}<\\STATESEP>unfolding Field_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>with *(4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}<\\STATESEP>have \"?f ` Field ?L \\<subset> Field ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_prod id f ` Field (r *o s) \\<subset> Field (r *o t)<\\STATESEP>unfolding Field_oprod<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_prod id f ` (Field r \\<times> Field s) \\<subset> Field r \\<times> Field t<\\STATESEP>by auto (metis SigmaD2 SigmaI map_prod_surj_on)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)<\\STATESEP>have \"embedS ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\n\ngoal (1 subgoal):\n 1. embedS (r *o s) (r *o t) (map_prod id f)<\\STATESEP>using embedS_iff[OF oprod_Well_order[OF r s], of ?R ?f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed (r *o s) (r *o t) (map_prod id f)\nmap_prod id f ` Field (r *o s) \\<subset> Field (r *o t)\nembed (r *o s) (r *o t) (map_prod id f) \\<Longrightarrow> embedS (r *o s) (r *o t) (map_prod id f) = (map_prod id f ` Field (r *o s) \\<subset> Field (r *o t))\n\ngoal (1 subgoal):\n 1. embedS (r *o s) (r *o t) (map_prod id f)<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. r *o s <o r *o t<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembedS (r *o s) (r *o t) (map_prod id f)\n\ngoal (1 subgoal):\n 1. (r *o s, r *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}<\\STATESEP>by (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr *o s <o r *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_monoL:\n  assumes \"r \\<le>o s\"\n  shows \"r *o t \\<le>o s *o t\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>from assms<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nr \\<le>o s<\\STATESEP>obtain f where f: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nWell_order r \\<and> Well_order s \\<and> (\\<exists>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a))\n\ngoal (1 subgoal):\n 1. (\\<And>f. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>let ?f = \"map_prod f id\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>from f<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)<\\STATESEP>have \"\\<forall>a\\<in>Field (r *o t).\n     ?f a \\<in> Field (s *o t) \\<and> ?f ` underS (r *o t) a \\<subseteq> underS (s *o t) (?f a)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)<\\STATESEP>unfolding Field_oprod underS_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r \\<times> Field t. map_prod f id a \\<in> Field s \\<times> Field t \\<and> map_prod f id ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r *o t} \\<subseteq> {b. b \\<noteq> map_prod f id a \\<and> (b, map_prod f id a) \\<in> s *o t}<\\STATESEP>unfolding map_prod_def oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> r} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r \\<times> Field t. (case a of (x, y) \\<Rightarrow> (f x, id y)) \\<in> Field s \\<times> Field t \\<and> (\\<lambda>(x, y). (f x, id y)) ` {b. b \\<noteq> a \\<and> (b, a) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r}} \\<subseteq> {b. b \\<noteq> (case a of (x, y) \\<Rightarrow> (f x, id y)) \\<and> (b, case a of (x, y) \\<Rightarrow> (f x, id y)) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. r *o t \\<le>o s *o t<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field (r *o t). map_prod f id a \\<in> Field (s *o t) \\<and> map_prod f id ` underS (r *o t) a \\<subseteq> underS (s *o t) (map_prod f id a)\n\ngoal (1 subgoal):\n 1. Well_order (r *o t) \\<and> Well_order (s *o t) \\<and> (\\<exists>f. \\<forall>a\\<in>Field (r *o t). f a \\<in> Field (s *o t) \\<and> f ` underS (r *o t) a \\<subseteq> underS (s *o t) (f a))<\\STATESEP>by (auto intro: oprod_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr *o t \\<le>o s *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_assoc: \"(r *o s) *o t =o r *o s *o t\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>let ?f = \"\\<lambda>((a,b),c). (a,b,c)\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))<\\STATESEP>unfolding Field_oprod bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>(Field r \\<times> Field s) \\<times> Field t. \\<forall>y\\<in>(Field r \\<times> Field s) \\<times> Field t. (case x of (x, xa) \\<Rightarrow> (case x of (a, b) \\<Rightarrow> \\<lambda>c. (a, b, c)) xa) = (case y of (x, xa) \\<Rightarrow> (case x of (a, b) \\<Rightarrow> \\<lambda>c. (a, b, c)) xa) \\<longrightarrow> x = y) \\<and> (\\<lambda>((a, b), c). (a, b, c)) ` ((Field r \\<times> Field s) \\<times> Field t) = Field r \\<times> Field s \\<times> Field t<\\STATESEP>by (auto simp: image_Un image_iff)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))<\\STATESEP>proof (unfold compat_def, safe)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t<\\STATESEP>fix a1 a2 a3 b1 b2 b3<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t<\\STATESEP>assume \"(((a1, a2), a3), ((b1, b2), b3)) \\<in> ?L\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(((a1, a2), a3), (b1, b2), b3) \\<in> (r *o s) *o t\n\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc. (((a, b), ba), (aa, bb), bc) \\<in> (r *o s) *o t \\<Longrightarrow> ((a, b, ba), aa, bb, bc) \\<in> r *o s *o t<\\STATESEP>thus \"((a1, a2, a3), (b1, b2, b3)) \\<in> ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> (r *o s) *o t\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> r *o s *o t<\\STATESEP>unfolding oprod_def[of \"r *o s\" t] oprod_def[of r \"s *o t\"] Field_oprod<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<times> Field s \\<and> x2 \\<in> Field r \\<times> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r *o s}\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s *o t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s \\<times> Field t) \\<and> (x1, x2) \\<in> r}<\\STATESEP>unfolding oprod_def Field_oprod image_iff image_Un<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(((a1, a2), a3), (b1, b2), b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<times> Field s \\<and> x2 \\<in> Field r \\<times> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r}}\n\ngoal (1 subgoal):\n 1. ((a1, a2, a3), b1, b2, b3) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s \\<times> Field t) \\<and> (x1, x2) \\<in> r}<\\STATESEP>by fast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n((a1, a2, a3), b1, b2, b3) \\<in> r *o s *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. iso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>((a, b), c). (a, b, c)) (Field ((r *o s) *o t)) (Field (r *o s *o t))\ncompat ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r *o s) *o t =o r *o s *o t<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso ((r *o s) *o t) (r *o s *o t) (\\<lambda>((a, b), c). (a, b, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. ((r *o s) *o t, r *o s *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n(r *o s) *o t =o r *o s *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oprod_osum: \"r *o (s +o t) =o r *o s +o r *o t\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>let ?f = \"\\<lambda>(a,bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))<\\STATESEP>unfolding Field_oprod Field_osum bij_betw_def inj_on_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t). \\<forall>y\\<in>Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t). (case x of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) = (case y of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<longrightarrow> x = y) \\<and> (\\<lambda>(a, y). case_sum (\\<lambda>b. Inl (a, b)) (\\<lambda>c. Inr (a, c)) y) ` (Field r \\<times> (Inl ` Field s \\<union> Inr ` Field t)) = Inl ` (Field r \\<times> Field s) \\<union> Inr ` (Field r \\<times> Field t)<\\STATESEP>by (fastforce simp: image_Un image_iff split: sum.splits)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))<\\STATESEP>proof (unfold compat_def, intro allI impI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t<\\STATESEP>fix a b<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t<\\STATESEP>assume \"(a, b) \\<in> ?L\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(a, b) \\<in> r *o (s +o t)\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r *o (s +o t) \\<Longrightarrow> (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t<\\STATESEP>thus \"(?f a, ?f b) \\<in> ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> r *o (s +o t)\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t<\\STATESEP>unfolding oprod_def[of r \"s +o t\"] osum_def[of \"r *o s\" \"r *o t\"] Field_oprod Field_osum<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> s +o t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Inl ` Field s \\<union> Inr ` Field t) \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> map_prod Inl Inl ` (r *o s) \\<union> map_prod Inr Inr ` (r *o t) \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<times> Field s \\<and> a' \\<in> Field r \\<times> Field t}<\\STATESEP>unfolding oprod_def osum_def Field_oprod Field_osum image_iff image_Un<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n(a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t} - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Inl ` Field s \\<union> Inr ` Field t) \\<and> (x1, x2) \\<in> r}\n\ngoal (1 subgoal):\n 1. (case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> map_prod Inl Inl ` {((x1, y1), x2, y2). (y1, y2) \\<in> s - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field s) \\<and> (x1, x2) \\<in> r} \\<union> map_prod Inr Inr ` {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field r \\<and> x2 \\<in> Field r \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> r} \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field r \\<times> Field s \\<and> a' \\<in> Field r \\<times> Field t}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(case a of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c), case b of (a, Inl b) \\<Rightarrow> Inl (a, b) | (a, Inr c) \\<Rightarrow> Inr (a, c)) \\<in> r *o s +o r *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. iso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c)) (Field (r *o (s +o t))) (Field (r *o s +o r *o t))\ncompat (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))<\\STATESEP>by (subst iso_iff3) (auto intro: oprod_Well_order osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. r *o (s +o t) =o r *o s +o r *o t<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (r *o (s +o t)) (r *o s +o r *o t) (\\<lambda>(a, bc). case bc of Inl b \\<Rightarrow> Inl (a, b) | Inr c \\<Rightarrow> Inr (a, c))\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r *o (s +o t), r *o s +o r *o t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oprod_Well_order osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nr *o (s +o t) =o r *o s +o r *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma ozero_oexp: \"\\<not> (s =o ozero) \\<Longrightarrow> ozero ^o s =o ozero\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (s, ozero) \\<notin> ordIso \\<Longrightarrow> ozero ^o s =o ozero<\\STATESEP>unfolding oexp_def[OF ozero_Well_order s] FinFunc_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (s, ozero) \\<notin> ordIso \\<Longrightarrow> {(f, g). f \\<in> Func (Field s) (Field ozero) \\<inter> fin_support (zero ozero) (Field s) \\<and> g \\<in> Func (Field s) (Field ozero) \\<inter> fin_support (zero ozero) (Field s) \\<and> ((let m = wo_rel.max_fun_diff s f g in (f m, g m) \\<in> ozero) \\<or> f = g)} =o ozero<\\STATESEP>by simp (metis Func_emp2 bot.extremum_uniqueI emptyE well_order_on_domain s subrelI)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oone_oexp: \"oone ^o s =o oone\" (is \"?L =o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. oone ^o s =o oone<\\STATESEP>by (rule oone_ordIso_oexp[OF ordIso_reflexive[OF oone_Well_order] s])<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma oexp_monoR:\n  assumes \"oone <o r\" \"s <o t\"\n  shows   \"r ^o s <o r ^o t\" (is \"?L <o ?R\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o s <o r ^o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o s <o r ^o t<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o r ^o t<\\STATESEP>interpret rt: wo_rel2 r t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t<\\STATESEP>by unfold_locales (rule r, rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>interpret rexpt: wo_rel \"r ^o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel rt.oexp<\\STATESEP>by unfold_locales (rule rt.oexp_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>interpret r: wo_rel r<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r<\\STATESEP>by unfold_locales (rule r)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>interpret s: wo_rel s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>have \"Field r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}<\\STATESEP>by (metis assms(1) internalize_ordLess not_psubset_empty)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>assume \"Field r = {r.zero}\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nField r = {r.zero}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>hence \"r = {(r.zero, r.zero)}\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nField r = {r.zero}\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}<\\STATESEP>using refl_onD[OF r.REFL, of r.zero]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nField r = {r.zero}\nr.zero \\<in> Field r \\<Longrightarrow> (r.zero, r.zero) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}<\\STATESEP>unfolding Field_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nDomain r \\<union> Range r = {r.zero}\nr.zero \\<in> Domain r \\<union> Range r \\<Longrightarrow> (r.zero, r.zero) \\<in> r\n\ngoal (1 subgoal):\n 1. r = {(r.zero, r.zero)}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nr = {(r.zero, r.zero)}\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>hence \"r =o oone\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nr = {(r.zero, r.zero)}\n\ngoal (1 subgoal):\n 1. r =o oone<\\STATESEP>by (metis oone_ordIso ordIso_symmetric)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nr =o oone\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>with not_ordLess_ordIso[OF assms(1)]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(oone, r) \\<notin> ordIso\nr =o oone<\\STATESEP>have False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(oone, r) \\<notin> ordIso\nr =o oone\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by (metis ordIso_symmetric)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nField r = {r.zero} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nField r \\<noteq> {}\nField r = {r.zero} \\<Longrightarrow> False<\\STATESEP>obtain x where x: \"x \\<in> Field r\" \"r.zero \\<in> Field r\" \"x \\<noteq> r.zero\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nField r \\<noteq> {}\nField r = {r.zero} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (metis insert_iff r.zero_in_Field subsetI subset_singletonD)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>from assms(2)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ns <o t<\\STATESEP>obtain f where \"embedS s t f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns <o t\n\ngoal (1 subgoal):\n 1. (\\<And>f. embedS s t f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n(s, t) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. embedS s t f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembedS s t f\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>hence *: \"inj_on f (Field s)\" \"compat s t f\" \"ofilter t (f ` Field s)\" \"f ` Field s \\<subset> Field t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembedS s t f\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>using embed_iff_compat_inj_on_ofilter[OF s t, of f] embedS_iff[OF s, of t f]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembedS s t f\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> t.ofilter (f ` Field s))\nembed s t f \\<Longrightarrow> embedS s t f = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>unfolding embedS_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)\nembed s t f = (compat s t f \\<and> inj_on f (Field s) \\<and> t.ofilter (f ` Field s))\nembed s t f \\<Longrightarrow> (embed s t f \\<and> \\<not> bij_betw f (Field s) (Field t)) = (f ` Field s \\<subset> Field t)\n\ngoal (1 subgoal):\n 1. (inj_on f (Field s) &&& compat s t f) &&& t.ofilter (f ` Field s) &&& f ` Field s \\<subset> Field t<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ninj_on f (Field s)\ncompat s t f\nt.ofilter (f ` Field s)\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>note invff = the_inv_into_f_f[OF *(1)] and injfD = inj_onD[OF *(1)]<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\\<lbrakk>f ?x = f ?y; ?x \\<in> Field s; ?y \\<in> Field s\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>define F where [abs_def]: \"F g z =\n    (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z)\n     else if z \\<in> Field t then r.zero else undefined)\" for g z<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nF \\<equiv> \\<lambda>g z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>from *(4) x(2) the_inv_into_f_eq[OF *(1)]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x<\\STATESEP>have FLR: \"F ` Field ?L \\<subseteq> Field ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp<\\STATESEP>unfolding rt.Field_oexp rs.Field_oexp FinFunc_def Func_def fin_support_def support_def F_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\nr.zero \\<in> Field r\n\\<lbrakk>f ?x = ?y; ?x \\<in> Field s\\<rbrakk> \\<Longrightarrow> the_inv_into (Field s) f ?y = ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>g z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) ` ({f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}) \\<subseteq> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}<\\STATESEP>by (fastforce split: option.splits if_split_asm elim!: finite_surj[of _ _ f])<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>have \"inj_on F (Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on F (Field rs.oexp)<\\STATESEP>unfolding rs.Field_oexp inj_on_def fun_eq_iff<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>rs.FINFUNC. \\<forall>y\\<in>rs.FINFUNC. (\\<forall>xa. F x xa = F y xa) \\<longrightarrow> (\\<forall>xa. x xa = y xa)<\\STATESEP>proof safe<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa<\\STATESEP>fix g h x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa<\\STATESEP>assume \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r s\" \"\\<forall>y. F g y = F h y\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa. \\<lbrakk>x \\<in> rs.FINFUNC; y \\<in> rs.FINFUNC; \\<forall>xa. F x xa = F y xa\\<rbrakk> \\<Longrightarrow> x xa = y xa<\\STATESEP>with invff<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y<\\STATESEP>show \"g x = h x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n\\<forall>y. F g y = F h y\n\ngoal (1 subgoal):\n 1. g x = h x<\\STATESEP>unfolding F_def fun_eq_iff FinFunc_def Func_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ng \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\nh \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field s)\n\\<forall>y. (if y \\<in> f ` Field s then g (the_inv_into (Field s) f y) else if y \\<in> Field t then r.zero else undefined) = (if y \\<in> f ` Field s then h (the_inv_into (Field s) f y) else if y \\<in> Field t then r.zero else undefined)\n\ngoal (1 subgoal):\n 1. g x = h x<\\STATESEP>by auto (metis image_eqI)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng x = h x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ninj_on F (Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ninj_on F (Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>have \"compat ?L ?R F\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat rs.oexp rt.oexp F<\\STATESEP>unfolding compat_def rs.oexp_def rt.oexp_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((let m = s.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)} \\<longrightarrow> (F a, F b) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}<\\STATESEP>proof (safe elim!: bspec[OF iffD1[OF image_subset_iff FLR[unfolded rs.Field_oexp rt.Field_oexp]]])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>fix g h<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>assume gh: \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r s\" \"F g \\<noteq> F h\"\n      \"let m = s.max_fun_diff g h in (g m, h m) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>hence \"g \\<noteq> h\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n\ngoal (1 subgoal):\n 1. g \\<noteq> h<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng \\<noteq> h\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>note max_fun_diff_in = rs.max_fun_diff_in[OF \\<open>g \\<noteq> h\\<close> gh(1,2)]\n    and max_fun_diff_max = rs.max_fun_diff_max[OF \\<open>g \\<noteq> h\\<close> gh(1,2)]<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>with *(4) invff *(2)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ncompat s t f\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s<\\STATESEP>have \"t.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ncompat s t f\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)<\\STATESEP>unfolding t.max_fun_diff_def compat_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\\<forall>a b. (a, b) \\<in> s \\<longrightarrow> (f a, f b) \\<in> t\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\n?x \\<in> {a \\<in> Field s. g a \\<noteq> h a} \\<Longrightarrow> (?x, s.max_fun_diff g h) \\<in> s\n\ngoal (1 subgoal):\n 1. t.maxim {a \\<in> Field t. F g a \\<noteq> F h a} = f (s.max_fun_diff g h)<\\STATESEP>by (intro t.maxim_equality) (auto simp: t.isMaxim_def F_def dest: injfD)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rs.FINFUNC; let m = s.max_fun_diff a b in (a m, b m) \\<in> r; F a \\<noteq> F b\\<rbrakk> \\<Longrightarrow> let m = t.max_fun_diff (F a) (F b) in (F a m, F b m) \\<in> r<\\STATESEP>with gh invff max_fun_diff_in<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)<\\STATESEP>show \"let m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\nF g \\<noteq> F h\nlet m = s.max_fun_diff g h in (g m, h m) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (F g) (F h) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. let m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r<\\STATESEP>unfolding F_def Let_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rs.FINFUNC\n(\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<noteq> (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\n(g (s.max_fun_diff g h), h (s.max_fun_diff g h)) \\<in> r\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\ns.max_fun_diff g h \\<in> {a \\<in> Field s. g a \\<noteq> h a}\nt.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) = f (s.max_fun_diff g h)\n\ngoal (1 subgoal):\n 1. (if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then g (the_inv_into (Field s) f (t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined, if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then h (the_inv_into (Field s) f (t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) (\\<lambda>z. if z \\<in> f ` Field s then h (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined) \\<in> r<\\STATESEP>by (auto simp: dest: injfD)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nlet m = t.max_fun_diff (F g) (F h) in (F g m, F h m) \\<in> r\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ncompat rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ncompat rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>from FLR<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp<\\STATESEP>have \"ofilter ?R (F ` Field ?L)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rexpt.ofilter (F ` Field rs.oexp)<\\STATESEP>unfolding rexpt.ofilter_def under_def rs.Field_oexp rt.Field_oexp<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nF ` rs.FINFUNC \\<subseteq> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. F ` rs.FINFUNC \\<subseteq> rt.FINFUNC \\<and> (\\<forall>a\\<in>F ` rs.FINFUNC. {b. (b, a) \\<in> rt.oexp} \\<subseteq> F ` rs.FINFUNC)<\\STATESEP>unfolding rt.oexp_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nF ` rs.FINFUNC \\<subseteq> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. F ` rs.FINFUNC \\<subseteq> rt.FINFUNC \\<and> (\\<forall>a\\<in>F ` rs.FINFUNC. {b. (b, a) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}} \\<subseteq> F ` rs.FINFUNC)<\\STATESEP>proof (safe elim!: imageI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC<\\STATESEP>fix g h<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC<\\STATESEP>assume gh: \"g \\<in> FinFunc r s\" \"h \\<in> FinFunc r t\" \"F g \\<in> FinFunc r t\"\n      \"let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ng \\<in> rs.FINFUNC\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>a x xa. \\<lbrakk>F ` rs.FINFUNC \\<subseteq> rt.FINFUNC; x \\<in> rs.FINFUNC; xa \\<in> rt.FINFUNC; F x \\<in> rt.FINFUNC; let m = t.max_fun_diff xa (F x) in (xa m, F x m) \\<in> r\\<rbrakk> \\<Longrightarrow> xa \\<in> F ` rs.FINFUNC<\\STATESEP>thus \"h \\<in> F ` FinFunc r s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> rs.FINFUNC\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\n\ngoal (1 subgoal):\n 1. h \\<in> F ` rs.FINFUNC<\\STATESEP>proof (cases \"h = F g\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nh \\<noteq> F g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>hence max_Field: \"t.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nh \\<noteq> F g\n\ngoal (1 subgoal):\n 1. t.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}<\\STATESEP>by (rule rt.max_fun_diff_in[OF _ gh(2,3)])<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>assume *: \"t.max_fun_diff h (F g) \\<notin> f ` Field s\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>with max_Field<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nt.max_fun_diff h (F g) \\<notin> f ` Field s<\\STATESEP>have **: \"F g (t.max_fun_diff h (F g)) = r.zero\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. F g (t.max_fun_diff h (F g)) = r.zero<\\STATESEP>unfolding F_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> {a \\<in> Field t. h a \\<noteq> (if a \\<in> f ` Field s then g (the_inv_into (Field s) f a) else if a \\<in> Field t then r.zero else undefined)}\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. (if t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s then g (the_inv_into (Field s) f (t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined))) else if t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> Field t then r.zero else undefined) = r.zero<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>with * gh(4)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero<\\STATESEP>have \"h (t.max_fun_diff h (F g)) = r.zero\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\nlet m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. h (t.max_fun_diff h (F g)) = r.zero<\\STATESEP>unfolding Let_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s\n(h (t.max_fun_diff h (F g)), F g (t.max_fun_diff h (F g))) \\<in> r\nF g (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. h (t.max_fun_diff h (F g)) = r.zero<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nh (t.max_fun_diff h (F g)) = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>with **<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero<\\STATESEP>have False<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>using max_Field gh(2,3)<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nh \\<in> rt.FINFUNC\nF g \\<in> rt.FINFUNC\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>unfolding FinFunc_def Func_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nF g (t.max_fun_diff h (F g)) = r.zero\nh (t.max_fun_diff h (F g)) = r.zero\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\nF g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<notin> f ` Field s \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>hence max_f_Field: \"t.max_fun_diff h (F g) \\<in> f ` Field s\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff h (F g) \\<notin> f ` Field s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. t.max_fun_diff h (F g) \\<in> f ` Field s<\\STATESEP>by blast<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>fix z<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>assume z: \"z \\<in> Field t - f ` Field s\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nz \\<in> Field t - f ` Field s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>have \"(t.max_fun_diff h (F g), z) \\<in> t\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<in> t<\\STATESEP>proof (rule ccontr)<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False<\\STATESEP>assume \"(t.max_fun_diff h (F g), z) \\<notin> t\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False<\\STATESEP>hence \"(z, t.max_fun_diff h (F g)) \\<in> t\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\ngoal (1 subgoal):\n 1. (z, t.max_fun_diff h (F g)) \\<in> t<\\STATESEP>using t.in_notinI[of \"t.max_fun_diff h (F g)\" z]\n            z max_Field<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<notin> t\n\\<lbrakk>(t.max_fun_diff h (F g), z) \\<notin> t \\<or> t.max_fun_diff h (F g) = z; z \\<in> Field t; t.max_fun_diff h (F g) \\<in> Field t\\<rbrakk> \\<Longrightarrow> (z, t.max_fun_diff h (F g)) \\<in> t\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (F g) \\<in> {a \\<in> Field t. h a \\<noteq> F g a}\n\ngoal (1 subgoal):\n 1. (z, t.max_fun_diff h (F g)) \\<in> t<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(z, t.max_fun_diff h (F g)) \\<in> t\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False<\\STATESEP>hence \"z \\<in> f ` Field s\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s<\\STATESEP>using *(3) max_f_Field<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\nt.ofilter (f ` Field s)\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s<\\STATESEP>unfolding t.ofilter_def under_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(z, t.max_fun_diff h (F g)) \\<in> t\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. z \\<in> f ` Field s<\\STATESEP>by fastforce<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nz \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. (t.max_fun_diff h (F g), z) \\<notin> t \\<Longrightarrow> False<\\STATESEP>with z<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nz \\<in> Field t - f ` Field s\nz \\<in> f ` Field s<\\STATESEP>show False<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> Field t - f ` Field s\nz \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by blast<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\n(t.max_fun_diff h (F g), z) \\<in> t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>hence \"h z = r.zero\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<in> t\n\ngoal (1 subgoal):\n 1. h z = r.zero<\\STATESEP>using rt.max_fun_diff_le_eq[OF _ False gh(2,3), of z]\n          z max_f_Field<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(t.max_fun_diff h (F g), z) \\<in> t\n\\<lbrakk>(t.max_fun_diff h (F g), z) \\<in> t; z \\<noteq> t.max_fun_diff h (F g)\\<rbrakk> \\<Longrightarrow> h z = F g z\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (F g) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. h z = r.zero<\\STATESEP>unfolding F_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined), z) \\<in> t\n\\<lbrakk>(t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined), z) \\<in> t; z \\<noteq> t.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\\<rbrakk> \\<Longrightarrow> h z = (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined)\nz \\<in> Field t - f ` Field s\nt.max_fun_diff h (\\<lambda>z. if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) \\<in> f ` Field s\n\ngoal (1 subgoal):\n 1. h z = r.zero<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\nh z = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>note ** = this<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>with *(3) gh(2)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero<\\STATESEP>have \"h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n\ngoal (1 subgoal):\n 1. h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)<\\STATESEP>using invff<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nt.ofilter (f ` Field s)\nh \\<in> rt.FINFUNC\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. h = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)<\\STATESEP>unfolding F_def fun_eq_iff FinFunc_def Func_def Let_def t.ofilter_def under_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t)\n?z3 \\<in> Field t - f ` Field s \\<Longrightarrow> h ?z3 = r.zero\n?x \\<in> Field s \\<Longrightarrow> the_inv_into (Field s) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. h x = (if x \\<in> f ` Field s then if the_inv_into (Field s) f x \\<in> Field s then h (f (the_inv_into (Field s) f x)) else undefined else if x \\<in> Field t then r.zero else undefined)<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>from gh(2) *(1,3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nh \\<in> rt.FINFUNC\ninj_on f (Field s)\nt.ofilter (f ` Field s)<\\STATESEP>have \"(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> FinFunc r s\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> rt.FINFUNC\ninj_on f (Field s)\nt.ofilter (f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC<\\STATESEP>unfolding FinFunc_def Func_def fin_support_def support_def t.ofilter_def under_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\ninj_on f (Field s)\nf ` Field s \\<subseteq> Field t \\<and> (\\<forall>a\\<in>f ` Field s. {b. (b, a) \\<in> t} \\<subseteq> f ` Field s)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> r.zero}}<\\STATESEP>by (auto intro: subset_inj_on elim!: finite_imageD[OF finite_subset[rotated]])<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC\n 2. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h \\<noteq> F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC<\\STATESEP>show \"?thesis\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nh = F (\\<lambda>x. if x \\<in> Field s then h (f x) else undefined)\n(\\<lambda>x. if x \\<in> Field s then h (f x) else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. h \\<in> F ` rs.FINFUNC<\\STATESEP>by (rule image_eqI)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nh \\<in> F ` rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> rs.FINFUNC; h \\<in> rt.FINFUNC; F g \\<in> rt.FINFUNC; let m = t.max_fun_diff h (F g) in (h m, F g m) \\<in> r; h = F g\\<rbrakk> \\<Longrightarrow> h \\<in> F ` rs.FINFUNC<\\STATESEP>qed simp<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nh \\<in> F ` rs.FINFUNC\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nrexpt.ofilter (F ` Field rs.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)<\\STATESEP>have \"embed ?L ?R F\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)\n\ngoal (1 subgoal):\n 1. embed rs.oexp rt.oexp F<\\STATESEP>using embed_iff_compat_inj_on_ofilter[of ?L ?R F]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\ninj_on F (Field rs.oexp)\ncompat rs.oexp rt.oexp F\nrexpt.ofilter (F ` Field rs.oexp)\n\\<lbrakk>Well_order rs.oexp; Well_order rt.oexp\\<rbrakk> \\<Longrightarrow> embed rs.oexp rt.oexp F = (compat rs.oexp rt.oexp F \\<and> inj_on F (Field rs.oexp) \\<and> rexpt.ofilter (F ` Field rs.oexp))\n\ngoal (1 subgoal):\n 1. embed rs.oexp rt.oexp F<\\STATESEP>by (auto intro: oexp_Well_order r s t)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembed rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nembed rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>from FLR<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp<\\STATESEP>have \"F ` Field ?L \\<subset> Field ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nF ` Field rs.oexp \\<subseteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subset> Field rt.oexp<\\STATESEP>proof (intro psubsetI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>from *(4)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nf ` Field s \\<subset> Field t<\\STATESEP>obtain z where z: \"z \\<in> Field t\" \"z \\<notin> f ` Field s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf ` Field s \\<subset> Field t\n\ngoal (1 subgoal):\n 1. (\\<And>z. \\<lbrakk>z \\<in> Field t; z \\<notin> f ` Field s\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>define h where [abs_def]: \"h z' =\n      (if z' \\<in> Field t then if z' = z then x else r.zero else undefined)\" for z'<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nh \\<equiv> \\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>from z x(3)<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero<\\STATESEP>have \"rt.SUPP h = {z}\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. rt.SUPP h = {z}<\\STATESEP>unfolding support_def h_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. {xa \\<in> Field t. (if xa \\<in> Field t then if xa = z then x else r.zero else undefined) \\<noteq> r.zero} = {z}<\\STATESEP>by simp<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrt.SUPP h = {z}\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>with x<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP h = {z}<\\STATESEP>have \"h \\<in> Field ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP h = {z}\n\ngoal (1 subgoal):\n 1. h \\<in> Field rt.oexp<\\STATESEP>unfolding h_def rt.Field_oexp FinFunc_def Func_def fin_support_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\nrt.SUPP (\\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined) = {z}\n\ngoal (1 subgoal):\n 1. (\\<lambda>z'. if z' \\<in> Field t then if z' = z then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rt.SUPP f)}<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>{<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>fix g<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>from z<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nz \\<in> Field t\nz \\<notin> f ` Field s<\\STATESEP>have \"F g z = r.zero\" \"h z = x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. F g z = r.zero &&& h z = x<\\STATESEP>unfolding support_def h_def F_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> Field t\nz \\<notin> f ` Field s\n\ngoal (1 subgoal):\n 1. (if z \\<in> f ` Field s then g (the_inv_into (Field s) f z) else if z \\<in> Field t then r.zero else undefined) = r.zero &&& (if z \\<in> Field t then if z = z then x else r.zero else undefined) = x<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nF g z = r.zero\nh z = x\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>with x(3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x<\\STATESEP>have \"F g \\<noteq> h\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x\n\ngoal (1 subgoal):\n 1. F g \\<noteq> h<\\STATESEP>unfolding fun_eq_iff<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\nF g z = r.zero\nh z = x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. F g x = h x)<\\STATESEP>by fastforce<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nF g \\<noteq> h\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>}<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nF ?g3 \\<noteq> h\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>hence \"h \\<notin> F ` Field ?L\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nF ?g3 \\<noteq> h\n\ngoal (1 subgoal):\n 1. h \\<notin> F ` Field rs.oexp<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nh \\<notin> F ` Field rs.oexp\n\ngoal (2 subgoals):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp\n 2. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nh \\<in> Field rt.oexp\nh \\<notin> F ` Field rs.oexp<\\STATESEP>show \"F ` Field ?L \\<noteq> Field ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> Field rt.oexp\nh \\<notin> F ` Field rs.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<noteq> Field rt.oexp<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nF ` Field rs.oexp \\<noteq> Field rt.oexp\n\ngoal (1 subgoal):\n 1. F ` Field rs.oexp \\<subseteq> Field rt.oexp \\<Longrightarrow> F ` Field rs.oexp \\<subseteq> Field rt.oexp<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nF ` Field rs.oexp \\<subset> Field rt.oexp\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp<\\STATESEP>have \"embedS ?L ?R F\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp\n\ngoal (1 subgoal):\n 1. embedS rs.oexp rt.oexp F<\\STATESEP>using embedS_iff[OF rs.oexp_Well_order, of ?R F]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembed rs.oexp rt.oexp F\nF ` Field rs.oexp \\<subset> Field rt.oexp\nembed rs.oexp rt.oexp F \\<Longrightarrow> embedS rs.oexp rt.oexp F = (F ` Field rs.oexp \\<subset> Field rt.oexp)\n\ngoal (1 subgoal):\n 1. embedS rs.oexp rt.oexp F<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. rs.oexp <o rt.oexp<\\STATESEP>unfolding ordLess_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\n\ngoal (1 subgoal):\n 1. (rs.oexp, rt.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nembedS rs.oexp rt.oexp F\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (rs.oexp, rt.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embedS r r')}<\\STATESEP>by (auto intro: oexp_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nrs.oexp <o rt.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_monoL:\n  assumes \"r \\<le>o s\"\n  shows   \"r ^o t \\<le>o s ^o t\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o t \\<le>o s ^o t<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o t \\<le>o s ^o t<\\STATESEP>interpret rt: wo_rel2 r t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t<\\STATESEP>by unfold_locales (rule r, rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o s ^o t<\\STATESEP>interpret st: wo_rel2 s t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 s t<\\STATESEP>by unfold_locales (rule s, rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>interpret r: wo_rel r<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r<\\STATESEP>by unfold_locales (rule r)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>interpret s: wo_rel s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>proof (cases \"t = {}\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. t = {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nt = {}\n\ngoal (2 subgoals):\n 1. t = {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nt = {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>using r s<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nt = {}\nWell_order r\nWell_order s\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>unfolding ordLeq_def2 underS_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nt = {}\nWell_order r\nWell_order s\n\ngoal (1 subgoal):\n 1. Well_order rt.oexp \\<and> Well_order st.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field rt.oexp. f a \\<in> Field st.oexp \\<and> f ` {b. b \\<noteq> a \\<and> (b, a) \\<in> rt.oexp} \\<subseteq> {b. b \\<noteq> f a \\<and> (b, f a) \\<in> st.oexp})<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nt \\<noteq> {}\n\ngoal (1 subgoal):\n 1. t \\<noteq> {} \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>thus ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nt \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>proof (cases \"r = {}\")<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<noteq> {}; r = {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>case True<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nr = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<noteq> {}; r = {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp\n 2. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>thus ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr = {}\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>using t \\<open>t \\<noteq> {}\\<close> st.oexp_Well_order ozero_ordLeq[unfolded ozero_def]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nr = {}\nWell_order t\nt \\<noteq> {}\nWell_order st.oexp\nWell_order ?r \\<Longrightarrow> {} \\<le>o ?r\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>next<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>case False<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>from assms<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nr \\<le>o s<\\STATESEP>obtain f where f: \"embed r s f\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nr \\<le>o s\n\ngoal (1 subgoal):\n 1. (\\<And>f. embed r s f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLeq_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(r, s) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (embed r r')}\n\ngoal (1 subgoal):\n 1. (\\<And>f. embed r s f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by blast<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nembed r s f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>hence f_underS: \"\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` underS r a \\<subseteq> underS s (f a)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)<\\STATESEP>using embed_in_Field embed_underS2 rt.rWELL<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\n\\<lbrakk>embed ?r ?r' ?f; ?a \\<in> Field ?r\\<rbrakk> \\<Longrightarrow> ?f ?a \\<in> Field ?r'\n\\<lbrakk>Well_order ?r; embed ?r ?s ?g; ?a \\<in> Field ?r\\<rbrakk> \\<Longrightarrow> ?g ` underS ?r ?a = underS ?s (?g ?a)\nWell_order r\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)<\\STATESEP>by fastforce<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>from f \\<open>t \\<noteq> {}\\<close> False<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nembed r s f\nt \\<noteq> {}\nr \\<noteq> {}<\\STATESEP>have *: \"Field r \\<noteq> {}\" \"Field s \\<noteq> {}\" \"Field t \\<noteq> {}\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\nt \\<noteq> {}\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {} &&& Field s \\<noteq> {} &&& Field t \\<noteq> {}<\\STATESEP>unfolding Field_def embed_def under_def bij_betw_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Domain r \\<union> Range r. inj_on f {b. (b, a) \\<in> r} \\<and> f ` {b. (b, a) \\<in> r} = {b. (b, f a) \\<in> s}\nt \\<noteq> {}\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Domain r \\<union> Range r \\<noteq> {} &&& Domain s \\<union> Range s \\<noteq> {} &&& Domain t \\<union> Range t \\<noteq> {}<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>with f<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nembed r s f\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}<\\STATESEP>obtain x where \"s.zero = f x\" \"x \\<in> Field r\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding embed_def bij_betw_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. inj_on f (r.under a) \\<and> f ` r.under a = s.under (f a)\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>using s.zero_under subsetD[OF under_Field[of r]]<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>a\\<in>Field r. inj_on f (r.under a) \\<and> f ` r.under a = s.under (f a)\nField r \\<noteq> {}\nField s \\<noteq> {}\nField t \\<noteq> {}\n?x \\<in> Field s \\<Longrightarrow> s.zero \\<in> s.under ?x\n?c \\<in> r.under ?a1 \\<Longrightarrow> ?c \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>s.zero = f x; x \\<in> Field r\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (metis (no_types, lifting) f_inv_into_f f_underS inv_into_into r.zero_in_Field)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>with f<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nembed r s f\ns.zero = f x\nx \\<in> Field r<\\STATESEP>have fz: \"f r.zero = s.zero\" and inj: \"inj_on f (Field r)\" and compat: \"compat r s f\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. f r.zero = s.zero &&& inj_on f (Field r) &&& compat r s f<\\STATESEP>unfolding embed_iff_compat_inj_on_ofilter[OF r s] compat_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s) \\<and> inj_on f (Field r) \\<and> s.ofilter (f ` Field r)\ns.zero = f x\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. f r.zero = s.zero &&& inj_on f (Field r) &&& \\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s<\\STATESEP>by (fastforce intro: s.leq_zero_imp)+<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nf r.zero = s.zero\ninj_on f (Field r)\ncompat r s f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>let ?f = \"\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined\"<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>fix g<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>assume g: \"g \\<in> Field (r ^o t)\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\ng \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>with fz f_underS<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> Field rt.oexp<\\STATESEP>have Field_fg: \"?f g \\<in> Field (s ^o t)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp<\\STATESEP>unfolding st.Field_oexp rt.Field_oexp FinFunc_def Func_def fin_support_def support_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ng \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field s) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> s.zero}}<\\STATESEP>by (auto elim!: finite_subset[rotated])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>have \"?f ` underS (r ^o t) g \\<subseteq> underS (s ^o t) (?f g)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>proof safe<\\STATESEP>9<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>fix h<\\STATESEP>10<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>assume h_underS: \"h \\<in> underS (r ^o t) g\"<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>hence \"h \\<in> Field (r ^o t)\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. h \\<in> Field rt.oexp<\\STATESEP>unfolding underS_def Field_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> {b. b \\<noteq> g \\<and> (b, g) \\<in> rt.oexp}\n\ngoal (1 subgoal):\n 1. h \\<in> Domain rt.oexp \\<union> Range rt.oexp<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nh \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>with fz f_underS<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> Field rt.oexp<\\STATESEP>have Field_fh: \"?f h \\<in> Field (s ^o t)\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> Field rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp<\\STATESEP>unfolding st.Field_oexp rt.Field_oexp FinFunc_def Func_def fin_support_def support_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\nh \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> r.zero}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field s) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> s.zero}}<\\STATESEP>by (auto elim!: finite_subset[rotated])<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>from h_underS<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nh \\<in> underS rt.oexp g<\\STATESEP>have \"h \\<noteq> g\" and hg: \"(h, g) \\<in> rt.oexp\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> underS rt.oexp g\n\ngoal (1 subgoal):\n 1. h \\<noteq> g &&& (h, g) \\<in> rt.oexp<\\STATESEP>unfolding underS_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nh \\<in> {b. b \\<noteq> g \\<and> (b, g) \\<in> rt.oexp}\n\ngoal (1 subgoal):\n 1. h \\<noteq> g &&& (h, g) \\<in> rt.oexp<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nh \\<noteq> g\n(h, g) \\<in> rt.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>with f inj<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\nembed r s f\ninj_on f (Field r)\nh \\<noteq> g\n(h, g) \\<in> rt.oexp<\\STATESEP>have neq: \"?f h \\<noteq> ?f g\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\ninj_on f (Field r)\nh \\<noteq> g\n(h, g) \\<in> rt.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>unfolding fun_eq_iff inj_on_def rt.oexp_def map_option_case FinFunc_def Func_def Let_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\nembed r s f\n\\<forall>x\\<in>Field r. \\<forall>y\\<in>Field r. f x = f y \\<longrightarrow> x = y\n\\<not> (\\<forall>x. h x = g x)\n(h, g) \\<in> {(f, g). f \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t) \\<and> g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support r.zero (Field t) \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> r \\<or> (\\<forall>x. f x = g x))}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. (if x \\<in> Field t then f (h x) else undefined) = (if x \\<in> Field t then f (g x) else undefined))<\\STATESEP>by simp metis<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>with hg<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n(h, g) \\<in> rt.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>have \"t.max_fun_diff (?f h) (?f g) = t.max_fun_diff h g\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(h, g) \\<in> rt.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g<\\STATESEP>unfolding rt.oexp_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g<\\STATESEP>using rt.max_fun_diff[OF \\<open>h \\<noteq> g\\<close>] rt.max_fun_diff_in[OF \\<open>h \\<noteq> g\\<close>]<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((let m = t.max_fun_diff f g in (f m, g m) \\<in> r) \\<or> f = g)}\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g<\\STATESEP>by (subst t.max_fun_diff_def, intro t.maxim_equality)\n              (auto simp: t.isMaxim_def intro: inj_onD[OF inj] intro!: rt.max_fun_diff_max)<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>with Field_fg Field_fh hg fz f_underS compat neq<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g<\\STATESEP>have \"(?f h, ?f g) \\<in> st.oexp\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp<\\STATESEP>using rt.max_fun_diff[OF \\<open>h \\<noteq> g\\<close>] rt.max_fun_diff_in[OF \\<open>h \\<noteq> g\\<close>]<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> Field st.oexp\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp<\\STATESEP>unfolding st.Field_oexp<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.FINFUNC\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> st.FINFUNC\n(h, g) \\<in> rt.oexp\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\ncompat r s f\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp<\\STATESEP>unfolding rt.oexp_def st.oexp_def Let_def compat_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.FINFUNC\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> st.FINFUNC\n(h, g) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> r \\<or> f = g)}\nf r.zero = s.zero\n\\<forall>a\\<in>Field r. f a \\<in> Field s \\<and> f ` r.underS a \\<subseteq> s.underS (f a)\n\\<forall>a b. (a, b) \\<in> r \\<longrightarrow> (f a, f b) \\<in> s\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\nt.max_fun_diff (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) = t.max_fun_diff h g\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> \\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> h (t.max_fun_diff h g) = a \\<and> g (t.max_fun_diff h g) = b\n\\<lbrakk>h \\<in> rt.FINFUNC; g \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff h g \\<in> {a \\<in> Field t. h a \\<noteq> g a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> {(f, g). f \\<in> st.FINFUNC \\<and> g \\<in> st.FINFUNC \\<and> ((f (t.max_fun_diff f g), g (t.max_fun_diff f g)) \\<in> s \\<or> f = g)}<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>x ga. ga \\<in> underS rt.oexp g \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (ga x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>with neq<\\STATESEP>10<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp<\\STATESEP>show \"?f h \\<in> underS (s ^o t) (?f g)\"<\\STATESEP>10<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>unfolding underS_def<\\STATESEP>11<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> {b. b \\<noteq> (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<and> (b, \\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> st.oexp}<\\STATESEP>by auto<\\STATESEP>11<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (h x) else undefined) \\<in> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>10<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>have \"?f g \\<in> Field (s ^o t) \\<and> ?f ` underS (r ^o t) g \\<subseteq> underS (s ^o t) (?f g)\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp\n(\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)<\\STATESEP>by blast<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>x. if x \\<in> Field t then f (g x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp g \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (g x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> {}; r \\<noteq> {}\\<rbrakk> \\<Longrightarrow> rt.oexp \\<le>o st.oexp<\\STATESEP>thus ?thesis<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. rt.oexp \\<le>o st.oexp<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n?g3 \\<in> Field rt.oexp \\<Longrightarrow> (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined) \\<in> Field st.oexp \\<and> (\\<lambda>g x. if x \\<in> Field t then f (g x) else undefined) ` underS rt.oexp ?g3 \\<subseteq> underS st.oexp (\\<lambda>x. if x \\<in> Field t then f (?g3 x) else undefined)\n\ngoal (1 subgoal):\n 1. Well_order rt.oexp \\<and> Well_order st.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field rt.oexp. f a \\<in> Field st.oexp \\<and> f ` underS rt.oexp a \\<subseteq> underS st.oexp (f a))<\\STATESEP>by (fastforce intro: oexp_Well_order r s t)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nrt.oexp \\<le>o st.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma ordLeq_oexp2:\n  assumes \"oone <o r\"\n  shows   \"s \\<le>o r ^o s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s \\<le>o r ^o s<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o r ^o s<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>interpret r: wo_rel r<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel r<\\STATESEP>by unfold_locales (rule r)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>interpret s: wo_rel s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>from assms well_order_on_domain[OF r]<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\noone <o r\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r<\\STATESEP>obtain x where\n    x: \"x \\<in> Field r\" \"r.zero \\<in> Field r\" \"x \\<noteq> r.zero\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\noone <o r\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>unfolding ordLess_def oone_def embedS_def[abs_def] bij_betw_def embed_def under_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n({((), ())}, r) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> (\\<exists>f. (\\<forall>a\\<in>Field r. inj_on f {b. (b, a) \\<in> r} \\<and> f ` {b. (b, a) \\<in> r} = {b. (b, f a) \\<in> r'}) \\<and> \\<not> (inj_on f (Field r) \\<and> f ` Field r = Field r'))}\n(?a, ?b) \\<in> r \\<Longrightarrow> ?a \\<in> Field r \\<and> ?b \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<lbrakk>x \\<in> Field r; r.zero \\<in> Field r; x \\<noteq> r.zero\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis<\\STATESEP>by (auto simp: image_def)\n       (metis (lifting) equals0D mem_Collect_eq r.zero_in_Field singletonI)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nx \\<in> Field r\nr.zero \\<in> Field r\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>let ?f = \"\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>from x(3)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> r.zero<\\STATESEP>have SUPP: \"\\<And>y. y \\<in> Field s \\<Longrightarrow> rs.SUPP (?f y) = {y}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = {y}<\\STATESEP>unfolding support_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> Field s \\<Longrightarrow> {xa \\<in> Field s. (if xa \\<in> Field s then if xa = y then x else r.zero else undefined) \\<noteq> r.zero} = {y}<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>{<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>fix y<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>assume y: \"y \\<in> Field s\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>with x(1,2) SUPP<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s<\\STATESEP>have \"?f y \\<in> Field (r ^o s)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp<\\STATESEP>unfolding rs.Field_oexp<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n?y1 \\<in> Field s \\<Longrightarrow> rs.SUPP (\\<lambda>b. if b \\<in> Field s then if b = ?y1 then x else r.zero else undefined) = {?y1}\ny \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC<\\STATESEP>by (auto simp: FinFunc_def Func_def fin_support_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>have \"?f ` underS s y \\<subseteq> underS (r ^o s) (?f y)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>proof safe<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>fix z<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>assume \"z \\<in> underS s y\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nz \\<in> s.underS y\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>hence z: \"z \\<noteq> y\" \"(z, y) \\<in> s\" \"z \\<in> Field s\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> s.underS y\n\ngoal (1 subgoal):\n 1. z \\<noteq> y &&& (z, y) \\<in> s &&& z \\<in> Field s<\\STATESEP>unfolding underS_def Field_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nz \\<in> {b. b \\<noteq> y \\<and> (b, y) \\<in> s}\n\ngoal (1 subgoal):\n 1. z \\<noteq> y &&& (z, y) \\<in> s &&& z \\<in> Domain s \\<union> Range s<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nz \\<noteq> y\n(z, y) \\<in> s\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>from x(3) y z(1,3)<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s<\\STATESEP>have \"?f z \\<noteq> ?f y\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>unfolding fun_eq_iff<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\nz \\<in> Field s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xa. (if xa \\<in> Field s then if xa = z then x else r.zero else undefined) = (if xa \\<in> Field s then if xa = y then x else r.zero else undefined))<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>moreover<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>{<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>from x(1,2)<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nx \\<in> Field r\nr.zero \\<in> Field r<\\STATESEP>have \"?f z \\<in> FinFunc r s\" \"?f y \\<in> FinFunc r s\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC &&& (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC<\\STATESEP>unfolding FinFunc_def Func_def fin_support_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nx \\<in> Field r\nr.zero \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)} &&& (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)}<\\STATESEP>by (auto simp: SUPP[OF z(3)] SUPP[OF y])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>moreover<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>from x(3) y z(1,2) refl_onD[OF s.REFL]<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s<\\STATESEP>have \"s.max_fun_diff (?f z) (?f y) = y\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y<\\STATESEP>unfolding rs.max_fun_diff_alt SUPP[OF z(3)] SUPP[OF y]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\nx \\<noteq> r.zero\ny \\<in> Field s\nz \\<noteq> y\n(z, y) \\<in> s\n?a \\<in> Field s \\<Longrightarrow> (?a, ?a) \\<in> s\n\ngoal (1 subgoal):\n 1. s.maxim (({z} \\<union> {y}) \\<inter> {a. (if a \\<in> Field s then if a = z then x else r.zero else undefined) \\<noteq> (if a \\<in> Field s then if a = y then x else r.zero else undefined)}) = y<\\STATESEP>by (intro s.maxim_equality) (auto simp: s.isMaxim_def)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>ultimately<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y<\\STATESEP>have \"(?f z, ?f y) \\<in> rs.oexp\"<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp<\\STATESEP>using y x(1)<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\ny \\<in> Field s\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp<\\STATESEP>unfolding rs.oexp_def Let_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> rs.FINFUNC\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.FINFUNC\ns.max_fun_diff (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) = y\ny \\<in> Field s\nx \\<in> Field r\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((f (s.max_fun_diff f g), g (s.max_fun_diff f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by auto<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>}<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. \\<And>xa a. a \\<in> s.underS y \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = a then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>ultimately<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp<\\STATESEP>show \"?f z \\<in> underS (r ^o s) (?f y)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>unfolding underS_def<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> {b. b \\<noteq> (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<and> (b, \\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> rs.oexp}<\\STATESEP>by blast<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = z then x else r.zero else undefined) \\<in> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>have \"?f y \\<in> Field (r ^o s) \\<and> ?f ` underS s y \\<subseteq> underS (r ^o s) (?f y)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp\n(\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)<\\STATESEP>by blast<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS y \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = y then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>}<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>thus ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. s \\<le>o rs.oexp<\\STATESEP>unfolding ordLeq_def2<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n?y3 \\<in> Field s \\<Longrightarrow> (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined) \\<in> Field rs.oexp \\<and> (\\<lambda>a b. if b \\<in> Field s then if b = a then x else r.zero else undefined) ` s.underS ?y3 \\<subseteq> underS rs.oexp (\\<lambda>b. if b \\<in> Field s then if b = ?y3 then x else r.zero else undefined)\n\ngoal (1 subgoal):\n 1. Well_order s \\<and> Well_order rs.oexp \\<and> (\\<exists>f. \\<forall>a\\<in>Field s. f a \\<in> Field rs.oexp \\<and> f ` s.underS a \\<subseteq> underS rs.oexp (f a))<\\STATESEP>by (fast intro: oexp_Well_order r s)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns \\<le>o rs.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma FinFunc_osum:\n  \"fg \\<in> FinFunc r (s +o t) = (fg o Inl \\<in> FinFunc r s \\<and> fg o Inr \\<in> FinFunc r t)\"\n  (is \"?L = (?R1 \\<and> ?R2)\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (fg \\<in> FinFunc r (s +o t)) = (fg \\<circ> Inl \\<in> FinFunc r s \\<and> fg \\<circ> Inr \\<in> FinFunc r t)<\\STATESEP>proof safe<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inl \\<in> FinFunc r s\n 2. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 3. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>assume ?L<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (3 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inl \\<in> FinFunc r s\n 2. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 3. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>from \\<open>?L\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfg \\<in> FinFunc r (s +o t)<\\STATESEP>show ?R1<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (1 subgoal):\n 1. fg \\<circ> Inl \\<in> FinFunc r s<\\STATESEP>unfolding FinFunc_def Field_osum Func_def Int_iff fin_support_Field_osum o_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s) \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fg (Inl x)) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s)<\\STATESEP>by (auto split: sum.splits)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfg \\<circ> Inl \\<in> FinFunc r s\n\ngoal (2 subgoals):\n 1. fg \\<in> FinFunc r (s +o t) \\<Longrightarrow> fg \\<circ> Inr \\<in> FinFunc r t\n 2. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>from \\<open>?L\\<close><\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nfg \\<in> FinFunc r (s +o t)<\\STATESEP>show ?R2<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> FinFunc r (s +o t)\n\ngoal (1 subgoal):\n 1. fg \\<circ> Inr \\<in> FinFunc r t<\\STATESEP>unfolding FinFunc_def Field_osum Func_def Int_iff fin_support_Field_osum o_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inl x)) \\<in> fin_support (zero r) (Field s) \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fg (Inr x)) \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<and> (\\<lambda>x. fg (Inr x)) \\<in> fin_support (zero r) (Field t)<\\STATESEP>by (auto split: sum.splits)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>assume ?R1 ?R2<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfg \\<circ> Inl \\<in> FinFunc r s\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fg \\<circ> Inl \\<in> FinFunc r s; fg \\<circ> Inr \\<in> FinFunc r t\\<rbrakk> \\<Longrightarrow> fg \\<in> FinFunc r (s +o t)<\\STATESEP>thus \"?L\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nfg \\<circ> Inl \\<in> FinFunc r s\nfg \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. fg \\<in> FinFunc r (s +o t)<\\STATESEP>unfolding FinFunc_def Field_osum Func_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nfg \\<circ> Inl \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)\nfg \\<circ> Inr \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. fg \\<in> {f. (\\<forall>a\\<in>Inl ` Field s \\<union> Inr ` Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Inl ` Field s \\<union> Inr ` Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Inl ` Field s \\<union> Inr ` Field t)<\\STATESEP>by (auto simp: fin_support_Field_osum o_def image_iff split: sum.splits) (metis sumE)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfg \\<in> FinFunc r (s +o t)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma max_fun_diff_eq_Inl:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inl x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff s f1 f2 = x\" (is ?P) \"g1 = g2\" (is ?Q)<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff s f1 f2 = x &&& g1 = g2<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff s f1 f2 = x\n 2. g1 = g2<\\STATESEP>interpret st: wo_rel \"s +o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s +o t)<\\STATESEP>by unfold_locales (rule osum_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff s f1 f2 = x\n 2. g1 = g2<\\STATESEP>interpret s: wo_rel s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2<\\STATESEP>interpret rst: wo_rel2 r \"s +o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)<\\STATESEP>by unfold_locales (rule r, rule osum_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x<\\STATESEP>have *: \"st.isMaxim {a \\<in> Field (s +o t). case_sum f1 g1 a \\<noteq> case_sum f2 g2 a} (Inl x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)<\\STATESEP>using rst.isMaxim_max_fun_diff[OF assms(2-4)]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inl x\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (st.max_fun_diff (case_sum f1 g1) (case_sum f2 g2))\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2<\\STATESEP>hence \"s.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\n\ngoal (1 subgoal):\n 1. s.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x<\\STATESEP>unfolding st.isMaxim_def s.isMaxim_def Field_osum<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> s +o t)\n\ngoal (1 subgoal):\n 1. x \\<in> {a \\<in> Field s. f1 a \\<noteq> f2 a} \\<and> (\\<forall>a\\<in>{a \\<in> Field s. f1 a \\<noteq> f2 a}. (a, x) \\<in> s)<\\STATESEP>by (auto simp: osum_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (2 subgoals):\n 1. s.max_fun_diff f1 f2 = x\n 2. g1 = g2<\\STATESEP>thus ?P<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (1 subgoal):\n 1. s.max_fun_diff f1 f2 = x<\\STATESEP>unfolding s.max_fun_diff_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ns.isMaxim {a \\<in> Field s. f1 a \\<noteq> f2 a} x\n\ngoal (1 subgoal):\n 1. s.maxim {a \\<in> Field s. f1 a \\<noteq> f2 a} = x<\\STATESEP>by (rule s.maxim_equality)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff f1 f2 = x\n\ngoal (1 subgoal):\n 1. g1 = g2<\\STATESEP>from assms(3,4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ncase_sum f1 g1 \\<in> rst.FINFUNC\ncase_sum f2 g2 \\<in> rst.FINFUNC<\\STATESEP>have **: \"g1 \\<in> FinFunc r t\" \"g2 \\<in> FinFunc r t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ncase_sum f1 g1 \\<in> rst.FINFUNC\ncase_sum f2 g2 \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. g1 \\<in> FinFunc r t &&& g2 \\<in> FinFunc r t<\\STATESEP>unfolding FinFunc_osum<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ncase_sum f1 g1 \\<circ> Inl \\<in> FinFunc r s \\<and> case_sum f1 g1 \\<circ> Inr \\<in> FinFunc r t\ncase_sum f2 g2 \\<circ> Inl \\<in> FinFunc r s \\<and> case_sum f2 g2 \\<circ> Inr \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 \\<in> FinFunc r t &&& g2 \\<in> FinFunc r t<\\STATESEP>by (auto simp: o_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 = g2<\\STATESEP>show ?Q<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. g1 = g2<\\STATESEP>proof<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g1 x = g2 x<\\STATESEP>fix x<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g1 x = g2 x<\\STATESEP>from * **<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t<\\STATESEP>show \"g1 x = g2 x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inl x)\ng1 \\<in> FinFunc r t\ng2 \\<in> FinFunc r t\n\ngoal (1 subgoal):\n 1. g1 x = g2 x<\\STATESEP>unfolding st.isMaxim_def Field_osum FinFunc_def Func_def fun_eq_iff<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> s +o t)\ng1 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\ng2 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. g1 x = g2 x<\\STATESEP>unfolding osum_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nInl x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inl x) \\<in> map_prod Inl Inl ` s \\<union> map_prod Inr Inr ` t \\<union> {(Inl a, Inr a') |a a'. a \\<in> Field s \\<and> a' \\<in> Field t})\ng1 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\ng2 \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field t)\n\ngoal (1 subgoal):\n 1. g1 x = g2 x<\\STATESEP>by (case_tac \"x \\<in> Field t\") auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ng1 x = g2 x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ng1 = g2\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma max_fun_diff_eq_Inr:\n  assumes \"wo_rel.max_fun_diff (s +o t) (case_sum f1 g1) (case_sum f2 g2) = Inr x\"\n    \"case_sum f1 g1 \\<noteq> case_sum f2 g2\"\n    \"case_sum f1 g1 \\<in> FinFunc r (s +o t)\" \"case_sum f2 g2 \\<in> FinFunc r (s +o t)\"\n  shows \"wo_rel.max_fun_diff t g1 g2 = x\" (is ?P) \"g1 \\<noteq> g2\" (is ?Q)<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff t g1 g2 = x &&& g1 \\<noteq> g2<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff t g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>interpret st: wo_rel \"s +o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s +o t)<\\STATESEP>by unfold_locales (rule osum_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. wo_rel.max_fun_diff t g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>interpret rst: wo_rel2 r \"s +o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)<\\STATESEP>by unfold_locales (rule r, rule osum_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>from assms(1)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x<\\STATESEP>have *: \"st.isMaxim {a \\<in> Field (s +o t). case_sum f1 g1 a \\<noteq> case_sum f2 g2 a} (Inr x)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)<\\STATESEP>using rst.isMaxim_max_fun_diff[OF assms(2-4)]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nst.max_fun_diff (case_sum f1 g1) (case_sum f2 g2) = Inr x\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (st.max_fun_diff (case_sum f1 g1) (case_sum f2 g2))\n\ngoal (1 subgoal):\n 1. st.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)<\\STATESEP>by simp<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)\n\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>hence \"t.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nst.isMaxim {a \\<in> Field (s +o t). (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} (Inr x)\n\ngoal (1 subgoal):\n 1. t.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x<\\STATESEP>unfolding st.isMaxim_def t.isMaxim_def Field_osum<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nInr x \\<in> {a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)} \\<and> (\\<forall>a\\<in>{a \\<in> Inl ` Field s \\<union> Inr ` Field t. (case a of Inl x \\<Rightarrow> f1 x | Inr x \\<Rightarrow> g1 x) \\<noteq> (case a of Inl x \\<Rightarrow> f2 x | Inr x \\<Rightarrow> g2 x)}. (a, Inr x) \\<in> s +o t)\n\ngoal (1 subgoal):\n 1. x \\<in> {a \\<in> Field t. g1 a \\<noteq> g2 a} \\<and> (\\<forall>a\\<in>{a \\<in> Field t. g1 a \\<noteq> g2 a}. (a, x) \\<in> t)<\\STATESEP>by (auto simp: osum_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (2 subgoals):\n 1. t.max_fun_diff g1 g2 = x\n 2. g1 \\<noteq> g2<\\STATESEP>thus ?P ?Q<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (1 subgoal):\n 1. t.max_fun_diff g1 g2 = x &&& g1 \\<noteq> g2<\\STATESEP>unfolding t.max_fun_diff_def fun_eq_iff<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nt.isMaxim {a \\<in> Field t. g1 a \\<noteq> g2 a} x\n\ngoal (1 subgoal):\n 1. t.maxim {a \\<in> Field t. g1 a \\<noteq> g2 a} = x &&& \\<not> (\\<forall>x. g1 x = g2 x)<\\STATESEP>by (auto intro: t.maxim_equality simp: t.isMaxim_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nt.max_fun_diff g1 g2 = x\ng1 \\<noteq> g2\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_osum: \"r ^o (s +o t) =o (r ^o s) *o (r ^o t)\" (is \"?R =o ?L\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o (s +o t) =o r ^o s *o r ^o t<\\STATESEP>proof (rule ordIso_symmetric)<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o s *o r ^o t =o r ^o (s +o t)<\\STATESEP>interpret rst: wo_rel2 r \"s +o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s +o t)<\\STATESEP>by unfold_locales (rule r, rule osum_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o s *o r ^o t =o rst.oexp<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o r ^o t =o rst.oexp<\\STATESEP>interpret rt: wo_rel2 r t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r t<\\STATESEP>by unfold_locales (rule r, rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>let ?f = \"\\<lambda>(f, g). case_sum f g\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>have \"bij_betw ?f (Field ?L) (Field ?R)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)<\\STATESEP>unfolding bij_betw_def rst.Field_oexp rs.Field_oexp rt.Field_oexp Field_oprod<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). case_sum x y) (rs.FINFUNC \\<times> rt.FINFUNC) \\<and> (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC<\\STATESEP>proof (intro conjI)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>(x, y). case_sum x y) (rs.FINFUNC \\<times> rt.FINFUNC)\n 2. (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC<\\STATESEP>show \"inj_on ?f (FinFunc r s \\<times> FinFunc r t)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(f, g). case_sum f g) (rs.FINFUNC \\<times> rt.FINFUNC)<\\STATESEP>unfolding inj_on_def<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>rs.FINFUNC \\<times> rt.FINFUNC. \\<forall>y\\<in>rs.FINFUNC \\<times> rt.FINFUNC. (case x of (x, xa) \\<Rightarrow> case_sum x xa) = (case y of (x, xa) \\<Rightarrow> case_sum x xa) \\<longrightarrow> x = y<\\STATESEP>by (auto simp: fun_eq_iff split: sum.splits)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ninj_on (\\<lambda>(f, g). case_sum f g) (rs.FINFUNC \\<times> rt.FINFUNC)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). case_sum x y) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC<\\STATESEP>show \"?f ` (FinFunc r s \\<times> FinFunc r t) = FinFunc r (s +o t)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC<\\STATESEP>proof safe<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)<\\STATESEP>fix fg<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)<\\STATESEP>assume \"fg \\<in> FinFunc r (s +o t)\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nfg \\<in> rst.FINFUNC\n\ngoal (2 subgoals):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)<\\STATESEP>thus \"fg \\<in> ?f ` (FinFunc r s \\<times> FinFunc r t)\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. fg \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)<\\STATESEP>by (intro image_eqI[of _ _ \"(fg o Inl, fg o Inr)\"])\n          (auto simp: FinFunc_osum fun_eq_iff split: sum.splits)<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nfg \\<in> (\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC)\n\ngoal (1 subgoal):\n 1. \\<And>x a b. \\<lbrakk>a \\<in> rs.FINFUNC; b \\<in> rt.FINFUNC\\<rbrakk> \\<Longrightarrow> case_sum a b \\<in> rst.FINFUNC<\\STATESEP>qed (auto simp: FinFunc_osum o_def)<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>(f, g). case_sum f g) ` (rs.FINFUNC \\<times> rt.FINFUNC) = rst.FINFUNC\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>moreover<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>have \"compat ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)<\\STATESEP>unfolding compat_def rst.Field_oexp rs.Field_oexp rt.Field_oexp oprod_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> rt.oexp - Id \\<and> x1 \\<in> rs.FINFUNC \\<and> x2 \\<in> rs.FINFUNC \\<or> (y1, y2) \\<in> Restr Id rt.FINFUNC \\<and> (x1, x2) \\<in> rs.oexp} \\<longrightarrow> (case a of (x, xa) \\<Rightarrow> case_sum x xa, case b of (x, xa) \\<Rightarrow> case_sum x xa) \\<in> rst.oexp<\\STATESEP>unfolding rst.oexp_def Let_def rs.oexp_def rt.oexp_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> {(f, g). f \\<in> rt.FINFUNC \\<and> g \\<in> rt.FINFUNC \\<and> ((f (wo_rel.max_fun_diff t f g), g (wo_rel.max_fun_diff t f g)) \\<in> r \\<or> f = g)} - Id \\<and> x1 \\<in> rs.FINFUNC \\<and> x2 \\<in> rs.FINFUNC \\<or> (y1, y2) \\<in> Restr Id rt.FINFUNC \\<and> (x1, x2) \\<in> {(f, g). f \\<in> rs.FINFUNC \\<and> g \\<in> rs.FINFUNC \\<and> ((f (wo_rel.max_fun_diff s f g), g (wo_rel.max_fun_diff s f g)) \\<in> r \\<or> f = g)}} \\<longrightarrow> (case a of (x, xa) \\<Rightarrow> case_sum x xa, case b of (x, xa) \\<Rightarrow> case_sum x xa) \\<in> {(f, g). f \\<in> rst.FINFUNC \\<and> g \\<in> rst.FINFUNC \\<and> ((f (wo_rel.max_fun_diff (s +o t) f g), g (wo_rel.max_fun_diff (s +o t) f g)) \\<in> r \\<or> f = g)}<\\STATESEP>by (fastforce simp: Field_osum FinFunc_osum o_def split: sum.splits\n        dest: max_fun_diff_eq_Inl max_fun_diff_eq_Inr)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>ultimately<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)<\\STATESEP>have \"iso ?L ?R ?f\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. iso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nbij_betw (\\<lambda>(f, g). case_sum f g) (Field (rs.oexp *o rt.oexp)) (Field rst.oexp)\ncompat (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)<\\STATESEP>by (subst iso_iff3) (auto intro: oexp_Well_order oprod_Well_order osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>thus \"?L =o ?R\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>using r s t<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. rs.oexp *o rt.oexp =o rst.oexp<\\STATESEP>unfolding ordIso_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\niso (rs.oexp *o rt.oexp) rst.oexp (\\<lambda>(f, g). case_sum f g)\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (rs.oexp *o rt.oexp, rst.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oexp_Well_order oprod_Well_order osum_Well_order)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nrs.oexp *o rt.oexp =o rst.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>definition \"rev_curr f b = (if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined)\"<\\STATESEP>0<\\TRANSEP><\\STATESEP>lemma rev_curr_FinFunc:\n  assumes Field: \"Field r \\<noteq> {}\"\n  shows \"rev_curr ` (FinFunc r (s *o t)) = FinFunc (r ^o s) t\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. local.rev_curr ` FinFunc r (s *o t) = FinFunc (r ^o s) t<\\STATESEP>proof safe<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> FinFunc (r ^o s) t\n 2. \\<And>x. x \\<in> FinFunc (r ^o s) t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> FinFunc rs.oexp t\n 2. \\<And>x. x \\<in> FinFunc rs.oexp t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>interpret rst: wo_rel2 \"r ^o s\" t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t<\\STATESEP>by unfold_locales (rule oexp_Well_order[OF r s], rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>fix g<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>assume g: \"g \\<in> FinFunc r (s *o t)\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\ng \\<in> FinFunc r (s *o t)\n\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>hence \"finite (rst.SUPP (rev_curr g))\" \"\\<forall>x \\<in> Field t. finite (rs.SUPP (rev_curr g x))\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> FinFunc r (s *o t)\n\ngoal (1 subgoal):\n 1. finite (rst.SUPP (local.rev_curr g)) &&& \\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))<\\STATESEP>unfolding FinFunc_def Field_oprod rs.Field_oexp Func_def fin_support_def support_def\n      rs.zero_oexp[OF Field] rev_curr_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}\n\ngoal (1 subgoal):\n 1. finite {x \\<in> Field t. (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) \\<noteq> rs.const} &&& \\<forall>x\\<in>Field t. finite {xa \\<in> Field s. (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa \\<noteq> zero r}<\\STATESEP>by (auto simp: fun_eq_iff rs.const_def elim!: finite_surj)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> FinFunc r (s *o t) \\<Longrightarrow> local.rev_curr xa \\<in> rst.FINFUNC\n 2. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>with g<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\ng \\<in> FinFunc r (s *o t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))<\\STATESEP>show \"rev_curr g \\<in> FinFunc (r ^o s) t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> FinFunc r (s *o t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (1 subgoal):\n 1. local.rev_curr g \\<in> rst.FINFUNC<\\STATESEP>unfolding FinFunc_def Field_oprod rs.Field_oexp Func_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\ng \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t)\nfinite (rst.SUPP (local.rev_curr g))\n\\<forall>x\\<in>Field t. finite (rs.SUPP (local.rev_curr g x))\n\ngoal (1 subgoal):\n 1. local.rev_curr g \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero rs.oexp) (Field t)<\\STATESEP>by (auto simp: rev_curr_def fin_support_def)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> FinFunc (r ^o s) t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> FinFunc rs.oexp t \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>interpret rst: wo_rel2 \"r ^o s\" t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t<\\STATESEP>by unfold_locales (rule oexp_Well_order[OF r s], rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>fix fg<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>assume *: \"fg \\<in> FinFunc (r ^o s) t\"<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>let ?g = \"\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined\"<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rst.FINFUNC \\<Longrightarrow> x \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>show \"fg \\<in> rev_curr ` FinFunc r (s *o t)\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. fg \\<in> local.rev_curr ` FinFunc r (s *o t)<\\STATESEP>proof (rule image_eqI[of _ _ ?g])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. fg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)\n 2. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>show \"fg = rev_curr ?g\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. fg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)<\\STATESEP>proof<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x<\\STATESEP>fix x<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x<\\STATESEP>from *<\\STATESEP>6<\\TRANSEP>proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC<\\STATESEP>show \"fg x = rev_curr ?g x\"<\\STATESEP>6<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. fg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x<\\STATESEP>unfolding FinFunc_def rs.Field_oexp Func_def rev_curr_def Field_oprod<\\STATESEP>7<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s)) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero rs.oexp) (Field t)\n\ngoal (1 subgoal):\n 1. fg x = (if x \\<in> Field t then \\<lambda>a. case (a, x) of (a, b) \\<Rightarrow> if (a, b) \\<in> Field s \\<times> Field t then fg b a else undefined else undefined)<\\STATESEP>by auto<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nfg x = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) x\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nfg = local.rev_curr (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>have **: \"(\\<Union>g \\<in> fg ` Field t. rs.SUPP g) =\n              (\\<Union>g \\<in> fg ` Field t - {rs.const}. rs.SUPP g)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (rs.SUPP ` fg ` Field t) = \\<Union> (rs.SUPP ` (fg ` Field t - {rs.const}))<\\STATESEP>unfolding support_def<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>g\\<in>fg ` Field t. {x \\<in> Field s. g x \\<noteq> zero r}) = (\\<Union>g\\<in>fg ` Field t - {rs.const}. {x \\<in> Field s. g x \\<noteq> zero r})<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<Union> (rs.SUPP ` fg ` Field t) = \\<Union> (rs.SUPP ` (fg ` Field t - {rs.const}))\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>from *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC<\\STATESEP>have ***: \"\\<forall>g \\<in> fg ` Field t. finite (rs.SUPP g)\" \"finite (rst.SUPP fg)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g) &&& finite (rst.SUPP fg)<\\STATESEP>unfolding rs.Field_oexp FinFunc_def Func_def fin_support_def Option.these_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rs.SUPP f)}) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite (rst.SUPP f)}\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g) &&& finite (rst.SUPP fg)<\\STATESEP>by force+<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>hence \"finite (fg ` Field t - {rs.const})\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})<\\STATESEP>using *<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfg \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})<\\STATESEP>unfolding support_def rs.zero_oexp[OF Field] FinFunc_def Func_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite {x \\<in> Field s. g x \\<noteq> zero r}\nfinite {x \\<in> Field t. fg x \\<noteq> rs.const}\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> Field rs.oexp) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support rs.const (Field t)\n\ngoal (1 subgoal):\n 1. finite (fg ` Field t - {rs.const})<\\STATESEP>by (elim finite_surj[of _ _ fg]) (fastforce simp: image_iff Option.these_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nfinite (fg ` Field t - {rs.const})\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>with ***<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfinite (fg ` Field t - {rs.const})<\\STATESEP>have \"finite ((\\<Union>g \\<in> fg ` Field t. rs.SUPP g) \\<times> rst.SUPP fg)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<forall>g\\<in>fg ` Field t. finite (rs.SUPP g)\nfinite (rst.SUPP fg)\nfinite (fg ` Field t - {rs.const})\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)<\\STATESEP>by (subst **) (auto intro!: finite_cartesian_product)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>with *<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nfg \\<in> rst.FINFUNC\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)<\\STATESEP>show \"?g \\<in> FinFunc r (s *o t)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> rst.FINFUNC\nfinite (\\<Union> (rs.SUPP ` fg ` Field t) \\<times> rst.SUPP fg)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)<\\STATESEP>unfolding Field_oprod rs.Field_oexp FinFunc_def Func_def fin_support_def Option.these_def\n        support_def rs.zero_oexp[OF Field]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nfg \\<in> {f. (\\<forall>a\\<in>Field t. f a \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero r}}) \\<and> (\\<forall>a. a \\<notin> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field t. f x \\<noteq> rs.const}}\nfinite ((\\<Union>g\\<in>fg ` Field t. {x \\<in> Field s. g x \\<noteq> zero r}) \\<times> {x \\<in> Field t. fg x \\<noteq> rs.const})\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). if (a, b) \\<in> Field s \\<times> Field t then fg b a else undefined) \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}<\\STATESEP>by (auto elim!: finite_subset[rotated])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n(\\<lambda>(a, b). if (a, b) \\<in> Field (s *o t) then fg b a else undefined) \\<in> FinFunc r (s *o t)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nfg \\<in> local.rev_curr ` FinFunc r (s *o t)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma rev_curr_app_FinFunc[elim!]:\n  \"\\<lbrakk>f \\<in> FinFunc r (s *o t); z \\<in> Field t\\<rbrakk> \\<Longrightarrow> rev_curr f z \\<in> FinFunc r s\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> FinFunc r (s *o t); z \\<in> Field t\\<rbrakk> \\<Longrightarrow> local.rev_curr f z \\<in> FinFunc r s<\\STATESEP>unfolding rev_curr_def FinFunc_def Func_def Field_oprod fin_support_def support_def<\\STATESEP>1<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s \\<times> Field t. f x \\<noteq> zero r}}; z \\<in> Field t\\<rbrakk> \\<Longrightarrow> (if z \\<in> Field t then \\<lambda>a. f (a, z) else undefined) \\<in> {f. (\\<forall>a\\<in>Field s. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<longrightarrow> f a = undefined)} \\<inter> {f. finite {x \\<in> Field s. f x \\<noteq> zero r}}<\\STATESEP>by (auto elim: finite_surj)<\\STATESEP>1<\\TRANSEP><\\STATESEP>lemma max_fun_diff_oprod:\n  assumes Field: \"Field r \\<noteq> {}\" and \"f \\<noteq> g\" \"f \\<in> FinFunc r (s *o t)\" \"g \\<in> FinFunc r (s *o t)\"\n  defines \"m \\<equiv> wo_rel.max_fun_diff t (rev_curr f) (rev_curr g)\"\n  shows \"wo_rel.max_fun_diff (s *o t) f g =\n    (wo_rel.max_fun_diff s (rev_curr f m) (rev_curr g m), m)\"<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff (s *o t) f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>proof -<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. wo_rel.max_fun_diff (s *o t) f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret st: wo_rel \"s *o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel (s *o t)<\\STATESEP>by unfold_locales (rule oprod_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (wo_rel.max_fun_diff s (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret s: wo_rel s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel s<\\STATESEP>by unfold_locales (rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret t: wo_rel t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel t<\\STATESEP>by unfold_locales (rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret r_st: wo_rel2 r \"s *o t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s *o t)<\\STATESEP>by unfold_locales (rule r, rule oprod_Well_order[OF s t])<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>interpret rst: wo_rel2 \"r ^o s\" t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t<\\STATESEP>by unfold_locales (rule oexp_Well_order[OF r s], rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>from fun_unequal_in_support[OF assms(2), of \"Field (s *o t)\" \"Field r\" \"Field r\"] assms(3,4)<\\STATESEP>2<\\TRANSEP>proof (chain)\npicking this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC<\\STATESEP>have diff1: \"rev_curr f \\<noteq> rev_curr g\"\n      \"rev_curr f \\<in> FinFunc (r ^o s) t\" \"rev_curr g \\<in> FinFunc (r ^o s) t\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f \\<noteq> local.rev_curr g &&& local.rev_curr f \\<in> rst.FINFUNC &&& local.rev_curr g \\<in> rst.FINFUNC<\\STATESEP>using rev_curr_FinFunc[OF Field]<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field (s *o t)) (Field r); g \\<in> Func (Field (s *o t)) (Field r)\\<rbrakk> \\<Longrightarrow> (support ?z (Field (s *o t)) f \\<union> support ?z (Field (s *o t)) g) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\nlocal.rev_curr ` r_st.FINFUNC = rst.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f \\<noteq> local.rev_curr g &&& local.rev_curr f \\<in> rst.FINFUNC &&& local.rev_curr g \\<in> rst.FINFUNC<\\STATESEP>unfolding fun_eq_iff rev_curr_def[abs_def] FinFunc_def support_def Field_oprod<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\n\\<lbrakk>f \\<in> Func (Field s \\<times> Field t) (Field r); g \\<in> Func (Field s \\<times> Field t) (Field r)\\<rbrakk> \\<Longrightarrow> ({x \\<in> Field s \\<times> Field t. f x \\<noteq> ?z} \\<union> {x \\<in> Field s \\<times> Field t. g x \\<noteq> ?z}) \\<inter> {a. f a \\<noteq> g a} \\<noteq> {}\nf \\<in> Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)\ng \\<in> Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)\n(\\<lambda>f b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) ` (Func (Field s \\<times> Field t) (Field r) \\<inter> fin_support (zero r) (Field s \\<times> Field t)) = Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x xa. (if x \\<in> Field t then \\<lambda>a. f (a, x) else undefined) xa = (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa) &&& (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) \\<in> Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t) &&& (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Func (Field t) (Field rs.oexp) \\<inter> fin_support (zero rs.oexp) (Field t)<\\STATESEP>by auto fast<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>hence diff2: \"rev_curr f m \\<noteq> rev_curr g m\" \"rev_curr f m \\<in> FinFunc r s\" \"rev_curr g m \\<in> FinFunc r s\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr f m \\<noteq> local.rev_curr g m &&& local.rev_curr f m \\<in> rs.FINFUNC &&& local.rev_curr g m \\<in> rs.FINFUNC<\\STATESEP>using rst.max_fun_diff[OF diff1] assms(3,4) rst.max_fun_diff_in<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field rs.oexp \\<and> b \\<in> Field rs.oexp \\<and> local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = a \\<and> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = b\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> rst.FINFUNC; ?g \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff ?f ?g \\<in> {a \\<in> Field t. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. local.rev_curr f m \\<noteq> local.rev_curr g m &&& local.rev_curr f m \\<in> rs.FINFUNC &&& local.rev_curr g m \\<in> rs.FINFUNC<\\STATESEP>unfolding m_def<\\STATESEP>3<\\TRANSEP>proof (prove)\nusing this:\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field rs.oexp \\<and> b \\<in> Field rs.oexp \\<and> local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = a \\<and> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) = b\nf \\<in> r_st.FINFUNC\ng \\<in> r_st.FINFUNC\n\\<lbrakk>?f \\<noteq> ?g; ?f \\<in> rst.FINFUNC; ?g \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> t.max_fun_diff ?f ?g \\<in> {a \\<in> Field t. ?f a \\<noteq> ?g a}\n\ngoal (1 subgoal):\n 1. local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<noteq> local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) &&& local.rev_curr f (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> rs.FINFUNC &&& local.rev_curr g (t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> rs.FINFUNC<\\STATESEP>by auto<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nlocal.rev_curr f m \\<noteq> local.rev_curr g m\nlocal.rev_curr f m \\<in> rs.FINFUNC\nlocal.rev_curr g m \\<in> rs.FINFUNC\n\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. st.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>unfolding st.max_fun_diff_def<\\STATESEP>3<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. st.maxim {a \\<in> Field (s *o t). f a \\<noteq> g a} = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)<\\STATESEP>proof (intro st.maxim_equality, unfold st.isMaxim_def Field_oprod, safe)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (4 subgoals):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s\n 2. m \\<in> Field t\n 3. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 4. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>show \"s.max_fun_diff (rev_curr f m) (rev_curr g m) \\<in> Field s\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s<\\STATESEP>using rs.max_fun_diff_in[OF diff2]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> {a \\<in> Field s. local.rev_curr f m a \\<noteq> local.rev_curr g m a}\n\ngoal (1 subgoal):\n 1. s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> Field s\n\ngoal (3 subgoals):\n 1. m \\<in> Field t\n 2. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 3. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (3 subgoals):\n 1. m \\<in> Field t\n 2. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 3. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>show \"m \\<in> Field t\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> Field t<\\STATESEP>using rst.max_fun_diff_in[OF diff1]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\n\ngoal (1 subgoal):\n 1. m \\<in> Field t<\\STATESEP>unfolding m_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\n\ngoal (1 subgoal):\n 1. t.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> Field t<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nm \\<in> Field t\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>assume \"f (s.max_fun_diff (rev_curr f m) (rev_curr g m), m) =\n            g (s.max_fun_diff (rev_curr f m) (rev_curr g m), m)\"\n           (is \"f (?x, m) = g (?x, m)\")<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nf (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>hence \"rev_curr f m ?x = rev_curr g m ?x\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal (1 subgoal):\n 1. local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))<\\STATESEP>unfolding rev_curr_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined), m) = g (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined), m)\n\ngoal (1 subgoal):\n 1. (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined)) = (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined) (s.max_fun_diff (if m \\<in> Field t then \\<lambda>a. f (a, m) else undefined) (if m \\<in> Field t then \\<lambda>a. g (a, m) else undefined))<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))\n\ngoal (2 subgoals):\n 1. f (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) = g (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<Longrightarrow> False\n 2. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>with rs.max_fun_diff[OF diff2]<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = a \\<and> local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = b\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))<\\STATESEP>show False<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<exists>a b. a \\<noteq> b \\<and> a \\<in> Field r \\<and> b \\<in> Field r \\<and> local.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = a \\<and> local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = b\nlocal.rev_curr f m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)) = local.rev_curr g m (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m))\n\ngoal (1 subgoal):\n 1. False<\\STATESEP>by auto<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nFalse\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>fix x y<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>assume \"f (x, y) \\<noteq> g (x, y)\" \"x \\<in> Field s\" \"y \\<in> Field t\"<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>f (a, b) \\<noteq> g (a, b); a \\<in> Field s; b \\<in> Field t\\<rbrakk> \\<Longrightarrow> ((a, b), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>thus \"((x, y), (s.max_fun_diff (rev_curr f m) (rev_curr g m), m)) \\<in> s *o t\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>using rst.max_fun_diff_in[OF diff1] rs.max_fun_diff_in[OF diff2] diff1 diff2\n        rst.max_fun_diff_max[OF diff1, of y] rs.max_fun_diff_le_eq[OF _ diff2, of x]<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\nt.max_fun_diff (local.rev_curr f) (local.rev_curr g) \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a}\ns.max_fun_diff (local.rev_curr f m) (local.rev_curr g m) \\<in> {a \\<in> Field s. local.rev_curr f m a \\<noteq> local.rev_curr g m a}\nlocal.rev_curr f \\<noteq> local.rev_curr g\nlocal.rev_curr f \\<in> rst.FINFUNC\nlocal.rev_curr g \\<in> rst.FINFUNC\nlocal.rev_curr f m \\<noteq> local.rev_curr g m\nlocal.rev_curr f m \\<in> rs.FINFUNC\nlocal.rev_curr g m \\<in> rs.FINFUNC\ny \\<in> {a \\<in> Field t. local.rev_curr f a \\<noteq> local.rev_curr g a} \\<Longrightarrow> (y, t.max_fun_diff (local.rev_curr f) (local.rev_curr g)) \\<in> t\n\\<lbrakk>(s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), x) \\<in> s; x \\<noteq> s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m)\\<rbrakk> \\<Longrightarrow> local.rev_curr f m x = local.rev_curr g m x\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t<\\STATESEP>unfolding oprod_def m_def rev_curr_def fun_eq_iff<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nf (x, y) \\<noteq> g (x, y)\nx \\<in> Field s\ny \\<in> Field t\nt.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> {a \\<in> Field t. \\<not> (\\<forall>x. (if a \\<in> Field t then \\<lambda>aa. f (aa, a) else undefined) x = (if a \\<in> Field t then \\<lambda>aa. g (aa, a) else undefined) x)}\ns.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> {a \\<in> Field s. (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) a \\<noteq> (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) a}\n\\<not> (\\<forall>x xa. (if x \\<in> Field t then \\<lambda>a. f (a, x) else undefined) xa = (if x \\<in> Field t then \\<lambda>a. g (a, x) else undefined) xa)\n(\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) \\<in> rst.FINFUNC\n(\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> rst.FINFUNC\n\\<not> (\\<forall>x. (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x = (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x)\n(if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> rs.FINFUNC\n(if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) \\<in> rs.FINFUNC\ny \\<in> {a \\<in> Field t. \\<not> (\\<forall>x. (if a \\<in> Field t then \\<lambda>aa. f (aa, a) else undefined) x = (if a \\<in> Field t then \\<lambda>aa. g (aa, a) else undefined) x)} \\<Longrightarrow> (y, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) \\<in> t\n\\<lbrakk>(s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined), x) \\<in> s; x \\<noteq> s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined)\\<rbrakk> \\<Longrightarrow> (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x = (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) x\n\ngoal (1 subgoal):\n 1. ((x, y), s.max_fun_diff (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. f (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined) (if t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined) \\<in> Field t then \\<lambda>a. g (a, t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) else undefined), t.max_fun_diff (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. f (a, b) else undefined) (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. g (a, b) else undefined)) \\<in> {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Field s \\<and> x2 \\<in> Field s \\<or> (y1, y2) \\<in> Restr Id (Field t) \\<and> (x1, x2) \\<in> s}<\\STATESEP>by (auto intro: s.in_notinI)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\n((x, y), s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m) \\<in> s *o t\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nst.max_fun_diff f g = (s.max_fun_diff (local.rev_curr f m) (local.rev_curr g m), m)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>lemma oexp_oexp: \"(r ^o s) ^o t =o r ^o (s *o t)\" (is \"?R =o ?L\")<\\STATESEP>0<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>proof (cases \"r = {}\")<\\STATESEP>1<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>case True<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nr = {}\n\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> rs.oexp ^o t =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> rs.oexp ^o t =o r ^o (s *o t)<\\STATESEP>interpret rst: wo_rel2 \"r ^o s\" t<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t<\\STATESEP>by unfold_locales (rule oexp_Well_order[OF r s], rule t)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. r = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. r \\<noteq> {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)<\\STATESEP>proof (cases \"s = {} \\<or> t = {}\")<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. s = {} \\<or> t = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>case True<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\ns = {} \\<or> t = {}\n\ngoal (2 subgoals):\n 1. s = {} \\<or> t = {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)\n 2. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>with \\<open>r = {}\\<close><\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nr = {}\ns = {} \\<or> t = {}<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nr = {}\ns = {} \\<or> t = {}\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)<\\STATESEP>by (auto simp: oexp_empty[OF oexp_Well_order[OF Well_order_empty s]]\n        intro!: ordIso_transitive[OF ordIso_symmetric[OF oone_ordIso] oone_ordIso]\n          ordIso_transitive[OF oone_ordIso_oexp[OF ordIso_symmetric[OF oone_ordIso] t] oone_ordIso])<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>next<\\STATESEP>4<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>case False<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>hence \"s *o t \\<noteq> {}\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. s *o t \\<noteq> {}<\\STATESEP>unfolding oprod_def Field_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\n\ngoal (1 subgoal):\n 1. {((x1, y1), x2, y2). (y1, y2) \\<in> t - Id \\<and> x1 \\<in> Domain s \\<union> Range s \\<and> x2 \\<in> Domain s \\<union> Range s \\<or> (y1, y2) \\<in> Restr Id (Domain t \\<union> Range t) \\<and> (x1, x2) \\<in> s} \\<noteq> {}<\\STATESEP>by fastforce<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\ns *o t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (s = {} \\<or> t = {}) \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>with False<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}<\\STATESEP>show ?thesis<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)<\\STATESEP>using \\<open>r = {}\\<close> ozero_ordIso<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\n\\<not> (s = {} \\<or> t = {})\ns *o t \\<noteq> {}\nr = {}\nozero =o ozero\n\ngoal (1 subgoal):\n 1. rst.oexp =o r ^o (s *o t)<\\STATESEP>by (auto simp add: s t oprod_Well_order ozero_def)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nrst.oexp =o r ^o (s *o t)\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> rst.oexp =o r ^o (s *o t)<\\STATESEP>next<\\STATESEP>2<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>case False<\\STATESEP>2<\\TRANSEP>proof (state)\nthis:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>hence Field: \"Field r \\<noteq> {}\"<\\STATESEP>2<\\TRANSEP>proof (prove)\nusing this:\nr \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Field r \\<noteq> {}<\\STATESEP>by (metis Field_def Range_empty_iff Un_empty)<\\STATESEP>3<\\TRANSEP>proof (state)\nthis:\nField r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r \\<noteq> {} \\<Longrightarrow> r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>show ?thesis<\\STATESEP>2<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. r ^o s ^o t =o r ^o (s *o t)<\\STATESEP>proof (rule ordIso_symmetric)<\\STATESEP>3<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r ^o (s *o t) =o r ^o s ^o t<\\STATESEP>interpret r_st: wo_rel2 r \"s *o t\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r (s *o t)<\\STATESEP>by unfold_locales (rule r, rule oprod_Well_order[OF s t])<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o r ^o s ^o t<\\STATESEP>interpret rs: wo_rel2 r s<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 r s<\\STATESEP>by unfold_locales (rule r, rule s)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o rs.oexp ^o t<\\STATESEP>interpret rst: wo_rel2 \"r ^o s\" t<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. wo_rel2 rs.oexp t<\\STATESEP>by unfold_locales (rule oexp_Well_order[OF r s], rule t)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>have bij: \"bij_betw rev_curr (Field ?L) (Field ?R)\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. bij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)<\\STATESEP>unfolding bij_betw_def r_st.Field_oexp rst.Field_oexp Field_oprod<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.rev_curr r_st.FINFUNC \\<and> local.rev_curr ` r_st.FINFUNC = rst.FINFUNC<\\STATESEP>proof (intro conjI)<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. inj_on local.rev_curr r_st.FINFUNC\n 2. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC<\\STATESEP>show \"inj_on rev_curr (FinFunc r (s *o t))\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.rev_curr r_st.FINFUNC<\\STATESEP>unfolding inj_on_def FinFunc_def Func_def Field_oprod rs.Field_oexp rev_curr_def[abs_def]<\\STATESEP>7<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t). \\<forall>y\\<in>{f. (\\<forall>a\\<in>Field s \\<times> Field t. f a \\<in> Field r) \\<and> (\\<forall>a. a \\<notin> Field s \\<times> Field t \\<longrightarrow> f a = undefined)} \\<inter> fin_support (zero r) (Field s \\<times> Field t). (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. x (a, b) else undefined) = (\\<lambda>b. if b \\<in> Field t then \\<lambda>a. y (a, b) else undefined) \\<longrightarrow> x = y<\\STATESEP>by (auto simp: fun_eq_iff) metis<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\ninj_on local.rev_curr r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC<\\STATESEP>show \"rev_curr ` (FinFunc r (s *o t)) = FinFunc (r ^o s) t\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. local.rev_curr ` r_st.FINFUNC = rst.FINFUNC<\\STATESEP>by (rule rev_curr_FinFunc[OF Field])<\\STATESEP>7<\\TRANSEP>proof (state)\nthis:\nlocal.rev_curr ` r_st.FINFUNC = rst.FINFUNC\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>moreover<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>have \"compat ?L ?R rev_curr\"<\\STATESEP>4<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. compat r_st.oexp rst.oexp local.rev_curr<\\STATESEP>unfolding compat_def<\\STATESEP>5<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. (a, b) \\<in> r_st.oexp \\<longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp<\\STATESEP>proof safe<\\STATESEP>5<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp<\\STATESEP>fix fg1 fg2<\\STATESEP>6<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp<\\STATESEP>assume fg: \"(fg1, fg2) \\<in> r ^o (s *o t)\"<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\n(fg1, fg2) \\<in> r_st.oexp\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> r_st.oexp \\<Longrightarrow> (local.rev_curr a, local.rev_curr b) \\<in> rst.oexp<\\STATESEP>show \"(rev_curr fg1, rev_curr fg2) \\<in> r ^o s ^o t\"<\\STATESEP>6<\\TRANSEP>proof (prove)\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>proof (cases \"fg1 = fg2\")<\\STATESEP>7<\\TRANSEP>proof (state)\ngoal (2 subgoals):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n 2. fg1 \\<noteq> fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>assume \"fg1 \\<noteq> fg2\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nfg1 \\<noteq> fg2\n\ngoal (2 subgoals):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n 2. fg1 \\<noteq> fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>with fg<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>using rst.max_fun_diff_in[of \"rev_curr fg1\" \"rev_curr fg2\"]\n          max_fun_diff_oprod[OF Field, of fg1 fg2]  rev_curr_FinFunc[OF Field, symmetric]<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>unfolding r_st.Field_oexp rs.Field_oexp rst.Field_oexp<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>unfolding r_st.oexp_def rst.oexp_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> {(f, g). f \\<in> r_st.FINFUNC \\<and> g \\<in> r_st.FINFUNC \\<and> ((let m = wo_rel.max_fun_diff (s *o t) f g in (f m, g m) \\<in> r) \\<or> f = g)}\nfg1 \\<noteq> fg2\n\\<lbrakk>local.rev_curr fg1 \\<noteq> local.rev_curr fg2; local.rev_curr fg1 \\<in> rst.FINFUNC; local.rev_curr fg2 \\<in> rst.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2) \\<in> {a \\<in> Field t. local.rev_curr fg1 a \\<noteq> local.rev_curr fg2 a}\n\\<lbrakk>fg1 \\<noteq> fg2; fg1 \\<in> r_st.FINFUNC; fg2 \\<in> r_st.FINFUNC\\<rbrakk> \\<Longrightarrow> wo_rel.max_fun_diff (s *o t) fg1 fg2 = (wo_rel.max_fun_diff s (local.rev_curr fg1 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))) (local.rev_curr fg2 (wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))), wo_rel.max_fun_diff t (local.rev_curr fg1) (local.rev_curr fg2))\nrst.FINFUNC = local.rev_curr ` r_st.FINFUNC\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> {(f, g). f \\<in> rst.FINFUNC \\<and> g \\<in> rst.FINFUNC \\<and> ((let m = wo_rel.max_fun_diff t f g in (f m, g m) \\<in> rs.oexp) \\<or> f = g)}<\\STATESEP>by (auto simp: rs.oexp_def Let_def) (auto simp: rev_curr_def[abs_def])<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>next<\\STATESEP>8<\\TRANSEP>proof (state)\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>assume \"fg1 = fg2\"<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. fg1 = fg2 \\<Longrightarrow> (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>with fg bij<\\STATESEP>8<\\TRANSEP>proof (chain)\npicking this:\n(fg1, fg2) \\<in> r_st.oexp\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\nfg1 = fg2<\\STATESEP>show ?thesis<\\STATESEP>8<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>unfolding r_st.Field_oexp rs.Field_oexp rst.Field_oexp bij_betw_def<\\STATESEP>9<\\TRANSEP>proof (prove)\nusing this:\n(fg1, fg2) \\<in> r_st.oexp\ninj_on local.rev_curr r_st.FINFUNC \\<and> local.rev_curr ` r_st.FINFUNC = rst.FINFUNC\nfg1 = fg2\n\ngoal (1 subgoal):\n 1. (local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp<\\STATESEP>by (auto simp: r_st.oexp_def rst.oexp_def)<\\STATESEP>9<\\TRANSEP>proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>8<\\TRANSEP>proof (state)\nthis:\n(local.rev_curr fg1, local.rev_curr fg2) \\<in> rst.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>6<\\TRANSEP>proof (state)\nthis:\ncompat r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>ultimately<\\STATESEP>4<\\TRANSEP>proof (chain)\npicking this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr<\\STATESEP>have \"iso ?L ?R rev_curr\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. iso r_st.oexp rst.oexp local.rev_curr<\\STATESEP>using r s t<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\nbij_betw local.rev_curr (Field r_st.oexp) (Field rst.oexp)\ncompat r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. iso r_st.oexp rst.oexp local.rev_curr<\\STATESEP>by (subst iso_iff3) (auto intro: oexp_Well_order oprod_Well_order)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\niso r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>thus \"?L =o ?R\"<\\STATESEP>4<\\TRANSEP>proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>using r s t<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. r_st.oexp =o rst.oexp<\\STATESEP>unfolding ordIso_def<\\STATESEP>5<\\TRANSEP>proof (prove)\nusing this:\niso r_st.oexp rst.oexp local.rev_curr\nWell_order r\nWell_order s\nWell_order t\n\ngoal (1 subgoal):\n 1. (r_st.oexp, rst.oexp) \\<in> {(r, r'). Well_order r \\<and> Well_order r' \\<and> Ex (iso r r')}<\\STATESEP>by (auto intro: oexp_Well_order oprod_Well_order)<\\STATESEP>5<\\TRANSEP>proof (state)\nthis:\nr_st.oexp =o rst.oexp\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>4<\\TRANSEP>proof (state)\nthis:\nr ^o s ^o t =o r ^o (s *o t)\n\ngoal:\nNo subgoals!<\\STATESEP>qed<\\STATESEP>2<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP><\\STATESEP>end<\\STATESEP>0<\\TRANSEP>",
    "theory_file_path": "/home/ubuntu/Isabelle2022/src/HOL/Cardinals/Ordinal_Arithmetic.thy",
    "working_directory": "/home/ubuntu/Isabelle2022/src/HOL/Cardinals"
}